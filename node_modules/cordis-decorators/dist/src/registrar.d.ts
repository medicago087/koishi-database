import 'reflect-metadata';
import { AcceptOptions, Context, GetEvents } from 'cordis';
import { ClassType } from 'schemastery-gen';
import { MetadataSetter, Reflector } from 'typed-reflector';
import type { Awaitable, Condition, ControlType, PartialDeep, TypedMethodDecorator } from './def';
import { RegistrarAspect } from './registrar-aspect';
import Schema from 'schemastery';
import { PluginRegistrar } from './plugin-def';
import { RegisterMeta } from './utility/register-meta';
declare module 'cordis' {
    interface Context {
        __parent?: any;
    }
}
export declare namespace Registrar {
    interface MetadataArrayMap {
        CordisRegisterKeys: string;
        CordisContextTransformer: RegisterMeta<ContextTransformer<Context>>;
        CordisTopLevelAction: RegisterMeta<TopLevelActionDef<Context>>;
        CordisContextLayers: RegisterMeta<ContextCallbackLayer<Context>>;
        CordisControl: ControlType;
        CordisPluginUsing: string;
        CordisPluginProvide: ProvideDefinition<Context>;
        CordisPluginInjectKeys: string;
        CordisPluginSystemKeys: string;
        CordisConfigAcceptors: (ctx: Context) => any;
    }
    interface MetadataMap {
        CordisRegister: MethodMeta<Context>;
        CordisPluginInject: string;
        CordisPluginSystem: PluginRegistrar.SystemInjectFun<Context>;
        CordisPluginPredefineSchema: Schema | ClassType<any>;
        CordisPluginPredefineName: string;
        CordisPluginFork: PluginRegistrar.PluginClass<Context>;
        CordisPluginReusable: boolean;
        CordisPluginReactive: boolean;
    }
    type DecorateFunctionParam<Ctx extends Context, A extends any[] = any[], R = any> = (ctx: Ctx, ...args: A) => R;
    type DecorateFunctionParamSingle<Ctx extends Context, P, A extends any[] = any[], R = any> = (ctx: Ctx, param: P, ...args: A) => R;
    interface MethodResolveInfo<Ctx extends Context> {
        ctx: Ctx;
        obj: any;
        key: string;
        view: any;
    }
    type MethodResolver<Ctx extends Context, A extends any[] = any[], F extends (...args: any[]) => any = (...args: any[]) => any> = (info: MethodResolveInfo<Ctx>, fun: F, ...args: A) => any;
    type MethodMeta<Ctx extends Context> = RegisterMeta<MethodResolver<Ctx>, {
        type: string;
    }>;
    type RegisterResult<Ctx extends Context, T> = Omit<MethodMeta<Ctx>, 'run'> & {
        type: string;
        key: keyof T & string;
        result: any;
        ctx: Ctx;
    };
    interface ProvideOptions {
        immediate?: boolean;
        internal?: boolean;
    }
    interface ProvideDefinition<C extends Context> extends ProvideOptions {
        serviceName: string;
    }
    type ContextFunction<Ctx extends Context, T> = DecorateFunctionParam<Ctx, [
    ], T>;
    type ContextTransformer<Ctx extends Context, A extends any[] = any[]> = DecorateFunctionParam<Ctx, A, Ctx>;
    type ContextCallbackLayer<Ctx extends Context, A extends any[] = any[]> = DecorateFunctionParamSingle<Ctx, ContextFunction<Ctx, void>, A>;
    type TopLevelActionDef<Ctx extends Context, A extends any[] = any[]> = DecorateFunctionParamSingle<Ctx, any, A>;
}
export declare class Registrar<Ctx extends Context> {
    contextClass: ClassType<Ctx>;
    metadata: MetadataSetter<Registrar.MetadataMap, Registrar.MetadataArrayMap>;
    reflector: Reflector<Registrar.MetadataMap, Registrar.MetadataArrayMap>;
    constructor(contextClass: ClassType<Ctx>);
    aspect<T>(obj: T, view?: Record<any, any>): RegistrarAspect<Ctx, T>;
    decorateMethod<A extends any[], F extends (...args: any[]) => any>(type: string, action: Registrar.MethodResolver<Ctx, A, F>): (...args: A) => TypedMethodDecorator<F>;
    decorateTransformer<A extends any[]>(transformer: Registrar.ContextTransformer<Ctx, A>): (...args: A) => ClassDecorator & MethodDecorator;
    decorateTopLevelAction<A extends any[]>(action: Registrar.TopLevelActionDef<Ctx, A>): (...args: A) => ClassDecorator;
    decorateContextLayer<A extends any[]>(action: Registrar.ContextCallbackLayer<Ctx, A>): (...args: A) => ClassDecorator & MethodDecorator;
    private getFork;
    afterPluginMethodRegistration(result: Registrar.RegisterResult<Ctx, any>): void;
    getConfigAcceptors(configClass: any): ((ctx: Context<any>) => any)[];
    plugin<T>(options?: PluginRegistrar.PluginRegistrationOptions<Ctx, T>): <C extends PluginRegistrar.PluginClass<Ctx, T>>(plugin: C) => C & PluginRegistrar.PluginRegistrationOptions<Ctx, T>;
    methodDecorators(): {
        UseEvent: (event: keyof GetEvents<Ctx>, prepend?: boolean) => TypedMethodDecorator<(...args: any[]) => any>;
        UsePlugin: () => TypedMethodDecorator<(...args: any[]) => Awaitable<PluginRegistrar.PluginDefinition<Ctx>>>;
        Apply: () => TypedMethodDecorator<(...args: any[]) => any>;
    };
    scopeDecorators(): {
        If: <T>(func: Condition<boolean, T, [Record<string, any>]>) => MethodDecorator;
        For: <T_1>(func: Condition<Iterable<Record<string, any>>, T_1, [Record<string, any>]>) => MethodDecorator;
        Isolate: (...args: string[]) => ClassDecorator & MethodDecorator;
        UsingService: (...services: string[]) => ClassDecorator & MethodDecorator;
    };
    pluginDecorators(): {
        PluginName: (name: string) => import("typed-reflector").AllDecorators;
        PluginSchema: (schema: Schema | ClassType<any>) => import("typed-reflector").AllDecorators;
        Reusable: (reusable?: boolean) => import("typed-reflector").AllDecorators;
        Reactive: (reactive?: boolean) => import("typed-reflector").AllDecorators;
        Fork: (fork: PluginRegistrar.PluginClass<Ctx>) => import("typed-reflector").AllDecorators;
        Provide: (name: string, options?: Registrar.ProvideOptions) => ClassDecorator;
        Inject: (args_0?: string | boolean, args_1?: boolean) => PropertyDecorator;
        InjectSystem: (fun: PluginRegistrar.SystemInjectFun<Ctx>) => import("typed-reflector").AllDecorators;
        InjectContext: () => import("typed-reflector").AllDecorators;
        InjectConfig: () => import("typed-reflector").AllDecorators;
        InjectParent: () => import("typed-reflector").AllDecorators;
        Caller: () => import("typed-reflector").AllDecorators;
        DefinePlugin: <T>(options?: PluginRegistrar.PluginRegistrationOptions<Ctx, T>) => <C extends PluginRegistrar.PluginClass<Ctx, T, any>>(plugin: C) => C & PluginRegistrar.PluginRegistrationOptions<Ctx, T>;
        AcceptWhen: (keys?: string[], options?: AcceptOptions) => TypedMethodDecorator<(config: any) => boolean>;
    };
    transformContext<_Ctx extends Ctx>(ctx: _Ctx, filters: RegisterMeta<Registrar.ContextTransformer<Ctx>>[], view: any): _Ctx;
    starterPluginFactory(): <C>(config?: ClassType<C>) => {
        new (ctx: Ctx, config: PartialDeep<C>): {
            ctx: Ctx;
            config: C;
        };
    };
}
export declare const defaultRegistrar: Registrar<Context<any>>;
export declare class BasePlugin<Ctx extends Context, C, PC = PartialDeep<C>> {
    ctx: Ctx;
    constructor(ctx: Ctx, config: PC);
    config: C;
}
