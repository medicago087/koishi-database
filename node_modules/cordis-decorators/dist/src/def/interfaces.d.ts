export declare type Awaitable<T> = [T] extends [Promise<unknown>] ? T : T | Promise<T>;
export declare type TypedMethodDecorator<F extends (...args: any[]) => any> = <T extends F>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => void;
export declare type ParamRenderer = <T>(v: T) => T;
export interface ControlTypeMap {
    if: boolean;
    for: Iterable<Record<string, any>>;
}
export declare type Condition<R, T = any, Ext extends any[] = []> = (o: T, ...ext: Ext) => R;
export interface ControlType<T extends keyof ControlTypeMap = keyof ControlTypeMap> {
    type: T;
    condition: Condition<ControlTypeMap[T], any, [Record<string, any>]>;
}
export declare type TypeFromClass<T> = T extends {
    new (...args: any[]): infer U;
} ? U : never;
export declare type ParamsFromClass<T> = T extends {
    new (...args: infer U): any;
} ? U : never;
export declare type FunctionParams<F extends (...args: any[]) => any> = F extends (...args: infer U) => any ? U : never;
export declare type FunctionReturn<F extends (...args: any[]) => any> = F extends (...args: any) => infer U ? U : never;
export declare type Prop<T> = T;
export declare type PartialDeep<T> = T extends string | number | bigint | boolean | null | undefined | symbol | Date | Function ? T | undefined : T extends Array<infer ArrayType> ? Array<PartialDeep<ArrayType>> : T extends ReadonlyArray<infer ArrayType> ? ReadonlyArray<ArrayType> : T extends Set<infer SetType> ? Set<PartialDeep<SetType>> : T extends ReadonlySet<infer SetType> ? ReadonlySet<SetType> : T extends Map<infer KeyType, infer ValueType> ? Map<PartialDeep<KeyType>, PartialDeep<ValueType>> : T extends ReadonlyMap<infer KeyType, infer ValueType> ? ReadonlyMap<PartialDeep<KeyType>, PartialDeep<ValueType>> : {
    [K in keyof T]?: PartialDeep<T[K]>;
};
