"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePlugin = exports.defaultRegistrar = exports.Registrar = void 0;
require("reflect-metadata");
const cordis_1 = require("cordis");
const schemastery_gen_1 = require("schemastery-gen");
const typed_reflector_1 = require("typed-reflector");
const registrar_aspect_1 = require("./registrar-aspect");
const lodash_1 = __importDefault(require("lodash"));
const register_meta_1 = require("./utility/register-meta");
const ThirdEyeSym = Symbol('ThirdEyeSym');
class Registrar {
    constructor(contextClass) {
        this.contextClass = contextClass;
        this.metadata = new typed_reflector_1.MetadataSetter();
        this.reflector = new typed_reflector_1.Reflector();
    }
    aspect(obj, view = {}) {
        return new registrar_aspect_1.RegistrarAspect(this, obj, view);
    }
    decorateMethod(type, action) {
        return (...args) => this.metadata.set('CordisRegister', new register_meta_1.RegisterMeta(action, args, { type }), 'CordisRegisterKeys');
    }
    decorateTransformer(transformer) {
        return (...args) => this.metadata.append('CordisContextTransformer', new register_meta_1.RegisterMeta(transformer, args));
    }
    decorateTopLevelAction(action) {
        return (...args) => this.metadata.append('CordisTopLevelAction', new register_meta_1.RegisterMeta(action, args));
    }
    decorateContextLayer(action) {
        return (...args) => this.metadata.append('CordisContextLayers', new register_meta_1.RegisterMeta(action, args));
    }
    getFork(obj) {
        const fork = this.reflector.get('CordisPluginFork', obj);
        if (!fork) {
            return;
        }
        return this.plugin()(fork);
    }
    afterPluginMethodRegistration(result) {
        // for override
    }
    getConfigAcceptors(configClass) {
        if (!configClass) {
            return [];
        }
        return this.reflector.getArray('CordisConfigAcceptors', configClass);
    }
    plugin(options = {}) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const _this = this;
        const reflector = this.reflector;
        return (originalClass) => {
            if (options.name) {
                _this.pluginDecorators().PluginName(options.name)(originalClass);
            }
            if (options.schema) {
                _this.pluginDecorators().PluginSchema(options.schema)(originalClass);
            }
            if (options.using) {
                _this.scopeDecorators().UsingService(...options.using)(originalClass);
            }
            if (originalClass[ThirdEyeSym]) {
                return originalClass;
            }
            const newClass = class extends originalClass {
                constructor(...args) {
                    const originalCtx = args[0];
                    const config = originalCtx.config;
                    const ctx = _this
                        .aspect(newClass, config)
                        .getScopeContext(originalCtx);
                    super(ctx, config, ...args.slice(2));
                    this.__ctx = ctx;
                    this.__pluginOptions = options;
                    this.__registrar = _this.aspect(this, config);
                    this.__promisesToWaitFor = [];
                    this.__disposables = [];
                    this._initializePluginClass();
                }
                static get Config() {
                    const schemaType = reflector.get('CordisPluginPredefineSchema', newClass);
                    return schemaType ? (0, schemastery_gen_1.SchemaClass)(schemaType) : undefined;
                }
                static get using() {
                    let list = reflector.getArray('CordisPluginUsing', newClass);
                    const fork = _this.getFork(newClass);
                    if (fork) {
                        list = [...list, ...fork.using];
                    }
                    return lodash_1.default.uniq(list);
                }
                static get reusable() {
                    return reflector.get('CordisPluginReusable', newClass);
                }
                static get reactive() {
                    return reflector.get('CordisPluginReactive', newClass);
                }
                _handleSystemInjections() {
                    const injectKeys = reflector.getArray('CordisPluginSystemKeys', this);
                    for (const key of injectKeys) {
                        const valueFunction = reflector.get('CordisPluginSystem', this, key);
                        if (!valueFunction) {
                            continue;
                        }
                        Object.defineProperty(this, key, {
                            configurable: true,
                            enumerable: true,
                            get: () => valueFunction(this, newClass),
                        });
                    }
                }
                _handleServiceInjections() {
                    const injectKeys = reflector.getArray('CordisPluginInjectKeys', this);
                    for (const key of injectKeys) {
                        const name = reflector.get('CordisPluginInject', this, key);
                        if (!name) {
                            continue;
                        }
                        Object.defineProperty(this, key, {
                            enumerable: true,
                            configurable: true,
                            get: () => {
                                return this.__ctx[name];
                            },
                            set: (val) => {
                                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                                // @ts-ignore
                                this.__ctx[name] = val;
                            },
                        });
                    }
                }
                _registerDeclarations() {
                    this.__registrar.register(this.__ctx).subscribe({
                        next: (v) => {
                            if (!v) {
                                return;
                            }
                            const mayBePromise = v.result;
                            if (mayBePromise instanceof Promise) {
                                this.__promisesToWaitFor.push(mayBePromise);
                            }
                            _this.afterPluginMethodRegistration(v);
                        },
                    });
                }
                _handleConfigAcceptors() {
                    const acceptors = _this.getConfigAcceptors(newClass.Config);
                    acceptors.forEach((acceptor) => acceptor(this.__ctx));
                }
                _getProvidingServices() {
                    return reflector.getArray('CordisPluginProvide', this);
                }
                _handleServiceProvide(immediate) {
                    const providingServices = this._getProvidingServices().filter((serviceDef) => !serviceDef.immediate === !immediate);
                    for (const key of providingServices) {
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        this.__ctx[key.serviceName] = this;
                    }
                }
                _initializeFork() {
                    const fork = _this.getFork(this);
                    if (!fork) {
                        return;
                    }
                    this.__ctx.on('fork', (ctx, options) => {
                        ctx.__parent = this;
                        const instance = new fork(ctx, options);
                        ctx.on('dispose', () => {
                            if (typeof this.onForkDisconnect === 'function') {
                                this.onForkDisconnect(instance);
                            }
                            delete ctx.__parent;
                        });
                        if (typeof this.onFork === 'function') {
                            this.onFork(instance);
                        }
                    });
                }
                _uninstallServiceProvide() {
                    const providingServices = this._getProvidingServices();
                    for (const key of providingServices) {
                        if (this.__ctx[key.serviceName] === this) {
                            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                            // @ts-ignore
                            this.__ctx[key.serviceName] = null;
                        }
                    }
                }
                _registerAfterInit() {
                    this.__ctx.on('ready', async () => {
                        if (this.__promisesToWaitFor.length) {
                            await Promise.all(this.__promisesToWaitFor);
                            this.__promisesToWaitFor = [];
                        }
                        if (typeof this.onConnect === 'function') {
                            await this.onConnect();
                        }
                        this._handleServiceProvide(false);
                    });
                    this.__ctx.on('dispose', async () => {
                        this._uninstallServiceProvide();
                        if (typeof this.onDisconnect === 'function') {
                            await this.onDisconnect();
                        }
                        this.__disposables.forEach((dispose) => dispose());
                        delete this.__ctx;
                        delete this.__pluginOptions;
                        delete this.__registrar;
                        delete this.__promisesToWaitFor;
                        delete this.__disposables;
                    });
                }
                _initializePluginClass() {
                    this._handleSystemInjections();
                    this._handleServiceInjections();
                    this.__registrar.performTopActions(this.__ctx);
                    this._registerDeclarations();
                    this._handleConfigAcceptors();
                    if (typeof this.onApply === 'function') {
                        this.onApply();
                    }
                    this._handleServiceProvide(true);
                    this._initializeFork();
                    this._registerAfterInit();
                }
            };
            Object.defineProperty(newClass, 'name', {
                enumerable: true,
                configurable: true,
                get: () => {
                    const nameFromMeta = reflector.get('CordisPluginPredefineName', newClass);
                    if (nameFromMeta) {
                        return nameFromMeta;
                    }
                    const nameFromFork = _this.getFork(newClass)?.name;
                    if (nameFromFork) {
                        return nameFromFork;
                    }
                    return originalClass.name;
                },
            });
            newClass[ThirdEyeSym] = true;
            return newClass;
        };
    }
    methodDecorators() {
        return {
            UseEvent: this.decorateMethod('on', ({ ctx }, fun, event, prepend) => ctx.on(event, fun, prepend)),
            UsePlugin: this.decorateMethod('plugin', ({ ctx }, fun) => {
                const result = fun();
                const register = (def) => {
                    if (!def) {
                        return;
                    }
                    return ctx.plugin(def.plugin, def.options);
                };
                if (result instanceof Promise) {
                    return result.then(register);
                }
                else {
                    return register(result);
                }
            }),
            Apply: this.decorateMethod('apply', (info, fun) => fun()),
        };
    }
    scopeDecorators() {
        return {
            If: (func) => this.metadata.append('CordisControl', {
                type: 'if',
                condition: func,
            }),
            For: (func) => this.metadata.append('CordisControl', {
                type: 'for',
                condition: func,
            }),
            Isolate: this.decorateTransformer((ctx, ...services) => ctx.isolate(services)),
            UsingService: (...services) => {
                return (obj, key) => {
                    if (!key) {
                        services.forEach((service) => this.metadata.appendUnique('CordisPluginUsing', service)(obj));
                    }
                    else {
                        const dec = this.decorateContextLayer((ctx, cb) => ctx.using(services, cb));
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        dec()(obj, key);
                    }
                };
            },
        };
    }
    pluginDecorators() {
        const InjectSystem = (fun) => this.metadata.set('CordisPluginSystem', fun, 'CordisPluginSystemKeys');
        return {
            PluginName: (name) => this.metadata.set('CordisPluginPredefineName', name),
            PluginSchema: (schema) => this.metadata.set('CordisPluginPredefineSchema', schema),
            Reusable: (reusable = true) => this.metadata.set('CordisPluginReusable', reusable),
            Reactive: (reactive = true) => this.metadata.set('CordisPluginReactive', reactive),
            Fork: (fork) => this.metadata.set('CordisPluginFork', fork),
            Provide: (name, options) => {
                if (options?.internal) {
                    return (cls) => {
                        cordis_1.Context.service(name, cls);
                    };
                }
                cordis_1.Context.service(name);
                return this.metadata.append('CordisPluginProvide', {
                    ...options,
                    serviceName: name,
                });
            },
            Inject: (...args) => {
                let name;
                let addUsing = false;
                if (args.length === 1) {
                    if (typeof args[0] === 'boolean') {
                        addUsing = args[0];
                    }
                    else {
                        name = args[0];
                    }
                }
                else if (args.length >= 2) {
                    name = args[0];
                    addUsing = args[1];
                }
                return (obj, key) => {
                    const serviceName = name || key;
                    if (addUsing) {
                        this.metadata.appendUnique('CordisPluginUsing', serviceName)(obj.constructor);
                    }
                    const dec = this.metadata.set('CordisPluginInject', serviceName, 'CordisPluginInjectKeys');
                    return dec(obj, key);
                };
            },
            InjectSystem,
            InjectContext: () => InjectSystem((obj) => obj.__ctx),
            InjectConfig: () => InjectSystem((obj) => obj.__ctx.config),
            InjectParent: () => InjectSystem((obj) => obj.__ctx.__parent),
            Caller: () => InjectSystem((obj) => {
                const targetCtx = obj[cordis_1.Context.current] || obj.__ctx;
                return targetCtx;
            }),
            DefinePlugin: (options) => this.plugin(options),
            AcceptWhen: this.decorateMethod('accept', ({ ctx }, fun, keys, options) => {
                if (keys?.length) {
                    ctx.accept(keys, fun, options);
                }
                else {
                    ctx.accept(fun, options);
                }
            }),
        };
    }
    transformContext(ctx, filters, view) {
        let targetCtx = ctx;
        for (const fun of filters) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            targetCtx = fun.run(view, ctx) || targetCtx;
        }
        return targetCtx;
    }
    starterPluginFactory() {
        return (config) => {
            const plugin = class StarterPluginBase extends BasePlugin {
            };
            if (config) {
                this.pluginDecorators().PluginSchema(config)(plugin);
            }
            return plugin;
        };
    }
}
exports.Registrar = Registrar;
exports.defaultRegistrar = new Registrar(cordis_1.Context);
class BasePlugin {
    constructor(ctx, config) {
        this.ctx = ctx;
    }
}
__decorate([
    exports.defaultRegistrar.pluginDecorators().InjectConfig(),
    __metadata("design:type", Object)
], BasePlugin.prototype, "config", void 0);
exports.BasePlugin = BasePlugin;
//# sourceMappingURL=registrar.js.map