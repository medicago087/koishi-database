"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistrarAspect = void 0;
const utility_1 = require("./utility/utility");
const rxjs_1 = require("rxjs");
const lodash_1 = __importDefault(require("lodash"));
class RegistrarAspect {
    constructor(registrar, obj, view = {}) {
        this.registrar = registrar;
        this.obj = obj;
        this.view = view;
    }
    getAllFieldsToRegister() {
        const arr = this.registrar.reflector
            .getArray('CordisRegisterKeys', this.obj)
            .filter((k) => typeof k === 'string');
        return arr;
    }
    getScopeContext(ctx, key, extraView = {}, autoScope = true) {
        if (key && autoScope) {
            ctx = this.getScopeContext(ctx);
        }
        const contextFilters = this.registrar.reflector.getArray('CordisContextTransformer', this.obj, key);
        return this.registrar.transformContext(ctx, contextFilters, { ...this.view, ...extraView });
    }
    registerMethod(ctx, key, extraView = {}) {
        const data = this.registrar.reflector.get('CordisRegister', this.obj, key);
        if (!data)
            return;
        const specificCtx = this.getScopeContext(ctx, key, extraView, false);
        const view = { ...this.view, ...extraView };
        const result = data.run(view, { ctx: specificCtx, obj: this.obj, key, view }, (0, utility_1.extractObjectMethod)(this.obj, key));
        return {
            ...data,
            type: data.info.type,
            key: key,
            result,
            ctx: specificCtx,
        };
    }
    registerWithLoopControl(ctx, key, stack, existing = {}) {
        if (!stack.length) {
            const result = this.registerMethod(ctx, key, existing);
            return result ? [result] : [];
        }
        const rest = [...stack];
        const control = rest.pop();
        switch (control.type) {
            case 'if':
                if (!control.condition(this.obj, existing))
                    return [];
                return this.registerWithLoopControl(ctx, key, rest, existing);
            case 'for':
                return Array.from(control.condition(this.obj, existing)).flatMap((item) => this.registerWithLoopControl(ctx, key, rest, {
                    ...existing,
                    ...item,
                }));
        }
    }
    runLayersWith(ctx, cb, layers) {
        const rest = [...layers];
        const layer = rest.pop();
        if (!layer) {
            return (0, rxjs_1.from)(cb(ctx));
        }
        return new rxjs_1.Observable((subscriber) => {
            layer.run(this.view, ctx, async (nextCtx) => {
                if (!rest.length) {
                    const result = cb(nextCtx);
                    if (result) {
                        const tmpObs = (0, rxjs_1.from)(result);
                        tmpObs.subscribe({
                            next: (v) => subscriber.next(v),
                            // no error
                            // no complete
                        });
                    }
                }
                else {
                    this.runLayersWith(nextCtx, cb, rest).subscribe(subscriber);
                }
            });
        });
    }
    runLayers(ctx, cb, key) {
        const layers = this.registrar.reflector.getArray('CordisContextLayers', this.obj, key);
        return this.runLayersWith(ctx, cb, layers);
    }
    registerFor(ctx, key) {
        const stack = this.registrar.reflector.getArray('CordisControl', this.obj, key);
        return this.runLayers(ctx, (innerCtx) => this.registerWithLoopControl(innerCtx, key, stack), key);
    }
    register(ctx) {
        const keys = this.getAllFieldsToRegister();
        return this.runLayers(ctx, (innerCtx) => keys.map((key) => this.registerFor(innerCtx, key))).pipe((0, rxjs_1.mergeMap)((v) => v));
    }
    performTopActions(ctx, autoScope = false, extraView = {}) {
        if (autoScope) {
            ctx = this.getScopeContext(ctx);
        }
        const actions = lodash_1.default.uniq(this.registrar.reflector.getArray('CordisTopLevelAction', this.obj));
        actions.forEach((action) => action.run({ ...this.view, ...extraView }, ctx, this.obj));
    }
}
exports.RegistrarAspect = RegistrarAspect;
//# sourceMappingURL=registrar-aspect.js.map