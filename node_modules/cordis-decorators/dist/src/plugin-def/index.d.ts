import { Context, Plugin } from 'cordis';
import Schema from 'schemastery';
import { ClassType } from 'schemastery-gen';
export declare namespace PluginRegistrar {
    type PluginClass<Ctx extends Context, C = any, P = any> = new (ctx: Ctx, config: C) => P;
    type SystemInjectFun<Ctx extends Context> = <T = any>(obj: PluginMeta<Ctx, T>, cl: PluginClass<Ctx>) => any;
    interface PluginRegistrationOptions<Ctx extends Context, T = any> {
        name?: string;
        schema?: Schema<T> | ClassType<T>;
        Config?: Schema<T> | ClassType<T>;
        using?: string[];
        reusable?: boolean;
    }
    interface PluginMeta<Ctx extends Context, T = any> {
        __ctx: Ctx;
        __pluginOptions: PluginRegistrationOptions<Ctx, T>;
        __promisesToWaitFor: Promise<void>[];
        __disposables: (() => void)[];
    }
    type PluginOptions<T extends Plugin> = boolean | Plugin.Config<T>;
    interface PluginDefinitionExact<Ctx extends Context, T extends Plugin<Ctx>> {
        plugin: T;
        options?: boolean | PluginOptions<T>;
    }
    interface PluginDefinitionName {
        plugin: string;
        options?: any;
    }
    type PluginDefinition<Ctx extends Context, T extends Plugin = any> = PluginDefinitionExact<Ctx, T> | PluginDefinitionName;
    type ClassPluginConfig<P extends PluginClass<Context>> = P extends PluginClass<Context, infer C> ? C : never;
    type ExactClassPluginConfig<P extends PluginClass<Context>> = P extends PluginClass<Context, any, {
        config: infer IC;
    }> ? IC : ClassPluginConfig<P>;
    type ContextFromPlugin<P extends PluginClass<Context>> = P extends PluginClass<infer Ctx> ? Ctx : never;
}
export declare function PluginDef(name: string, options?: any): PluginRegistrar.PluginDefinitionName;
export declare function PluginDef<Ctx extends Context, T extends Plugin>(plugin: T, options?: PluginRegistrar.PluginOptions<T>): PluginRegistrar.PluginDefinitionExact<Ctx, T>;
export interface LifecycleEvents {
    onApply?(): void;
    onConnect?(): void | Promise<void>;
    onDisconnect?(): void | Promise<void>;
    onFork?(instance: any): void | Promise<void>;
    onForkDisconnect?(instance: any): void | Promise<void>;
}
