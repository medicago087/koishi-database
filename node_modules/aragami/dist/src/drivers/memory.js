"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryDriver = void 0;
const lru_cache_1 = __importDefault(require("lru-cache"));
const base_driver_1 = require("../base-driver");
const better_lock_1 = __importDefault(require("better-lock"));
class MemoryDriver extends base_driver_1.BaseDriver {
    constructor() {
        super(...arguments);
        this.cacheMap = new Map();
        this.betterLock = new better_lock_1.default();
    }
    async destroy() {
        for (const cache of this.cacheMap.values()) {
            cache.clear();
        }
        this.cacheMap.clear();
    }
    getCacheInstance(baseKey) {
        if (!this.cacheMap.has(baseKey)) {
            this.cacheMap.set(baseKey, new lru_cache_1.default({
                ttl: 1,
                updateAgeOnGet: false,
                updateAgeOnHas: false,
            }));
        }
        return this.cacheMap.get(baseKey);
    }
    async get(baseKey, key) {
        const cache = this.getCacheInstance(baseKey);
        return cache.get(key);
    }
    async set(baseKey, key, value, ttl) {
        const cache = this.getCacheInstance(baseKey);
        cache.set(key, value, { ttl });
    }
    async del(baseKey, key) {
        const cache = this.getCacheInstance(baseKey);
        return cache.delete(key);
    }
    async keys(baseKey, prefix) {
        const cache = this.getCacheInstance(baseKey);
        let keys = Array.from(cache.keys());
        if (prefix) {
            keys = keys.filter((key) => key.startsWith(prefix));
        }
        return keys;
    }
    async clear(baseKey, prefix) {
        const cache = this.getCacheInstance(baseKey);
        if (prefix) {
            const keys = Array.from(cache.keys());
            for (const key of keys) {
                if (key.startsWith(prefix)) {
                    cache.delete(key);
                }
            }
        }
        else {
            cache.clear();
        }
    }
    lock(keys, cb) {
        return this.betterLock.acquire(keys, cb);
    }
}
exports.MemoryDriver = MemoryDriver;
//# sourceMappingURL=memory.js.map