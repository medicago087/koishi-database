"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Aragami = void 0;
const redis_1 = require("./drivers/redis");
const memory_1 = require("./drivers/memory");
const metadata_1 = require("./metadata");
const class_transformer_1 = require("class-transformer");
const encoded_buffer_1 = require("encoded-buffer");
const utility_1 = require("./utility/utility");
const lodash_1 = __importDefault(require("lodash"));
class Aragami {
    constructor(options = {}) {
        this.options = options;
        this.driver = options.redis
            ? new redis_1.RedisDriver(options.redis)
            : new memory_1.MemoryDriver();
    }
    getBaseKey(o) {
        if (typeof o === 'string') {
            return o;
        }
        const keyFromMetadata = metadata_1.reflector.get('AragamiCachePrefix', o);
        if (keyFromMetadata) {
            return keyFromMetadata;
        }
        const keyFromConstructor = typeof o === 'function' ? o.name : o.constructor?.name;
        if (keyFromConstructor) {
            return keyFromConstructor;
        }
        return 'default';
    }
    async getKey(o, prototype) {
        if (typeof o === 'string') {
            return o;
        }
        if (prototype) {
            o = (0, class_transformer_1.plainToInstance)(prototype, o);
        }
        const keyTransformer = metadata_1.reflector.get('AragamiCacheKey', o);
        if (!keyTransformer) {
            throw new Error(`No key metadata found for ${o.constructor.name}`);
        }
        return await keyTransformer(o);
    }
    getTTL(o) {
        return metadata_1.reflector.get('AragamiCacheTTL', o) ?? this.options.defaultTTL ?? 0;
    }
    encode(o) {
        return (0, encoded_buffer_1.encode)((0, class_transformer_1.instanceToPlain)(o));
    }
    decode(cl, value) {
        return (0, class_transformer_1.plainToInstance)(cl, (0, encoded_buffer_1.decode)(value)[0]);
    }
    async get(cl, key) {
        const value = await this.driver.get(this.getBaseKey(cl), key);
        if (!value) {
            return;
        }
        return this.decode(cl, value);
    }
    async set(...args) {
        let prototype;
        let o;
        let options;
        const firstArg = args[0];
        if (typeof firstArg === 'function') {
            prototype = firstArg;
            o = args[1];
            options = args[2] || {};
        }
        else {
            o = firstArg;
            options = args[1] || {};
            prototype = options.prototype;
        }
        if (!o) {
            return o;
        }
        if (prototype) {
            o = (0, class_transformer_1.plainToInstance)(prototype, o);
        }
        const buf = this.encode(o);
        await this.driver.set(this.getBaseKey(o), options.key || (await this.getKey(o)), buf, options.ttl ?? this.getTTL(o));
        return o;
    }
    async has(base, key) {
        return this.driver.has(this.getBaseKey(base), key || (await this.getKey(base)));
    }
    async del(base, key) {
        return this.driver.del(this.getBaseKey(base), key || (await this.getKey(base)));
    }
    async clear(base, prefix) {
        return this.driver.clear(this.getBaseKey(base), prefix);
    }
    async keys(base, prefix) {
        return this.driver.keys(this.getBaseKey(base), prefix);
    }
    async values(cl, prefix) {
        const buffers = await this.driver.values(this.getBaseKey(cl), prefix);
        return buffers.map((buf) => this.decode(cl, buf));
    }
    async entries(cl, prefix) {
        const entries = await this.driver.entries(this.getBaseKey(cl));
        return entries.map(([key, buf]) => [key, this.decode(cl, buf)]);
    }
    async cache(cl, keyOrMeta, cb) {
        const key = await this.getKey(keyOrMeta, cl);
        if (!key) {
            return cb();
        }
        const cachedValue = await this.get(cl, key);
        if (cachedValue != null) {
            return cachedValue;
        }
        const value = await cb();
        if (value != null) {
            await this.set(value, { key, prototype: cl });
        }
        return value;
    }
    useCache(cl, cb, keySource) {
        return async (...args) => {
            const keyMeta = await keySource(...args);
            return this.cache(cl, keyMeta, () => cb(...args));
        };
    }
    async getLockKeys(o) {
        if (typeof o === 'string') {
            return [o];
        }
        const baseKey = this.getBaseKey(o);
        const keyTransformers = metadata_1.reflector.getArray('AragamiLockKeys', o);
        const actualKeys = await Promise.all(keyTransformers.map((fn) => fn(o)));
        return lodash_1.default.compact(actualKeys.flatMap((mayBeKeyArray) => (0, utility_1.makeArray)(mayBeKeyArray).map((key) => `${baseKey}:${key}`)));
    }
    async lock(keys, cb) {
        const keyMeta = (0, utility_1.makeArray)(keys);
        const actualKeys = (await Promise.all(keyMeta.map((o) => this.getLockKeys(o)))).flat();
        if (!keys.length) {
            return cb();
        }
        return this.driver.lock(actualKeys, async () => await cb());
    }
    useLock(cb, keySource) {
        return async (...args) => {
            const keys = await keySource(...args);
            return this.lock(keys, () => cb(...args));
        };
    }
    async destroy() {
        try {
            await this.driver.destroy();
        }
        catch (e) { }
    }
}
exports.Aragami = Aragami;
//# sourceMappingURL=aragami.js.map