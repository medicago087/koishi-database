var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// packages/sqlite/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_cosmokit = require("cosmokit");
var import_core = require("@minatojs/core");
var import_sql_utils = require("@minatojs/sql-utils");
var import_better_sqlite3 = __toESM(require("better-sqlite3"));
var import_path = require("path");
var import_sqlstring_sqlite = require("sqlstring-sqlite");
var import_fs = require("fs");
var import_reggol = __toESM(require("reggol"));
var logger = new import_reggol.default("sqlite");
function getTypeDefinition({ type }) {
  switch (type) {
    case "boolean":
    case "integer":
    case "unsigned":
    case "date":
    case "time":
    case "timestamp":
      return `INTEGER`;
    case "float":
    case "double":
    case "decimal":
      return `REAL`;
    case "char":
    case "string":
    case "text":
    case "list":
    case "json":
      return `TEXT`;
  }
}
__name(getTypeDefinition, "getTypeDefinition");
var _joinKeys, joinKeys_fn, _exec, exec_fn, _update, update_fn, _create, create_fn;
var SQLiteDriver = class extends import_core.Driver {
  constructor(database, config) {
    super(database);
    this.config = config;
    __privateAdd(this, _joinKeys);
    __privateAdd(this, _exec);
    __privateAdd(this, _update);
    __privateAdd(this, _create);
    this.sqlite = this;
    this.sql = new class extends import_sql_utils.Builder {
      constructor() {
        super(...arguments);
        this.format = import_sqlstring_sqlite.format;
        this.escapeId = import_sqlstring_sqlite.escapeId;
      }
      escape(value) {
        if (value instanceof Date) {
          return +value + "";
        }
        return (0, import_sqlstring_sqlite.escape)(value);
      }
      createElementQuery(key, value) {
        return `(',' || ${key} || ',') LIKE ${this.escape("%," + value + ",%")}`;
      }
    }();
    this.caster = new import_sql_utils.Caster(this.database.tables);
    this.caster.register({
      types: ["boolean"],
      dump: (value) => +value,
      load: (value) => !!value
    });
    this.caster.register({
      types: ["json"],
      dump: (value) => JSON.stringify(value),
      load: (value, initial) => value ? JSON.parse(value) : initial
    });
    this.caster.register({
      types: ["list"],
      dump: (value) => value.join(","),
      load: (value) => value ? value.split(",") : []
    });
    this.caster.register({
      types: ["date", "time", "timestamp"],
      dump: (value) => value === null ? null : +value,
      load: (value) => value === null ? null : new Date(value)
    });
  }
  _getColDefs(table, key) {
    const config = this.model(table);
    const { initial, nullable = true } = config.fields[key];
    let def = `\`${key}\``;
    if (key === config.primary && config.autoInc) {
      def += " INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT";
    } else {
      const typedef = getTypeDefinition(config.fields[key]);
      def += " " + typedef + (nullable ? " " : " NOT ") + "NULL";
      if (initial !== void 0 && initial !== null) {
        def += " DEFAULT " + this.sql.escape(this.caster.dump(table, { [key]: initial })[key]);
      }
    }
    return def;
  }
  async prepare(table) {
    const info = __privateMethod(this, _exec, exec_fn).call(this, "all", `PRAGMA table_info(${this.sql.escapeId(table)})`);
    const config = this.model(table);
    const keys = Object.keys(config.fields);
    if (info.length) {
      logger.info("auto updating table %c", table);
      for (const key of keys) {
        if (info.some(({ name }) => name === key))
          continue;
        const def = this._getColDefs(table, key);
        __privateMethod(this, _exec, exec_fn).call(this, "run", `ALTER TABLE ${this.sql.escapeId(table)} ADD COLUMN ${def}`);
      }
    } else {
      logger.info("auto creating table %c", table);
      const defs = keys.map((key) => this._getColDefs(table, key));
      const constraints = [];
      if (config.primary && !config.autoInc) {
        constraints.push(`PRIMARY KEY (${__privateMethod(this, _joinKeys, joinKeys_fn).call(this, (0, import_cosmokit.makeArray)(config.primary))})`);
      }
      if (config.unique) {
        constraints.push(...config.unique.map((keys2) => `UNIQUE (${__privateMethod(this, _joinKeys, joinKeys_fn).call(this, (0, import_cosmokit.makeArray)(keys2))})`));
      }
      if (config.foreign) {
        constraints.push(...Object.entries(config.foreign).map(([key, [table2, key2]]) => {
          return `FOREIGN KEY (\`${key}\`) REFERENCES ${this.sql.escapeId(table2)} (\`${key2}\`)`;
        }));
      }
      __privateMethod(this, _exec, exec_fn).call(this, "run", `CREATE TABLE ${this.sql.escapeId(table)} (${[...defs, ...constraints].join(",")})`);
    }
  }
  async start() {
    this.db = (0, import_better_sqlite3.default)(this.config.path === ":memory:" ? this.config.path : (0, import_path.resolve)(this.config.path));
    this.db.function("regexp", (pattern, str) => +new RegExp(pattern).test(str));
  }
  async stop() {
    this.db.close();
  }
  async drop() {
    const tables = Object.keys(this.database.tables);
    for (const table of tables) {
      __privateMethod(this, _exec, exec_fn).call(this, "run", `DROP TABLE ${this.sql.escapeId(table)}`);
    }
  }
  async stats() {
    if (this.config.path === ":memory:")
      return {};
    const { size } = await import_fs.promises.stat(this.config.path);
    return { size };
  }
  async remove(sel) {
    const { query, table } = sel;
    const filter = this.sql.parseQuery(query);
    if (filter === "0")
      return;
    __privateMethod(this, _exec, exec_fn).call(this, "run", `DELETE FROM ${this.sql.escapeId(table)} WHERE ${filter}`);
  }
  async get(sel, modifier) {
    const { table, fields, query } = sel;
    const filter = this.sql.parseQuery(query);
    if (filter === "0")
      return [];
    const { limit, offset, sort } = modifier;
    let sql = `SELECT ${__privateMethod(this, _joinKeys, joinKeys_fn).call(this, fields ? Object.keys(fields) : null)} FROM ${this.sql.escapeId(table)} WHERE ${filter}`;
    if (sort.length)
      sql += " ORDER BY " + sort.map(([key, order]) => `\`${key["$"][1]}\` ${order}`).join(", ");
    if (limit < Infinity)
      sql += " LIMIT " + limit;
    if (offset > 0)
      sql += " OFFSET " + offset;
    const rows = __privateMethod(this, _exec, exec_fn).call(this, "all", sql);
    return rows.map((row) => this.caster.load(table, row));
  }
  async eval(sel, expr) {
    const { table, query } = sel;
    const filter = this.sql.parseQuery(query);
    const output = this.sql.parseEval(expr);
    const { value } = __privateMethod(this, _exec, exec_fn).call(this, "get", `SELECT ${output} AS value FROM ${this.sql.escapeId(table)} WHERE ${filter}`);
    return value;
  }
  async set(sel, update) {
    const { model, table, query } = sel;
    const { primary, fields } = model;
    const updateFields = [...new Set(Object.keys(update).map((key) => {
      return Object.keys(fields).find((field) => field === key || key.startsWith(field + "."));
    }))];
    const primaryFields = (0, import_cosmokit.makeArray)(primary);
    const data = await this.database.get(table, query, (0, import_cosmokit.union)(primaryFields, updateFields));
    for (const row of data) {
      __privateMethod(this, _update, update_fn).call(this, sel, primaryFields, updateFields, update, row);
    }
  }
  async create(sel, data) {
    const { model, table } = sel;
    data = model.create(data);
    const result = __privateMethod(this, _create, create_fn).call(this, table, data);
    const { autoInc, primary } = model;
    if (!autoInc)
      return data;
    return { ...data, [primary]: result.lastInsertRowid };
  }
  async upsert(sel, data, keys) {
    if (!data.length)
      return;
    const { model, table, ref } = sel;
    const dataFields = [...new Set(Object.keys(Object.assign({}, ...data)).map((key) => {
      return Object.keys(model.fields).find((field) => field === key || key.startsWith(field + "."));
    }))];
    const relaventFields = (0, import_cosmokit.union)(keys, dataFields);
    const updateFields = (0, import_cosmokit.difference)(dataFields, keys);
    const results = await this.database.get(table, {
      $or: data.map((item) => Object.fromEntries(keys.map((key) => [key, item[key]])))
    }, relaventFields);
    for (const item of data) {
      const row = results.find((row2) => keys.every((key) => row2[key] === item[key]));
      if (row) {
        __privateMethod(this, _update, update_fn).call(this, sel, keys, updateFields, item, row);
      } else {
        __privateMethod(this, _create, create_fn).call(this, table, (0, import_core.executeUpdate)(model.create(), item, ref));
      }
    }
  }
};
__name(SQLiteDriver, "SQLiteDriver");
_joinKeys = new WeakSet();
joinKeys_fn = /* @__PURE__ */ __name(function(keys) {
  return (keys == null ? void 0 : keys.length) ? keys.map((key) => `\`${key}\``).join(",") : "*";
}, "#joinKeys");
_exec = new WeakSet();
exec_fn = /* @__PURE__ */ __name(function(action, sql, params = []) {
  try {
    const result = this.db.prepare(sql)[action](params);
    logger.debug("SQL > %c", sql);
    return result;
  } catch (e) {
    logger.warn("SQL > %c", sql);
    throw e;
  }
}, "#exec");
_update = new WeakSet();
update_fn = /* @__PURE__ */ __name(function(sel, indexFields, updateFields, update, data) {
  const { ref, table } = sel;
  const row = this.caster.dump(table, (0, import_core.executeUpdate)(data, update, ref));
  const assignment = updateFields.map((key) => `\`${key}\` = ${this.sql.escape(row[key])}`).join(",");
  const query = Object.fromEntries(indexFields.map((key) => [key, row[key]]));
  const filter = this.sql.parseQuery(query);
  __privateMethod(this, _exec, exec_fn).call(this, "run", `UPDATE ${this.sql.escapeId(table)} SET ${assignment} WHERE ${filter}`);
}, "#update");
_create = new WeakSet();
create_fn = /* @__PURE__ */ __name(function(table, data) {
  data = this.caster.dump(table, data);
  const keys = Object.keys(data);
  const sql = `INSERT INTO ${this.sql.escapeId(table)} (${__privateMethod(this, _joinKeys, joinKeys_fn).call(this, keys)}) VALUES (${keys.map((key) => this.sql.escape(data[key])).join(", ")})`;
  return __privateMethod(this, _exec, exec_fn).call(this, "run", sql);
}, "#create");
var src_default = SQLiteDriver;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map
