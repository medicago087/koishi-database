"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// minato/packages/sqlite/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_cosmokit = require("cosmokit");
var import_core = require("@minatojs/core");
var import_sql_utils = require("@minatojs/sql-utils");
var import_fs = require("fs");
var import_sql = __toESM(require("@minatojs/sql.js"));
var import_reggol = __toESM(require("reggol"));
var logger = new import_reggol.default("sqlite");
function getTypeDef({ type }) {
  switch (type) {
    case "boolean":
    case "integer":
    case "unsigned":
    case "date":
    case "time":
    case "timestamp":
      return `INTEGER`;
    case "float":
    case "double":
    case "decimal":
      return `REAL`;
    case "char":
    case "string":
    case "text":
    case "list":
    case "json":
      return `TEXT`;
  }
}
__name(getTypeDef, "getTypeDef");
var SQLiteBuilder = class extends import_sql_utils.Builder {
  constructor(tables) {
    super(tables);
    this.evalOperators.$if = (args) => `iif(${args.map((arg) => this.parseEval(arg)).join(", ")})`;
    this.define({
      types: ["boolean"],
      dump: (value) => +value,
      load: (value) => !!value
    });
    this.define({
      types: ["json"],
      dump: (value) => JSON.stringify(value),
      load: (value, initial) => value ? JSON.parse(value) : initial
    });
    this.define({
      types: ["list"],
      dump: (value) => value.join(","),
      load: (value) => value ? value.split(",") : []
    });
    this.define({
      types: ["date", "time", "timestamp"],
      dump: (value) => value === null ? null : +value,
      load: (value) => value === null ? null : new Date(value)
    });
  }
  escape(value, field) {
    if (value instanceof Date)
      value = +value;
    return super.escape(value, field);
  }
  createElementQuery(key, value) {
    return `(',' || ${key} || ',') LIKE ${this.escape("%," + value + ",%")}`;
  }
};
__name(SQLiteBuilder, "SQLiteBuilder");
var _joinKeys, joinKeys_fn, _exec, exec_fn, _all, all_fn, _get, get_fn, _run, run_fn, _update, update_fn, _create, create_fn;
var SQLiteDriver = class extends import_core.Driver {
  constructor(database, config) {
    super(database);
    this.config = config;
    __privateAdd(this, _joinKeys);
    __privateAdd(this, _exec);
    __privateAdd(this, _all);
    __privateAdd(this, _get);
    __privateAdd(this, _run);
    __privateAdd(this, _update);
    __privateAdd(this, _create);
    this.sql = new SQLiteBuilder(database.tables);
  }
  async prepare(table) {
    const info = __privateMethod(this, _all, all_fn).call(this, `PRAGMA table_info(${(0, import_sql_utils.escapeId)(table)})`);
    const model = this.model(table);
    const columnDefs = [];
    const indexDefs = [];
    const alter = [];
    const mapping = {};
    let shouldMigrate = false;
    for (const key in model.fields) {
      const legacy = [key, ...model.fields[key].legacy || []];
      const column = info.find(({ name }) => legacy.includes(name));
      const { initial, nullable = true } = model.fields[key];
      const typedef = getTypeDef(model.fields[key]);
      let def = `${(0, import_sql_utils.escapeId)(key)} ${typedef}`;
      if (key === model.primary && model.autoInc) {
        def += " NOT NULL PRIMARY KEY AUTOINCREMENT";
      } else {
        def += (nullable ? " " : " NOT ") + "NULL";
        if (!(0, import_cosmokit.isNullable)(initial)) {
          def += " DEFAULT " + this.sql.escape(this.sql.dump(model, { [key]: initial })[key]);
        }
      }
      columnDefs.push(def);
      if (!column) {
        alter.push("ADD " + def);
      } else {
        mapping[column.name] = key;
        shouldMigrate || (shouldMigrate = column.name !== key || column.type !== typedef);
      }
    }
    if (model.primary && !model.autoInc) {
      indexDefs.push(`PRIMARY KEY (${__privateMethod(this, _joinKeys, joinKeys_fn).call(this, (0, import_cosmokit.makeArray)(model.primary))})`);
    }
    if (model.unique) {
      indexDefs.push(...model.unique.map((keys) => `UNIQUE (${__privateMethod(this, _joinKeys, joinKeys_fn).call(this, (0, import_cosmokit.makeArray)(keys))})`));
    }
    if (model.foreign) {
      indexDefs.push(...Object.entries(model.foreign).map(([key, value]) => {
        const [table2, key2] = value;
        return `FOREIGN KEY (\`${key}\`) REFERENCES ${(0, import_sql_utils.escapeId)(table2)} (\`${key2}\`)`;
      }));
    }
    if (!info.length) {
      logger.info("auto creating table %c", table);
      __privateMethod(this, _run, run_fn).call(this, `CREATE TABLE ${(0, import_sql_utils.escapeId)(table)} (${[...columnDefs, ...indexDefs].join(", ")})`);
    } else if (shouldMigrate) {
      for (const column of info) {
        if (mapping[column.name])
          continue;
        let def = `${(0, import_sql_utils.escapeId)(column.name)} ${column.type}`;
        def += (column.notnull ? " NOT " : " ") + "NULL";
        if (column.pk)
          def += " PRIMARY KEY";
        if (column.dflt_value !== null)
          def += " DEFAULT " + (0, import_sql_utils.escape)(column.dflt_value);
        columnDefs.push(def);
        mapping[column.name] = column.name;
      }
      const temp = table + "_temp";
      const fields = Object.keys(mapping).map(import_sql_utils.escapeId).join(", ");
      logger.info("auto migrating table %c", table);
      __privateMethod(this, _run, run_fn).call(this, `CREATE TABLE ${(0, import_sql_utils.escapeId)(temp)} (${columnDefs.join(", ")})`);
      try {
        __privateMethod(this, _run, run_fn).call(this, `INSERT INTO ${(0, import_sql_utils.escapeId)(temp)} SELECT ${fields} FROM ${(0, import_sql_utils.escapeId)(table)}`);
        __privateMethod(this, _run, run_fn).call(this, `DROP TABLE ${(0, import_sql_utils.escapeId)(table)}`);
        __privateMethod(this, _run, run_fn).call(this, `CREATE TABLE ${(0, import_sql_utils.escapeId)(table)} (${[...columnDefs, ...indexDefs].join(", ")})`);
        __privateMethod(this, _run, run_fn).call(this, `INSERT INTO ${(0, import_sql_utils.escapeId)(table)} SELECT * FROM ${(0, import_sql_utils.escapeId)(temp)}`);
      } finally {
        __privateMethod(this, _run, run_fn).call(this, `DROP TABLE ${(0, import_sql_utils.escapeId)(temp)}`);
      }
    } else if (alter.length) {
      logger.info("auto updating table %c", table);
      __privateMethod(this, _run, run_fn).call(this, `ALTER TABLE ${(0, import_sql_utils.escapeId)(table)} ${alter.join(", ")}`);
    }
  }
  init(buffer) {
    this.db = new this.sqlite.Database(buffer);
    this.db.create_function("regexp", (pattern, str) => +new RegExp(pattern).test(str));
  }
  async start() {
    const [sqlite, buffer] = await Promise.all([
      (0, import_sql.default)(),
      this.config.path === ":memory:" ? null : import_fs.promises.readFile(this.config.path).catch(() => null)
    ]);
    this.sqlite = sqlite;
    this.init(buffer);
  }
  async stop() {
    this.db.close();
  }
  async drop() {
    const tables = Object.keys(this.database.tables);
    for (const table of tables) {
      __privateMethod(this, _run, run_fn).call(this, `DROP TABLE ${(0, import_sql_utils.escapeId)(table)}`);
    }
  }
  async stats() {
    const size = this.db.export().byteLength;
    return { size };
  }
  async remove(sel) {
    const { query, table } = sel;
    const filter = this.sql.parseQuery(query);
    if (filter === "0")
      return;
    __privateMethod(this, _run, run_fn).call(this, `DELETE FROM ${(0, import_sql_utils.escapeId)(table)} WHERE ${filter}`);
  }
  async get(sel) {
    const { tables } = sel;
    const builder = new SQLiteBuilder(tables);
    const sql = builder.get(sel);
    if (!sql)
      return [];
    const rows = __privateMethod(this, _all, all_fn).call(this, sql);
    return rows.map((row) => this.sql.load(sel.model, row));
  }
  async eval(sel, expr) {
    const output = this.sql.parseEval(expr);
    let sql = this.sql.get(sel.table);
    const prefix = `SELECT ${output} AS value `;
    if (sql.startsWith("SELECT * ")) {
      sql = prefix + sql.slice(9);
    } else {
      sql = `${prefix}FROM (${sql}) ${sql.ref}`;
    }
    const { value } = __privateMethod(this, _get, get_fn).call(this, sql);
    return value;
  }
  async set(sel, update) {
    const { model, table, query } = sel;
    const { primary, fields } = model;
    const updateFields = [...new Set(Object.keys(update).map((key) => {
      return Object.keys(fields).find((field) => field === key || key.startsWith(field + "."));
    }))];
    const primaryFields = (0, import_cosmokit.makeArray)(primary);
    const data = await this.database.get(table, query, (0, import_cosmokit.union)(primaryFields, updateFields));
    for (const row of data) {
      __privateMethod(this, _update, update_fn).call(this, sel, primaryFields, updateFields, update, row);
    }
  }
  async create(sel, data) {
    const { model, table } = sel;
    data = model.create(data);
    const { id } = __privateMethod(this, _create, create_fn).call(this, table, data);
    const { autoInc, primary } = model;
    if (!autoInc || Array.isArray(primary))
      return data;
    return { ...data, [primary]: id };
  }
  async upsert(sel, data, keys) {
    if (!data.length)
      return;
    const { model, table, ref } = sel;
    const dataFields = [...new Set(Object.keys(Object.assign({}, ...data)).map((key) => {
      return Object.keys(model.fields).find((field) => field === key || key.startsWith(field + "."));
    }))];
    const relaventFields = (0, import_cosmokit.union)(keys, dataFields);
    const updateFields = (0, import_cosmokit.difference)(dataFields, keys);
    const results = await this.database.get(table, {
      $or: data.map((item) => Object.fromEntries(keys.map((key) => [key, item[key]])))
    }, relaventFields);
    for (const item of data) {
      const row = results.find((row2) => keys.every((key) => row2[key] === item[key]));
      if (row) {
        __privateMethod(this, _update, update_fn).call(this, sel, keys, updateFields, item, row);
      } else {
        __privateMethod(this, _create, create_fn).call(this, table, (0, import_core.executeUpdate)(model.create(), item, ref));
      }
    }
  }
};
__name(SQLiteDriver, "SQLiteDriver");
_joinKeys = new WeakSet();
joinKeys_fn = /* @__PURE__ */ __name(function(keys) {
  return (keys == null ? void 0 : keys.length) ? keys.map((key) => `\`${key}\``).join(", ") : "*";
}, "#joinKeys");
_exec = new WeakSet();
exec_fn = /* @__PURE__ */ __name(function(sql, params, callback) {
  try {
    const stmt = this.db.prepare(sql);
    const result = callback(stmt);
    stmt.free();
    logger.debug("> %s", sql);
    return result;
  } catch (e) {
    logger.warn("> %s", sql);
    throw e;
  }
}, "#exec");
_all = new WeakSet();
all_fn = /* @__PURE__ */ __name(function(sql, params = []) {
  return __privateMethod(this, _exec, exec_fn).call(this, sql, params, (stmt) => {
    stmt.bind(params);
    const result = [];
    while (stmt.step()) {
      result.push(stmt.getAsObject());
    }
    return result;
  });
}, "#all");
_get = new WeakSet();
get_fn = /* @__PURE__ */ __name(function(sql, params = []) {
  return __privateMethod(this, _exec, exec_fn).call(this, sql, params, (stmt) => stmt.getAsObject(params));
}, "#get");
_run = new WeakSet();
run_fn = /* @__PURE__ */ __name(function(sql, params = [], callback) {
  __privateMethod(this, _exec, exec_fn).call(this, sql, params, (stmt) => stmt.run(params));
  const result = callback == null ? void 0 : callback();
  if (this.config.path) {
    const data = this.db.export();
    const timer = this.writeTask = setTimeout(() => {
      if (this.writeTask !== timer)
        return;
      import_fs.promises.writeFile(this.config.path, data);
    }, 0);
    this.init(data);
  }
  return result;
}, "#run");
_update = new WeakSet();
update_fn = /* @__PURE__ */ __name(function(sel, indexFields, updateFields, update, data) {
  const { ref, table } = sel;
  const model = this.model(table);
  const row = this.sql.dump(model, (0, import_core.executeUpdate)(data, update, ref));
  const assignment = updateFields.map((key) => `${(0, import_sql_utils.escapeId)(key)} = ${this.sql.escape(row[key])}`).join(",");
  const query = Object.fromEntries(indexFields.map((key) => [key, row[key]]));
  const filter = this.sql.parseQuery(query);
  __privateMethod(this, _run, run_fn).call(this, `UPDATE ${(0, import_sql_utils.escapeId)(table)} SET ${assignment} WHERE ${filter}`);
}, "#update");
_create = new WeakSet();
create_fn = /* @__PURE__ */ __name(function(table, data) {
  const model = this.model(table);
  data = this.sql.dump(model, data);
  const keys = Object.keys(data);
  const sql = `INSERT INTO ${(0, import_sql_utils.escapeId)(table)} (${__privateMethod(this, _joinKeys, joinKeys_fn).call(this, keys)}) VALUES (${keys.map((key) => this.sql.escape(data[key])).join(", ")})`;
  return __privateMethod(this, _run, run_fn).call(this, sql, [], () => __privateMethod(this, _get, get_fn).call(this, `SELECT last_insert_rowid() AS id`));
}, "#create");
var src_default = SQLiteDriver;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map
