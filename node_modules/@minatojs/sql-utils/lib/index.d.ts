import { Dict } from 'cosmokit';
import { Eval, Field, Model, Modifier, Query, Selection } from '@minatojs/core';
export * from './utils';
export type QueryOperators = {
    [K in keyof Query.FieldExpr]?: (key: string, value: NonNullable<Query.FieldExpr[K]>) => string;
};
export type ExtractUnary<T> = T extends [infer U] ? U : T;
export type EvalOperators = {
    [K in keyof Eval.Static as `$${K}`]?: (expr: ExtractUnary<Parameters<Eval.Static[K]>>) => string;
} & {
    $: (expr: any) => string;
};
export interface Transformer<S = any, T = any> {
    types: Field.Type<S>[];
    dump: (value: S) => T | null;
    load: (value: T, initial?: S) => S | null;
}
export declare class Builder {
    tables: Dict<Model>;
    protected types: Dict<Transformer>;
    protected createEqualQuery: (key: string, value: any) => string;
    protected queryOperators: QueryOperators;
    protected evalOperators: EvalOperators;
    constructor(tables: Dict<Model>);
    protected createNullQuery(key: string, value: boolean): string;
    protected createMemberQuery(key: string, value: any[], notStr?: string): string;
    protected createRegExpQuery(key: string, value: RegExp): string;
    protected createElementQuery(key: string, value: any): string;
    protected comparator(operator: string): (key: string, value: any) => string;
    protected binary(operator: string): ([left, right]: [any, any]) => string;
    protected logicalAnd(conditions: string[]): string;
    protected logicalOr(conditions: string[]): string;
    protected logicalNot(condition: string): string;
    protected parseFieldQuery(key: string, query: Query.FieldExpr): string;
    parseQuery(query: Query.Expr): string;
    private parseEvalExpr;
    private parseAggr;
    private getRecursive;
    parseEval(expr: any): string;
    suffix(modifier: Modifier): string;
    get(sel: Selection.Immutable): any;
    define<S, T>(converter: Transformer<S, T>): void;
    dump(model: Model, obj: any): any;
    load(model: Model, obj: any): any;
    escape(value: any, field?: Field): string;
    stringify(value: any, field?: Field): any;
}
