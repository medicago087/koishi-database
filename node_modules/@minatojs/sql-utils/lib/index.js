"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// minato/packages/sql-utils/src/index.ts
var src_exports = {};
__export(src_exports, {
  Builder: () => Builder,
  escapeId: () => escapeId
});
module.exports = __toCommonJS(src_exports);
var import_cosmokit = require("cosmokit");
function escapeId(value) {
  return "`" + value + "`";
}
__name(escapeId, "escapeId");
var Builder = class {
  constructor(tables) {
    this.tables = tables;
    this.escapeMap = {};
    this.types = {};
    this.createEqualQuery = this.comparator("=");
    this.queryOperators = {
      $or: (key, value) => this.logicalOr(value.map((value2) => this.parseFieldQuery(key, value2))),
      $and: (key, value) => this.logicalAnd(value.map((value2) => this.parseFieldQuery(key, value2))),
      $not: (key, value) => this.logicalNot(this.parseFieldQuery(key, value)),
      $exists: (key, value) => this.createNullQuery(key, value),
      $eq: this.createEqualQuery,
      $ne: this.comparator("!="),
      $gt: this.comparator(">"),
      $gte: this.comparator(">="),
      $lt: this.comparator("<"),
      $lte: this.comparator("<="),
      $in: (key, value) => this.createMemberQuery(key, value, ""),
      $nin: (key, value) => this.createMemberQuery(key, value, " NOT"),
      $regex: (key, value) => this.createRegExpQuery(key, value),
      $regexFor: (key, value) => `${this.escape(value)} regexp ${key}`,
      $bitsAllSet: (key, value) => `${key} & ${this.escape(value)} = ${this.escape(value)}`,
      $bitsAllClear: (key, value) => `${key} & ${this.escape(value)} = 0`,
      $bitsAnySet: (key, value) => `${key} & ${this.escape(value)} != 0`,
      $bitsAnyClear: (key, value) => `${key} & ${this.escape(value)} != ${this.escape(value)}`,
      $el: (key, value) => {
        if (Array.isArray(value)) {
          return this.logicalOr(value.map((value2) => this.createElementQuery(key, value2)));
        } else if (typeof value !== "number" && typeof value !== "string") {
          throw new TypeError("query expr under $el is not supported");
        } else {
          return this.createElementQuery(key, value);
        }
      },
      $size: (key, value) => {
        if (!value)
          return this.logicalNot(key);
        return `${key} AND LENGTH(${key}) - LENGTH(REPLACE(${key}, ${this.escape(",")}, ${this.escape("")})) = ${this.escape(value)} - 1`;
      }
    };
    this.evalOperators = {
      $: (key) => this.getRecursive(key),
      $if: (args) => `if(${args.map((arg) => this.parseEval(arg)).join(", ")})`,
      $ifNull: (args) => `ifnull(${args.map((arg) => this.parseEval(arg)).join(", ")})`,
      $add: (args) => `(${args.map((arg) => this.parseEval(arg)).join(" + ")})`,
      $multiply: (args) => `(${args.map((arg) => this.parseEval(arg)).join(" * ")})`,
      $subtract: this.binary("-"),
      $divide: this.binary("/"),
      $concat: (args) => `concat(${args.map((arg) => this.parseEval(arg)).join(", ")})`,
      $or: (args) => this.logicalOr(args.map((arg) => this.parseEval(arg))),
      $and: (args) => this.logicalAnd(args.map((arg) => this.parseEval(arg))),
      $not: (arg) => this.logicalNot(this.parseEval(arg)),
      $eq: this.binary("="),
      $ne: this.binary("!="),
      $gt: this.binary(">"),
      $gte: this.binary(">="),
      $lt: this.binary("<"),
      $lte: this.binary("<="),
      $sum: (expr) => `ifnull(sum(${this.parseAggr(expr)}), 0)`,
      $avg: (expr) => `avg(${this.parseAggr(expr)})`,
      $min: (expr) => `min(${this.parseAggr(expr)})`,
      $max: (expr) => `max(${this.parseAggr(expr)})`,
      $count: (expr) => `count(distinct ${this.parseAggr(expr)})`
    };
  }
  createNullQuery(key, value) {
    return `${key} is ${value ? "not " : ""} null`;
  }
  createMemberQuery(key, value, notStr = "") {
    if (!value.length)
      return notStr ? "1" : "0";
    return `${key}${notStr} in (${value.map((val) => this.escape(val)).join(", ")})`;
  }
  createRegExpQuery(key, value) {
    return `${key} regexp ${this.escape(value.source)}`;
  }
  createElementQuery(key, value) {
    return `find_in_set(${this.escape(value)}, ${key})`;
  }
  comparator(operator) {
    return (key, value) => {
      return `${key} ${operator} ${this.escape(value)}`;
    };
  }
  binary(operator) {
    return ([left, right]) => {
      return `(${this.parseEval(left)} ${operator} ${this.parseEval(right)})`;
    };
  }
  logicalAnd(conditions) {
    if (!conditions.length)
      return "1";
    if (conditions.includes("0"))
      return "0";
    return conditions.join(" AND ");
  }
  logicalOr(conditions) {
    if (!conditions.length)
      return "0";
    if (conditions.includes("1"))
      return "1";
    return `(${conditions.join(" OR ")})`;
  }
  logicalNot(condition) {
    return `NOT(${condition})`;
  }
  parseFieldQuery(key, query) {
    const conditions = [];
    if (Array.isArray(query)) {
      conditions.push(this.createMemberQuery(key, query));
    } else if (query instanceof RegExp) {
      conditions.push(this.createRegExpQuery(key, query));
    } else if (typeof query === "string" || typeof query === "number" || query instanceof Date) {
      conditions.push(this.createEqualQuery(key, query));
    } else if ((0, import_cosmokit.isNullable)(query)) {
      conditions.push(this.createNullQuery(key, false));
    } else {
      for (const prop in query) {
        if (prop in this.queryOperators) {
          conditions.push(this.queryOperators[prop](key, query[prop]));
        }
      }
    }
    return this.logicalAnd(conditions);
  }
  parseQuery(query) {
    const conditions = [];
    for (const key in query) {
      if (key === "$not") {
        conditions.push(this.logicalNot(this.parseQuery(query.$not)));
      } else if (key === "$and") {
        conditions.push(this.logicalAnd(query.$and.map(this.parseQuery.bind(this))));
      } else if (key === "$or") {
        conditions.push(this.logicalOr(query.$or.map(this.parseQuery.bind(this))));
      } else if (key === "$expr") {
        conditions.push(this.parseEval(query.$expr));
      } else {
        conditions.push(this.parseFieldQuery(escapeId(key), query[key]));
      }
    }
    return this.logicalAnd(conditions);
  }
  parseEvalExpr(expr) {
    for (const key in expr) {
      if (key in this.evalOperators) {
        return this.evalOperators[key](expr[key]);
      }
    }
    return this.escape(expr);
  }
  parseAggr(expr) {
    if (typeof expr === "string") {
      return this.getRecursive(expr);
    }
    return this.parseEvalExpr(expr);
  }
  getRecursive(args) {
    var _a;
    if (typeof args === "string") {
      return this.getRecursive(["_", args]);
    } else {
      const [table, key] = args;
      const fields = ((_a = this.tables[table]) == null ? void 0 : _a.fields) || {};
      if (key in fields || !key.includes("."))
        return escapeId(key);
      const field = Object.keys(fields).find((k) => key.startsWith(k + ".")) || key.split(".")[0];
      const rest = key.slice(field.length + 1).split(".");
      return `json_unquote(json_extract(${escapeId(field)}, '$${rest.map((key2) => `."${key2}"`).join("")}'))`;
    }
  }
  parseEval(expr) {
    if (typeof expr === "string" || typeof expr === "number" || typeof expr === "boolean" || expr instanceof Date) {
      return this.escape(expr);
    }
    return this.parseEvalExpr(expr);
  }
  suffix(modifier) {
    const { limit, offset, sort, group, having } = modifier;
    let sql = "";
    if (group.length) {
      sql += ` GROUP BY ${group.map(escapeId).join(", ")}`;
      const filter = this.parseEval(having);
      if (filter !== "1")
        sql += ` HAVING ${filter}`;
    }
    if (sort.length) {
      sql += " ORDER BY " + sort.map(([expr, dir]) => {
        return `${this.parseEval(expr)} ${dir.toUpperCase()}`;
      }).join(", ");
    }
    if (limit < Infinity)
      sql += " LIMIT " + limit;
    if (offset > 0)
      sql += " OFFSET " + offset;
    return sql;
  }
  get(sel) {
    const { args, table, query, ref } = sel;
    const filter = this.parseQuery(query);
    if (filter === "0")
      return;
    const { fields } = args[0];
    const keys = !fields ? "*" : Object.entries(fields).map(([key, value]) => {
      key = escapeId(key);
      value = this.parseEval(value);
      return key === value ? key : `${value} AS ${key}`;
    }).join(", ");
    let prefix = `SELECT ${keys} FROM `;
    let suffix = this.suffix(args[0]);
    if (filter !== "1") {
      suffix = ` WHERE ${filter}` + suffix;
    }
    if (typeof table === "string") {
      prefix += escapeId(table);
    } else {
      const inner = this.get(table);
      if (!inner)
        return;
      if (!fields && !suffix)
        return inner;
      prefix += `(${inner})`;
    }
    return `${prefix} ${ref}${suffix}`;
  }
  define(converter) {
    converter.types.forEach((type) => this.types[type] = converter);
  }
  dump(model, obj) {
    obj = model.format(obj);
    const result = {};
    for (const key in obj) {
      result[key] = this.stringify(obj[key], model.fields[key]);
    }
    return result;
  }
  load(model, obj) {
    const result = {};
    for (const key in obj) {
      if (!(key in model.fields))
        continue;
      const { type, initial } = model.fields[key];
      const converter = this.types[type];
      result[key] = converter ? converter.load(obj[key], initial) : obj[key];
    }
    return model.parse(result);
  }
  escape(value, field) {
    value = this.stringify(value, field);
    if ((0, import_cosmokit.isNullable)(value))
      return "NULL";
    switch (typeof value) {
      case "boolean":
      case "number":
        return value + "";
      case "object":
        return this.quote(JSON.stringify(value));
      default:
        return this.quote(value);
    }
  }
  stringify(value, field) {
    const converter = this.types[field == null ? void 0 : field.type];
    return converter ? converter.dump(value) : value;
  }
  quote(value) {
    var _a;
    (_a = this.escapeRegExp) != null ? _a : this.escapeRegExp = new RegExp(`[${Object.values(this.escapeMap).join("")}]`, "g");
    let chunkIndex = this.escapeRegExp.lastIndex = 0;
    let escapedVal = "";
    let match;
    while (match = this.escapeRegExp.exec(value)) {
      escapedVal += value.slice(chunkIndex, match.index) + this.escapeMap[match[0]];
      chunkIndex = this.escapeRegExp.lastIndex;
    }
    if (chunkIndex === 0) {
      return "'" + value + "'";
    }
    if (chunkIndex < value.length) {
      return "'" + escapedVal + value.slice(chunkIndex) + "'";
    }
    return "'" + escapedVal + "'";
  }
};
__name(Builder, "Builder");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Builder,
  escapeId
});
//# sourceMappingURL=index.js.map
