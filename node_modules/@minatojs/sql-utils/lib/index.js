var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/sql-utils/src/index.ts
var src_exports = {};
__export(src_exports, {
  Builder: () => Builder,
  Caster: () => Caster
});
module.exports = __toCommonJS(src_exports);
var import_cosmokit = require("cosmokit");
var Builder = class {
  constructor() {
    this.createEqualQuery = this.comparator("=");
    this.queryOperators = {
      $or: (key, value) => this.logicalOr(value.map((value2) => this.parseFieldQuery(key, value2))),
      $and: (key, value) => this.logicalAnd(value.map((value2) => this.parseFieldQuery(key, value2))),
      $not: (key, value) => this.logicalNot(this.parseFieldQuery(key, value)),
      $exists: (key, value) => this.createNullQuery(key, value),
      $eq: this.createEqualQuery,
      $ne: this.comparator("!="),
      $gt: this.comparator(">"),
      $gte: this.comparator(">="),
      $lt: this.comparator("<"),
      $lte: this.comparator("<="),
      $in: (key, value) => this.createMemberQuery(key, value, ""),
      $nin: (key, value) => this.createMemberQuery(key, value, " NOT"),
      $regex: (key, value) => this.createRegExpQuery(key, value),
      $regexFor: (key, value) => `${this.escape(value)} REGEXP ${key}`,
      $bitsAllSet: (key, value) => `${key} & ${this.escape(value)} = ${this.escape(value)}`,
      $bitsAllClear: (key, value) => `${key} & ${this.escape(value)} = 0`,
      $bitsAnySet: (key, value) => `${key} & ${this.escape(value)} != 0`,
      $bitsAnyClear: (key, value) => `${key} & ${this.escape(value)} != ${this.escape(value)}`,
      $el: (key, value) => {
        if (Array.isArray(value)) {
          return this.logicalOr(value.map((value2) => this.createElementQuery(key, value2)));
        } else if (typeof value !== "number" && typeof value !== "string") {
          throw new TypeError("query expr under $el is not supported");
        } else {
          return this.createElementQuery(key, value);
        }
      },
      $size: (key, value) => {
        if (!value)
          return this.logicalNot(key);
        return `${key} AND LENGTH(${key}) - LENGTH(REPLACE(${key}, ${this.escape(",")}, ${this.escape("")})) = ${this.escape(value)} - 1`;
      }
    };
    this.evalOperators = {
      $: (key) => this.getRecursive(key),
      $if: (args) => `IF(${args.map((arg) => this.parseEval(arg)).join(", ")})`,
      $ifNull: (args) => `IFNULL(${args.map((arg) => this.parseEval(arg)).join(", ")})`,
      $add: (args) => `(${args.map((arg) => this.parseEval(arg)).join(" + ")})`,
      $multiply: (args) => `(${args.map((arg) => this.parseEval(arg)).join(" * ")})`,
      $subtract: this.binary("-"),
      $divide: this.binary("/"),
      $concat: (args) => `concat(${args.map((arg) => this.parseEval(arg)).join(", ")})`,
      $or: (args) => this.logicalOr(args.map((arg) => this.parseEval(arg))),
      $and: (args) => this.logicalAnd(args.map((arg) => this.parseEval(arg))),
      $not: (arg) => this.logicalNot(this.parseEval(arg)),
      $eq: this.binary("="),
      $ne: this.binary("!="),
      $gt: this.binary(">"),
      $gte: this.binary(">="),
      $lt: this.binary("<"),
      $lte: this.binary("<="),
      $sum: (expr) => `ifnull(sum(${this.parseAggr(expr)}), 0)`,
      $avg: (expr) => `avg(${this.parseAggr(expr)})`,
      $min: (expr) => `min(${this.parseAggr(expr)})`,
      $max: (expr) => `max(${this.parseAggr(expr)})`,
      $count: (expr) => `count(distinct ${this.parseAggr(expr)})`
    };
  }
  createNullQuery(key, value) {
    return `${key} is ${value ? "not " : ""} null`;
  }
  createMemberQuery(key, value, notStr = "") {
    if (!value.length)
      return notStr ? "1" : "0";
    return `${key}${notStr} in (${value.map((val) => this.escape(val)).join(", ")})`;
  }
  createRegExpQuery(key, value) {
    return `${key} regexp ${this.escape(value.source)}`;
  }
  createElementQuery(key, value) {
    return `find_in_set(${this.escape(value)}, ${key})`;
  }
  comparator(operator) {
    return function(key, value) {
      return `${key} ${operator} ${this.escape(value)}`;
    }.bind(this);
  }
  binary(operator) {
    return function([left, right]) {
      return `(${this.parseEval(left)} ${operator} ${this.parseEval(right)})`;
    }.bind(this);
  }
  logicalAnd(conditions) {
    if (!conditions.length)
      return "1";
    if (conditions.includes("0"))
      return "0";
    return conditions.join(" AND ");
  }
  logicalOr(conditions) {
    if (!conditions.length)
      return "0";
    if (conditions.includes("1"))
      return "1";
    return `(${conditions.join(" OR ")})`;
  }
  logicalNot(condition) {
    return `NOT(${condition})`;
  }
  parseFieldQuery(key, query) {
    const conditions = [];
    if (Array.isArray(query)) {
      conditions.push(this.createMemberQuery(key, query));
    } else if (query instanceof RegExp) {
      conditions.push(this.createRegExpQuery(key, query));
    } else if (typeof query === "string" || typeof query === "number" || query instanceof Date) {
      conditions.push(this.createEqualQuery(key, query));
    } else if ((0, import_cosmokit.isNullable)(query)) {
      conditions.push(this.createNullQuery(key, false));
    } else {
      for (const prop in query) {
        if (prop in this.queryOperators) {
          conditions.push(this.queryOperators[prop](key, query[prop]));
        }
      }
    }
    return this.logicalAnd(conditions);
  }
  parseQuery(query) {
    const conditions = [];
    for (const key in query) {
      if (key === "$not") {
        conditions.push(this.logicalNot(this.parseQuery(query.$not)));
      } else if (key === "$and") {
        conditions.push(this.logicalAnd(query.$and.map(this.parseQuery.bind(this))));
      } else if (key === "$or") {
        conditions.push(this.logicalOr(query.$or.map(this.parseQuery.bind(this))));
      } else if (key === "$expr") {
        conditions.push(this.parseEval(query.$expr));
      } else {
        conditions.push(this.parseFieldQuery(this.escapeId(key), query[key]));
      }
    }
    return this.logicalAnd(conditions);
  }
  parseEvalExpr(expr, table, field) {
    for (const key in expr) {
      if (key in this.evalOperators) {
        return this.evalOperators[key](expr[key]);
      }
    }
    return this.escape(expr, table, field);
  }
  parseAggr(expr) {
    if (typeof expr === "string") {
      return this.getRecursive(expr);
    }
    return this.parseEvalExpr(expr);
  }
  getRecursive(args) {
    if (typeof args === "string") {
      return this.getRecursive(["_", args]);
    } else {
      const [, key] = args;
      if (!key.includes("."))
        return this.escapeId(key);
      const [field, ...rest] = key.split(".");
      return `json_unquote(json_extract(${this.escapeId(field)}, '$${rest.map((key2) => `."${key2}"`).join("")}'))`;
    }
  }
  parseEval(expr, table, field) {
    if (typeof expr === "string" || typeof expr === "number" || typeof expr === "boolean" || expr instanceof Date) {
      return this.escape(expr, table, field);
    }
    return this.parseEvalExpr(expr, table, field);
  }
};
__name(Builder, "Builder");
var Caster = class {
  constructor(models) {
    this.models = models;
    this.types = /* @__PURE__ */ Object.create(null);
  }
  register(typeCaster) {
    typeCaster.types.forEach((type) => this.types[type] = typeCaster);
  }
  dump(table, obj) {
    var _a;
    obj = this.models[table].format(obj);
    const { fields } = this.models[table];
    const result = {};
    for (const key in obj) {
      const converter = this.types[(_a = fields[key]) == null ? void 0 : _a.type];
      result[key] = converter ? converter.dump(obj[key]) : obj[key];
    }
    return result;
  }
  load(table, obj) {
    const { fields } = this.models[table];
    const result = {};
    for (const key in obj) {
      if (!(key in fields))
        continue;
      const { type, initial } = fields[key];
      const converter = this.types[type];
      result[key] = converter ? converter.load(obj[key], initial) : obj[key];
    }
    return this.models[table].parse(result);
  }
};
__name(Caster, "Caster");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Builder,
  Caster
});
//# sourceMappingURL=index.js.map
