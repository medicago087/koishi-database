{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils.ts"],
  "sourcesContent": ["import { Dict, isNullable } from 'cosmokit'\nimport { Eval, Field, Model, Modifier, Query, Selection } from '@minatojs/core'\nimport { escape, escapeId } from './utils'\n\nexport * from './utils'\n\nexport type QueryOperators = {\n  [K in keyof Query.FieldExpr]?: (key: string, value: NonNullable<Query.FieldExpr[K]>) => string\n}\n\nexport type ExtractUnary<T> = T extends [infer U] ? U : T\n\nexport type EvalOperators = {\n  [K in keyof Eval.Static as `$${K}`]?: (expr: ExtractUnary<Parameters<Eval.Static[K]>>) => string\n} & { $: (expr: any) => string }\n\nexport interface Transformer<S = any, T = any> {\n  types: Field.Type<S>[]\n  dump: (value: S) => T | null\n  load: (value: T, initial?: S) => S | null\n}\n\nexport class Builder {\n  protected types: Dict<Transformer> = {}\n  protected createEqualQuery = this.comparator('=')\n  protected queryOperators: QueryOperators\n  protected evalOperators: EvalOperators\n\n  constructor(public tables: Dict<Model>) {\n    this.queryOperators = {\n      // logical\n      $or: (key, value) => this.logicalOr(value.map(value => this.parseFieldQuery(key, value))),\n      $and: (key, value) => this.logicalAnd(value.map(value => this.parseFieldQuery(key, value))),\n      $not: (key, value) => this.logicalNot(this.parseFieldQuery(key, value)),\n\n      // existence\n      $exists: (key, value) => this.createNullQuery(key, value),\n\n      // comparison\n      $eq: this.createEqualQuery,\n      $ne: this.comparator('!='),\n      $gt: this.comparator('>'),\n      $gte: this.comparator('>='),\n      $lt: this.comparator('<'),\n      $lte: this.comparator('<='),\n\n      // membership\n      $in: (key, value) => this.createMemberQuery(key, value, ''),\n      $nin: (key, value) => this.createMemberQuery(key, value, ' NOT'),\n\n      // regexp\n      $regex: (key, value) => this.createRegExpQuery(key, value),\n      $regexFor: (key, value) => `${this.escape(value)} REGEXP ${key}`,\n\n      // bitwise\n      $bitsAllSet: (key, value) => `${key} & ${this.escape(value)} = ${this.escape(value)}`,\n      $bitsAllClear: (key, value) => `${key} & ${this.escape(value)} = 0`,\n      $bitsAnySet: (key, value) => `${key} & ${this.escape(value)} != 0`,\n      $bitsAnyClear: (key, value) => `${key} & ${this.escape(value)} != ${this.escape(value)}`,\n\n      // list\n      $el: (key, value) => {\n        if (Array.isArray(value)) {\n          return this.logicalOr(value.map(value => this.createElementQuery(key, value)))\n        } else if (typeof value !== 'number' && typeof value !== 'string') {\n          throw new TypeError('query expr under $el is not supported')\n        } else {\n          return this.createElementQuery(key, value)\n        }\n      },\n      $size: (key, value) => {\n        if (!value) return this.logicalNot(key)\n        return `${key} AND LENGTH(${key}) - LENGTH(REPLACE(${key}, ${this.escape(',')}, ${this.escape('')})) = ${this.escape(value)} - 1`\n      },\n    }\n\n    this.evalOperators = {\n      // universal\n      $: (key) => this.getRecursive(key),\n      $if: (args) => `if(${args.map(arg => this.parseEval(arg)).join(', ')})`,\n      $ifNull: (args) => `ifnull(${args.map(arg => this.parseEval(arg)).join(', ')})`,\n\n      // number\n      $add: (args) => `(${args.map(arg => this.parseEval(arg)).join(' + ')})`,\n      $multiply: (args) => `(${args.map(arg => this.parseEval(arg)).join(' * ')})`,\n      $subtract: this.binary('-'),\n      $divide: this.binary('/'),\n\n      // string\n      $concat: (args) => `concat(${args.map(arg => this.parseEval(arg)).join(', ')})`,\n\n      // logical\n      $or: (args) => this.logicalOr(args.map(arg => this.parseEval(arg))),\n      $and: (args) => this.logicalAnd(args.map(arg => this.parseEval(arg))),\n      $not: (arg) => this.logicalNot(this.parseEval(arg)),\n\n      // boolean\n      $eq: this.binary('='),\n      $ne: this.binary('!='),\n      $gt: this.binary('>'),\n      $gte: this.binary('>='),\n      $lt: this.binary('<'),\n      $lte: this.binary('<='),\n\n      // aggregation\n      $sum: (expr) => `ifnull(sum(${this.parseAggr(expr)}), 0)`,\n      $avg: (expr) => `avg(${this.parseAggr(expr)})`,\n      $min: (expr) => `min(${this.parseAggr(expr)})`,\n      $max: (expr) => `max(${this.parseAggr(expr)})`,\n      $count: (expr) => `count(distinct ${this.parseAggr(expr)})`,\n    }\n  }\n\n  protected createNullQuery(key: string, value: boolean) {\n    return `${key} is ${value ? 'not ' : ''} null`\n  }\n\n  protected createMemberQuery(key: string, value: any[], notStr = '') {\n    if (!value.length) return notStr ? '1' : '0'\n    return `${key}${notStr} in (${value.map(val => this.escape(val)).join(', ')})`\n  }\n\n  protected createRegExpQuery(key: string, value: RegExp) {\n    return `${key} regexp ${this.escape(value.source)}`\n  }\n\n  protected createElementQuery(key: string, value: any) {\n    return `find_in_set(${this.escape(value)}, ${key})`\n  }\n\n  protected comparator(operator: string) {\n    return (key: string, value: any) => {\n      return `${key} ${operator} ${this.escape(value)}`\n    }\n  }\n\n  protected binary(operator: string) {\n    return ([left, right]) => {\n      return `(${this.parseEval(left)} ${operator} ${this.parseEval(right)})`\n    }\n  }\n\n  protected logicalAnd(conditions: string[]) {\n    if (!conditions.length) return '1'\n    if (conditions.includes('0')) return '0'\n    return conditions.join(' AND ')\n  }\n\n  protected logicalOr(conditions: string[]) {\n    if (!conditions.length) return '0'\n    if (conditions.includes('1')) return '1'\n    return `(${conditions.join(' OR ')})`\n  }\n\n  protected logicalNot(condition: string) {\n    return `NOT(${condition})`\n  }\n\n  protected parseFieldQuery(key: string, query: Query.FieldExpr) {\n    const conditions: string[] = []\n\n    // query shorthand\n    if (Array.isArray(query)) {\n      conditions.push(this.createMemberQuery(key, query))\n    } else if (query instanceof RegExp) {\n      conditions.push(this.createRegExpQuery(key, query))\n    } else if (typeof query === 'string' || typeof query === 'number' || query instanceof Date) {\n      conditions.push(this.createEqualQuery(key, query))\n    } else if (isNullable(query)) {\n      conditions.push(this.createNullQuery(key, false))\n    } else {\n      // query expression\n      for (const prop in query) {\n        if (prop in this.queryOperators) {\n          conditions.push(this.queryOperators[prop](key, query[prop]))\n        }\n      }\n    }\n\n    return this.logicalAnd(conditions)\n  }\n\n  parseQuery(query: Query.Expr) {\n    const conditions: string[] = []\n    for (const key in query) {\n      // logical expression\n      if (key === '$not') {\n        conditions.push(this.logicalNot(this.parseQuery(query.$not!)))\n      } else if (key === '$and') {\n        conditions.push(this.logicalAnd(query.$and!.map(this.parseQuery.bind(this))))\n      } else if (key === '$or') {\n        conditions.push(this.logicalOr(query.$or!.map(this.parseQuery.bind(this))))\n      } else if (key === '$expr') {\n        conditions.push(this.parseEval(query.$expr))\n      } else {\n        conditions.push(this.parseFieldQuery(escapeId(key), query[key]))\n      }\n    }\n\n    return this.logicalAnd(conditions)\n  }\n\n  private parseEvalExpr(expr: any) {\n    for (const key in expr) {\n      if (key in this.evalOperators) {\n        return this.evalOperators[key](expr[key])\n      }\n    }\n    return this.escape(expr)\n  }\n\n  private parseAggr(expr: any) {\n    if (typeof expr === 'string') {\n      return this.getRecursive(expr)\n    }\n    return this.parseEvalExpr(expr)\n  }\n\n  private getRecursive(args: string | string[]) {\n    if (typeof args === 'string') {\n      return this.getRecursive(['_', args])\n    } else {\n      const [table, key] = args\n      const fields = this.tables[table]?.fields || {}\n      if (key in fields || !key.includes('.')) return escapeId(key)\n      const field = Object.keys(fields).find(k => key.startsWith(k + '.')) || key.split('.')[0]\n      const rest = key.slice(field.length + 1).split('.')\n      return `json_unquote(json_extract(${escapeId(field)}, '$${rest.map(key => `.\"${key}\"`).join('')}'))`\n    }\n  }\n\n  parseEval(expr: any): string {\n    if (typeof expr === 'string' || typeof expr === 'number' || typeof expr === 'boolean' || expr instanceof Date) {\n      return this.escape(expr)\n    }\n    return this.parseEvalExpr(expr)\n  }\n\n  suffix(modifier: Modifier) {\n    const { limit, offset, sort, group, having } = modifier\n    let sql = ''\n    if (group.length) {\n      sql += ` GROUP BY ${group.map(escapeId).join(', ')}`\n      const filter = this.parseEval(having)\n      if (filter !== '1') sql += ` HAVING ${filter}`\n    }\n    if (sort.length) {\n      sql += ' ORDER BY ' + sort.map(([expr, dir]) => {\n        return `${this.parseEval(expr)} ${dir.toUpperCase()}`\n      }).join(', ')\n    }\n    if (limit < Infinity) sql += ' LIMIT ' + limit\n    if (offset > 0) sql += ' OFFSET ' + offset\n    return sql\n  }\n\n  get(sel: Selection.Immutable) {\n    const { args, table, query, ref } = sel\n    const filter = this.parseQuery(query)\n    if (filter === '0') return\n    const { fields } = args[0]\n    const keys = !fields ? '*' : Object.entries(fields).map(([key, value]) => {\n      key = escapeId(key)\n      value = this.parseEval(value)\n      return key === value ? key : `${value} AS ${key}`\n    }).join(', ')\n    let prefix = `SELECT ${keys} FROM `\n    let suffix = this.suffix(args[0])\n    if (filter !== '1') {\n      suffix = ` WHERE ${filter}` + suffix\n    }\n    if (typeof table === 'string') {\n      prefix += escapeId(table)\n    } else {\n      const inner = this.get(table)\n      if (!inner) return\n      if (!fields && !suffix) return inner\n      prefix += `(${inner})`\n    }\n    return `${prefix} ${ref}${suffix}`\n  }\n\n  define<S, T>(converter: Transformer<S, T>) {\n    converter.types.forEach(type => this.types[type] = converter)\n  }\n\n  dump(model: Model, obj: any): any {\n    obj = model.format(obj)\n    const result = {}\n    for (const key in obj) {\n      result[key] = this.stringify(obj[key], model.fields[key])\n    }\n    return result\n  }\n\n  load(model: Model, obj: any): any {\n    const result = {}\n    for (const key in obj) {\n      if (!(key in model.fields)) continue\n      const { type, initial } = model.fields[key]!\n      const converter = this.types[type]\n      result[key] = converter ? converter.load(obj[key], initial) : obj[key]\n    }\n    return model.parse(result)\n  }\n\n  escape(value: any, field?: Field) {\n    return escape(this.stringify(value, field))\n  }\n\n  stringify(value: any, field?: Field) {\n    const converter = this.types[field!?.type]\n    return converter ? converter.dump(value) : value\n  }\n}\n", "// modified from sqlstring\n// https://github.com/mysqljs/sqlstring/blob/master/lib/SqlString.js\n\nimport { isNullable } from 'cosmokit'\n\nconst ESCAPE_CHARS_MAP = {\n  '\\0' : '\\\\0',\n  '\\b' : '\\\\b',\n  '\\t' : '\\\\t',\n  '\\n' : '\\\\n',\n  '\\r' : '\\\\r',\n  '\\x1a' : '\\\\Z',\n  '\\'' : '\\\\\\'',\n  '\\\\' : '\\\\\\\\',\n}\n\nconst ESCAPE_CHARS_REGEXP = new RegExp(`[${Object.values(ESCAPE_CHARS_MAP).join('')}]`, 'g')\n\nexport function escapeId(value: string) {\n  return '`' + value + '`'\n}\n\nexport function escape(value: any) {\n  if (isNullable(value)) return 'NULL'\n\n  switch (typeof value) {\n    case 'boolean':\n    case 'number':\n      return value + ''\n    case 'object':\n      return quote(JSON.stringify(value))\n    default:\n      return quote(value)\n  }\n}\n\nexport function quote(value: string) {\n  let chunkIndex = ESCAPE_CHARS_REGEXP.lastIndex = 0\n  let escapedVal = ''\n  let match: RegExpExecArray | null\n\n  while ((match = ESCAPE_CHARS_REGEXP.exec(value))) {\n    escapedVal += value.slice(chunkIndex, match.index) + ESCAPE_CHARS_MAP[match[0]]\n    chunkIndex = ESCAPE_CHARS_REGEXP.lastIndex\n  }\n\n  if (chunkIndex === 0) {\n    return \"'\" + value + \"'\"\n  }\n\n  if (chunkIndex < value.length) {\n    return \"'\" + escapedVal + value.slice(chunkIndex) + \"'\"\n  }\n\n  return \"'\" + escapedVal + \"'\"\n}\n"],
  "mappings": "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",
  "names": ["import_cosmokit", "value", "key"]
}
