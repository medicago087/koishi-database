{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import { Dict, isNullable } from 'cosmokit'\nimport { Eval, Field, Model, Query } from '@minatojs/core'\n\nexport type QueryOperators = {\n  [K in keyof Query.FieldExpr]?: (key: string, value: Query.FieldExpr[K]) => string\n}\n\nexport type ExtractUnary<T> = T extends [infer U] ? U : T\n\nexport type EvalOperators = {\n  [K in keyof Eval.Static as `$${K}`]?: (expr: ExtractUnary<Parameters<Eval.Static[K]>>) => string\n} & { $: (expr: any) => string }\n\nexport abstract class Builder {\n  protected createEqualQuery = this.comparator('=')\n  protected queryOperators: QueryOperators\n  protected evalOperators: EvalOperators\n\n  abstract escapeId(value: any): string\n  abstract escape(value: any, table?: string, field?: string): string\n  abstract format(sql: string, args?: object | any[]): string\n\n  constructor() {\n    this.queryOperators = {\n      // logical\n      $or: (key, value) => this.logicalOr(value.map(value => this.parseFieldQuery(key, value))),\n      $and: (key, value) => this.logicalAnd(value.map(value => this.parseFieldQuery(key, value))),\n      $not: (key, value) => this.logicalNot(this.parseFieldQuery(key, value)),\n\n      // existence\n      $exists: (key, value) => this.createNullQuery(key, value),\n\n      // comparison\n      $eq: this.createEqualQuery,\n      $ne: this.comparator('!='),\n      $gt: this.comparator('>'),\n      $gte: this.comparator('>='),\n      $lt: this.comparator('<'),\n      $lte: this.comparator('<='),\n\n      // membership\n      $in: (key, value) => this.createMemberQuery(key, value, ''),\n      $nin: (key, value) => this.createMemberQuery(key, value, ' NOT'),\n\n      // regexp\n      $regex: (key, value) => this.createRegExpQuery(key, value),\n      $regexFor: (key, value) => `${this.escape(value)} REGEXP ${key}`,\n\n      // bitwise\n      $bitsAllSet: (key, value) => `${key} & ${this.escape(value)} = ${this.escape(value)}`,\n      $bitsAllClear: (key, value) => `${key} & ${this.escape(value)} = 0`,\n      $bitsAnySet: (key, value) => `${key} & ${this.escape(value)} != 0`,\n      $bitsAnyClear: (key, value) => `${key} & ${this.escape(value)} != ${this.escape(value)}`,\n\n      // list\n      $el: (key, value) => {\n        if (Array.isArray(value)) {\n          return this.logicalOr(value.map(value => this.createElementQuery(key, value)))\n        } else if (typeof value !== 'number' && typeof value !== 'string') {\n          throw new TypeError('query expr under $el is not supported')\n        } else {\n          return this.createElementQuery(key, value)\n        }\n      },\n      $size: (key, value) => {\n        if (!value) return this.logicalNot(key)\n        return `${key} AND LENGTH(${key}) - LENGTH(REPLACE(${key}, ${this.escape(',')}, ${this.escape('')})) = ${this.escape(value)} - 1`\n      },\n    }\n\n    this.evalOperators = {\n      // universal\n      $: (key) => this.getRecursive(key),\n      $if: (args) => `IF(${args.map(arg => this.parseEval(arg)).join(', ')})`,\n      $ifNull: (args) => `IFNULL(${args.map(arg => this.parseEval(arg)).join(', ')})`,\n\n      // number\n      $add: (args) => `(${args.map(arg => this.parseEval(arg)).join(' + ')})`,\n      $multiply: (args) => `(${args.map(arg => this.parseEval(arg)).join(' * ')})`,\n      $subtract: this.binary('-'),\n      $divide: this.binary('/'),\n\n      // string\n      $concat: (args) => `concat(${args.map(arg => this.parseEval(arg)).join(', ')})`,\n\n      // logical\n      $or: (args) => this.logicalOr(args.map(arg => this.parseEval(arg))),\n      $and: (args) => this.logicalAnd(args.map(arg => this.parseEval(arg))),\n      $not: (arg) => this.logicalNot(this.parseEval(arg)),\n\n      // boolean\n      $eq: this.binary('='),\n      $ne: this.binary('!='),\n      $gt: this.binary('>'),\n      $gte: this.binary('>='),\n      $lt: this.binary('<'),\n      $lte: this.binary('<='),\n\n      // aggregation\n      $sum: (expr) => `ifnull(sum(${this.parseAggr(expr)}), 0)`,\n      $avg: (expr) => `avg(${this.parseAggr(expr)})`,\n      $min: (expr) => `min(${this.parseAggr(expr)})`,\n      $max: (expr) => `max(${this.parseAggr(expr)})`,\n      $count: (expr) => `count(distinct ${this.parseAggr(expr)})`,\n    }\n  }\n\n  protected createNullQuery(key: string, value: boolean) {\n    return `${key} is ${value ? 'not ' : ''} null`\n  }\n\n  protected createMemberQuery(key: string, value: any[], notStr = '') {\n    if (!value.length) return notStr ? '1' : '0'\n    return `${key}${notStr} in (${value.map(val => this.escape(val)).join(', ')})`\n  }\n\n  protected createRegExpQuery(key: string, value: RegExp) {\n    return `${key} regexp ${this.escape(value.source)}`\n  }\n\n  protected createElementQuery(key: string, value: any) {\n    return `find_in_set(${this.escape(value)}, ${key})`\n  }\n\n  protected comparator(operator: string) {\n    return function (key: string, value: any) {\n      return `${key} ${operator} ${this.escape(value)}`\n    }.bind(this)\n  }\n\n  protected binary(operator: string) {\n    return function ([left, right]) {\n      return `(${this.parseEval(left)} ${operator} ${this.parseEval(right)})`\n    }.bind(this)\n  }\n\n  protected logicalAnd(conditions: string[]) {\n    if (!conditions.length) return '1'\n    if (conditions.includes('0')) return '0'\n    return conditions.join(' AND ')\n  }\n\n  protected logicalOr(conditions: string[]) {\n    if (!conditions.length) return '0'\n    if (conditions.includes('1')) return '1'\n    return `(${conditions.join(' OR ')})`\n  }\n\n  protected logicalNot(condition: string) {\n    return `NOT(${condition})`\n  }\n\n  protected parseFieldQuery(key: string, query: Query.FieldExpr) {\n    const conditions: string[] = []\n\n    // query shorthand\n    if (Array.isArray(query)) {\n      conditions.push(this.createMemberQuery(key, query))\n    } else if (query instanceof RegExp) {\n      conditions.push(this.createRegExpQuery(key, query))\n    } else if (typeof query === 'string' || typeof query === 'number' || query instanceof Date) {\n      conditions.push(this.createEqualQuery(key, query))\n    } else if (isNullable(query)) {\n      conditions.push(this.createNullQuery(key, false))\n    } else {\n      // query expression\n      for (const prop in query) {\n        if (prop in this.queryOperators) {\n          conditions.push(this.queryOperators[prop](key, query[prop]))\n        }\n      }\n    }\n\n    return this.logicalAnd(conditions)\n  }\n\n  parseQuery(query: Query.Expr) {\n    const conditions: string[] = []\n    for (const key in query) {\n    // logical expression\n      if (key === '$not') {\n        conditions.push(this.logicalNot(this.parseQuery(query.$not)))\n      } else if (key === '$and') {\n        conditions.push(this.logicalAnd(query.$and.map(this.parseQuery.bind(this))))\n      } else if (key === '$or') {\n        conditions.push(this.logicalOr(query.$or.map(this.parseQuery.bind(this))))\n      } else if (key === '$expr') {\n        conditions.push(this.parseEval(query.$expr))\n      } else {\n        conditions.push(this.parseFieldQuery(this.escapeId(key), query[key]))\n      }\n    }\n\n    return this.logicalAnd(conditions)\n  }\n\n  private parseEvalExpr(expr: any, table?: string, field?: string) {\n    for (const key in expr) {\n      if (key in this.evalOperators) {\n        return this.evalOperators[key](expr[key])\n      }\n    }\n    return this.escape(expr, table, field)\n  }\n\n  private parseAggr(expr: any) {\n    if (typeof expr === 'string') {\n      return this.getRecursive(expr)\n    }\n    return this.parseEvalExpr(expr)\n  }\n\n  private getRecursive(args: string | string[]) {\n    if (typeof args === 'string') {\n      return this.getRecursive(['_', args])\n    } else {\n      const [, key] = args\n      if (!key.includes('.')) return this.escapeId(key)\n      const [field, ...rest] = key.split('.')\n      return `json_unquote(json_extract(${this.escapeId(field)}, '$${rest.map(key => `.\"${key}\"`).join('')}'))`\n    }\n  }\n\n  parseEval(expr: any, table?: string, field?: string): string {\n    if (typeof expr === 'string' || typeof expr === 'number' || typeof expr === 'boolean' || expr instanceof Date) {\n      return this.escape(expr, table, field)\n    }\n    return this.parseEvalExpr(expr, table, field)\n  }\n}\n\nexport interface TypeCaster<S = any, T = any> {\n  types: Field.Type<S>[]\n  dump: (value: S) => T\n  load: (value: T, initial?: S) => S\n}\n\nexport class Caster {\n  protected types: Dict<TypeCaster>\n\n  constructor(private models: Dict<Model>) {\n    this.types = Object.create(null)\n  }\n\n  register<S, T>(typeCaster: TypeCaster<S, T>) {\n    typeCaster.types.forEach(type => this.types[type] = typeCaster)\n  }\n\n  dump(table: string, obj: any): any {\n    obj = this.models[table].format(obj)\n    const { fields } = this.models[table]\n    const result = {}\n    for (const key in obj) {\n      const converter = this.types[fields[key]?.type]\n      result[key] = converter ? converter.dump(obj[key]) : obj[key]\n    }\n    return result\n  }\n\n  load(table: string, obj: any): any {\n    const { fields } = this.models[table]\n    const result = {}\n    for (const key in obj) {\n      if (!(key in fields)) continue\n      const { type, initial } = fields[key]\n      const converter = this.types[type]\n      result[key] = converter ? converter.load(obj[key], initial) : obj[key]\n    }\n    return this.models[table].parse(result)\n  }\n}\n"],
  "mappings": "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",
  "names": ["value", "key"]
}
