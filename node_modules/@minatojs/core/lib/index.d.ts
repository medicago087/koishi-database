import { Intersect, MaybeArray, Dict, Extract } from 'cosmokit';
export type Values<S> = S[keyof S];
export type Keys<O, T = any> = Values<{
    [K in keyof O]: O[K] extends T ? K : never;
}> & string;
export type Atomic = number | string | boolean | bigint | symbol | Date;
export type Indexable = string | number;
export type Comparable = string | number | boolean | Date;
type FlatWrap<S, T, P extends string> = {
    [K in P]?: S;
} | (S extends Atomic | T ? never : S extends any[] ? never : string extends keyof S ? never : FlatMap<S, T, `${P}.`>);
type FlatMap<S, T = never, P extends string = ''> = Values<{
    [K in keyof S & string as `${P}${K}`]: FlatWrap<S[K], S | T, `${P}${K}`>;
}>;
export type Flatten<S> = Intersect<FlatMap<S>>;
export function isComparable(value: any): value is Comparable;
export function randomId(): string;
export function isEvalExpr(value: any): value is Eval.Expr;
type $Date = Date;
export type Uneval<U> = U extends number ? Eval.Number : U extends string ? Eval.String : U extends boolean ? Eval.Boolean : U extends $Date ? Eval.Date : any;
export type Eval<U> = U extends Comparable ? U : U extends Eval.Expr<infer T> ? T : never;
declare const kExpr: unique symbol;
declare const kType: unique symbol;
export namespace Eval {
    interface Expr<T = any> {
        [kExpr]: true;
        [kType]?: T;
    }
    type Number = number | Expr<number>;
    type String = string | Expr<string>;
    type Boolean = boolean | Expr<boolean>;
    type Date = $Date | Expr<$Date>;
    type Any = Comparable | Expr;
    interface Comparator {
        (x: Number, y: Number): Expr<boolean>;
        (x: String, y: String): Expr<boolean>;
        (x: Date, y: Date): Expr<boolean>;
    }
    interface Static {
        (key: string, value: any): Eval.Expr;
        if<T extends Comparable>(cond: Any, vThen: T | Expr<T>, vElse: T | Expr<T>): Expr<T>;
        ifNull<T extends Comparable>(...args: (T | Expr<T>)[]): Expr<T>;
        add(...args: Number[]): Expr<number>;
        multiply(...args: Number[]): Expr<number>;
        subtract(x: Number, y: Number): Expr<number>;
        divide(x: Number, y: Number): Expr<number>;
        eq(x: Any, y: Any): Expr<boolean>;
        ne(x: Any, y: Any): Expr<boolean>;
        gt: Comparator;
        gte: Comparator;
        lt: Comparator;
        lte: Comparator;
        concat(...args: String[]): Expr<string>;
        and(...args: Boolean[]): Expr<boolean>;
        or(...args: Boolean[]): Expr<boolean>;
        not(value: Boolean): Expr<boolean>;
        sum(value: Number): Expr<number>;
        avg(value: Number): Expr<number>;
        max(value: Number): Expr<number>;
        min(value: Number): Expr<number>;
        count(value: Any): Expr<number>;
    }
}
export const Eval: Eval.Static;
export { Eval as $ };
type MapUneval<S> = {
    [K in keyof S]?: Uneval<S[K]>;
};
export type Update<T = any> = MapUneval<Flatten<T>>;
export function executeEval(data: any, expr: any): any;
export function executeUpdate(data: any, update: any, ref: string): any;
export interface Field<T = any> {
    type: Field.Type<T>;
    length?: number;
    nullable?: boolean;
    initial?: T;
    precision?: number;
    scale?: number;
}
export namespace Field {
    export const number: Type[];
    export const string: Type[];
    export const boolean: Type[];
    export const date: Type[];
    export const object: Type[];
    export type Type<T = any> = T extends number ? 'integer' | 'unsigned' | 'float' | 'double' | 'decimal' : T extends string ? 'char' | 'string' | 'text' : T extends boolean ? 'boolean' : T extends Date ? 'timestamp' | 'date' | 'time' : T extends unknown[] ? 'list' | 'json' : T extends object ? 'json' : never;
    type Shorthand<S extends string> = S | `${S}(${any})`;
    type MapField<O = any> = {
        [K in keyof O]?: O[K] extends (...args: any) => any ? O[K] : Field<O[K]> | Shorthand<Type<O[K]>>;
    };
    export type Extension<O = any> = MapField<Flatten<O>>;
    export type Config<O = any> = {
        [K in keyof O]?: O[K] extends (...args: any) => any ? never : Field<O[K]>;
    };
    export type Internal<O = any> = {
        [K in keyof O]?: O[K] extends (...args: any) => any ? O[K] : never;
    };
    export function parse(source: string | Field): Field;
}
export namespace Model {
    interface Config<O = {}> {
        driver?: keyof any;
        autoInc?: boolean;
        primary?: MaybeArray<Keys<O>>;
        unique?: MaybeArray<Keys<O>>[];
        foreign?: {
            [K in keyof O]?: [string, string];
        };
    }
}
export interface Model<S> extends Model.Config<S> {
}
export class Model<S = any> {
    name: string;
    fields: Field.Config<S>;
    internal: Field.Internal<S>;
    constructor(name: string);
    extend(fields: Field.Extension<S>, config?: Model.Config<S>): void;
    private checkIndex;
    resolveValue(key: string, value: any): any;
    format(source: object, strict?: boolean, prefix?: string, result?: S): S;
    parse(source: object): any;
    create(data?: {}): any;
}
export type Direction = 'asc' | 'desc';
export interface Modifier {
    limit: number;
    offset: number;
    sort: [Eval.Expr, Direction][];
}
export namespace Executable {
    type Action = 'get' | 'set' | 'remove' | 'create' | 'upsert' | 'eval';
    interface Payload {
        type: Action;
        table: string;
        ref: string;
        query: Query.Expr;
        fields?: Dict<Eval.Expr>;
        expr?: Eval.Expr;
        args?: any[];
    }
}
export interface Executable extends Executable.Payload {
}
export class Executable<S = any, T = any> {
    #private;
    driver: Driver;
    constructor(driver: Driver, payload?: Executable.Payload);
    get row(): any;
    get model(): Model<any>;
    protected resolveQuery(query: Query<S>): Query.Expr<S>;
    resolveData(data: any, fields: Dict<Eval.Expr<any>>): any;
    protected resolveField(field: Selection.Field<S>): Eval.Expr;
    execute(): Promise<T>;
}
export namespace Selection {
    type Callback<S, T = any> = (row: Row<S>) => Eval.Expr<T>;
    type Field<S = any> = Keys<S> | Callback<S>;
    type Take<S, F extends Field<S>> = F extends Keys<S> ? S[F] : F extends Callback<S> ? Eval<ReturnType<F>> : never;
    type Row<S> = {
        [K in keyof S]: Eval.Expr<S[K]> & (S[K] extends Comparable ? {} : Row<S[K]>);
    };
    type Yield<S, T> = T | ((row: Row<S>) => T);
    type Project<S, T extends Dict<Field<S>>> = {
        [K in keyof T]: Take<S, T[K]>;
    };
    type Selector<S> = Keys<S>;
    type Resolve<S, T> = T extends Keys<S> ? S[T] : never;
}
export class Selection<S = any> extends Executable<S, S[]> {
    args: [Modifier];
    constructor(driver: Driver, table: string, query: Query);
    limit(limit: number): this;
    offset(offset: number): this;
    orderBy(field: Selection.Field<S>, direction?: Direction): this;
    project<T extends Keys<S>>(fields: T[]): Selection<Pick<S, T>>;
    project<T extends Dict<Selection.Field<S>>>(fields: T): Selection<Selection.Project<S, T>>;
    action(type: Executable.Action, ...args: any[]): Executable<any, any>;
    evaluate<T>(callback: Selection.Callback<S, T>): Executable<S, T>;
}
export function executeSort(data: any[], modifier: Modifier, name: string): any[];
export type Query<T = any> = Query.Expr<T> | Query.Shorthand<Indexable> | Selection.Callback<T, boolean>;
export namespace Query {
    interface FieldExpr<T = any> {
        $or?: FieldQuery<T>[];
        $and?: FieldQuery<T>[];
        $not?: FieldQuery<T>;
        $exists?: boolean;
        $in?: Extract<T, Indexable, T[]>;
        $nin?: Extract<T, Indexable, T[]>;
        $eq?: Extract<T, Comparable>;
        $ne?: Extract<T, Comparable>;
        $gt?: Extract<T, Comparable>;
        $gte?: Extract<T, Comparable>;
        $lt?: Extract<T, Comparable>;
        $lte?: Extract<T, Comparable>;
        $el?: T extends (infer U)[] ? FieldQuery<U> : never;
        $size?: Extract<T, any[], number>;
        $regex?: Extract<T, string, RegExp>;
        $regexFor?: Extract<T, string>;
        $bitsAllClear?: Extract<T, number>;
        $bitsAllSet?: Extract<T, number>;
        $bitsAnyClear?: Extract<T, number>;
        $bitsAnySet?: Extract<T, number>;
    }
    interface LogicalExpr<T = any> {
        $or?: Expr<T>[];
        $and?: Expr<T>[];
        $not?: Expr<T>;
        /** @deprecated use query callback instead */
        $expr?: Eval.Expr<boolean>;
    }
    type Shorthand<T = any> = Extract<T, Comparable> | Extract<T, Indexable, T[]> | Extract<T, string, RegExp>;
    type FieldQuery<T = any> = FieldExpr<T> | Shorthand<T>;
    type Expr<T = any> = LogicalExpr<T> & {
        [K in keyof T]?: FieldQuery<T[K]>;
    };
}
export function executeQuery(data: any, query: Query.Expr, ref: string): boolean;
export type Result<S, K, T = (...args: any) => any> = {
    [P in keyof S as S[P] extends T ? P : P extends K ? P : never]: S[P];
};
export namespace Driver {
    interface Stats {
        size?: number;
        tables?: Dict<TableStats>;
    }
    interface TableStats {
        count: number;
        size: number;
    }
    type Cursor<K extends string = never> = K[] | CursorOptions<K>;
    interface CursorOptions<K> {
        limit?: number;
        offset?: number;
        fields?: K[];
        sort?: Dict<Direction>;
    }
}
export class Database<S = any> {
    tables: {
        [K in Keys<S>]?: Model<S[K]>;
    };
    drivers: Record<keyof any, Driver>;
    private tasks;
    private stashed;
    refresh(): void;
    private getDriver;
    private prepare;
    extend<K extends Keys<S>>(name: K, fields: Field.Extension<S[K]>, config?: Model.Config<S[K]>): void;
    select<T extends Selection.Selector<S>>(table: T, query?: Query<Selection.Resolve<S, T>>): Selection<Selection.Resolve<S, T>>;
    get<T extends Keys<S>, K extends Keys<S[T]>>(table: T, query: Query<Selection.Resolve<S, T>>, cursor?: Driver.Cursor<K>): Promise<Result<S[T], K>[]>;
    eval<K extends Keys<S>, T>(table: K, expr: Selection.Callback<S[K], T>, query?: Query): Promise<T>;
    /** @deprecated use selection callback instead */
    eval(table: Keys<S>, expr: any, query?: Query): Promise<any>;
    set<T extends Keys<S>>(table: T, query: Query<Selection.Resolve<S, T>>, update: Selection.Yield<S[T], Update<S[T]>>): Promise<void>;
    remove<T extends Keys<S>>(table: T, query: Query<Selection.Resolve<S, T>>): Promise<void>;
    create<T extends Keys<S>>(table: T, data: Partial<S[T]>): Promise<S[T]>;
    upsert<T extends Keys<S>>(table: T, upsert: Selection.Yield<S[T], Update<S[T]>[]>, keys?: MaybeArray<Keys<Flatten<S[T]>, Indexable>>): Promise<void>;
    stopAll(): Promise<void>;
    dropAll(): Promise<void>;
    stats(): Promise<Driver.Stats>;
}
export namespace Driver {
    type Constructor<T = any> = new (database: Database, config?: T) => Driver;
}
export abstract class Driver {
    database: Database;
    abstract start(): Promise<void>;
    abstract stop(): Promise<void>;
    abstract drop(): Promise<void>;
    abstract stats(): Promise<Driver.Stats>;
    abstract prepare(name: string): Promise<void>;
    abstract get(sel: Executable, modifier: Modifier): Promise<any>;
    abstract eval(sel: Executable, expr: Eval.Expr): Promise<any>;
    abstract set(sel: Executable, data: Update): Promise<void>;
    abstract remove(sel: Executable): Promise<void>;
    abstract create(sel: Executable, data: any): Promise<any>;
    abstract upsert(sel: Executable, data: any[], keys: string[]): Promise<void>;
    constructor(database: Database);
    model(name: string): Model<any>;
    execute(executable: Executable): any;
}
export namespace RuntimeError {
    type Code = 'duplicate-entry' | 'unsupported-expression';
}
export class RuntimeError<T extends RuntimeError.Code> extends Error {
    code: T;
    name: string;
    constructor(code: T, message?: string);
    static check<T extends RuntimeError.Code>(error: any, code?: RuntimeError.Code): error is RuntimeError<T>;
}
