{
  "version": 3,
  "sources": ["../src/index.ts", "../src/driver.ts", "../src/model.ts", "../src/eval.ts", "../src/utils.ts", "../src/selection.ts", "../src/error.ts", "../src/query.ts"],
  "sourcesContent": ["export * from './driver'\nexport * from './error'\nexport * from './eval'\nexport * from './model'\nexport * from './query'\nexport * from './selection'\nexport * from './utils'\n", "import { Dict, makeArray, MaybeArray } from 'cosmokit'\nimport { Eval, Update } from './eval'\nimport { Field, Model } from './model'\nimport { Query } from './query'\nimport { Flatten, Indexable, Keys } from './utils'\nimport { Direction, Executable, Modifier, Selection } from './selection'\n\nexport type Result<S, K, T = (...args: any) => any> = {\n  [P in keyof S as S[P] extends T ? P : P extends K ? P : never]: S[P]\n}\n\nexport namespace Driver {\n  export interface Stats {\n    size?: number\n    tables?: Dict<TableStats>\n  }\n\n  export interface TableStats {\n    count: number\n    size: number\n  }\n\n  export type Cursor<K extends string = never> = K[] | CursorOptions<K>\n\n  export interface CursorOptions<K> {\n    limit?: number\n    offset?: number\n    fields?: K[]\n    sort?: Dict<Direction>\n  }\n}\n\nexport class Database<S = any> {\n  public tables: { [K in Keys<S>]?: Model<S[K]> } = Object.create(null)\n  public drivers: Record<keyof any, Driver> = Object.create(null)\n  private tasks: Dict<Promise<void>> = Object.create(null)\n  private stashed = new Set<string>()\n\n  refresh() {\n    for (const name in this.tables) {\n      this.tasks[name] = this.prepare(name)\n    }\n  }\n\n  private getDriver(name: string) {\n    const model: Model = this.tables[name]\n    if (model.driver) return this.drivers[model.driver]\n    return Object.values(this.drivers)[0]\n  }\n\n  private async prepare(name: string) {\n    this.stashed.add(name)\n    await this.tasks[name]\n    return new Promise<void>(async (resolve) => {\n      Promise.resolve().then(async () => {\n        if (this.stashed.delete(name)) {\n          await this.getDriver(name)?.prepare(name)\n        }\n        resolve()\n      })\n    })\n  }\n\n  extend<K extends Keys<S>>(name: K, fields: Field.Extension<S[K]>, config: Model.Config<S[K]> = {}) {\n    let model = this.tables[name]\n    if (!model) {\n      model = this.tables[name] = new Model(name)\n      model.driver = config.driver\n    }\n    model.extend(fields, config)\n    this.tasks[name] = this.prepare(name)\n  }\n\n  select<T extends Selection.Selector<S>>(table: T, query?: Query<Selection.Resolve<S, T>>): Selection<Selection.Resolve<S, T>> {\n    return new Selection(this.getDriver(table), table, query)\n  }\n\n  async get<T extends Keys<S>, K extends Keys<S[T]>>(table: T, query: Query<Selection.Resolve<S, T>>, cursor?: Driver.Cursor<K>): Promise<Result<S[T], K>[]> {\n    await this.tasks[table]\n    if (Array.isArray(cursor)) {\n      cursor = { fields: cursor }\n    } else if (!cursor) {\n      cursor = {}\n    }\n\n    const selection = this.select(table, query)\n    if (cursor.fields) selection.project(cursor.fields)\n    if (cursor.limit !== undefined) selection.limit(cursor.limit)\n    if (cursor.offset !== undefined) selection.offset(cursor.offset)\n    if (cursor.sort) {\n      for (const field in cursor.sort) {\n        selection.orderBy(field as any, cursor.sort[field])\n      }\n    }\n    return selection.execute()\n  }\n\n  eval<K extends Keys<S>, T>(table: K, expr: Selection.Callback<S[K], T>, query?: Query): Promise<T>\n  /** @deprecated use selection callback instead */\n  eval(table: Keys<S>, expr: any, query?: Query): Promise<any>\n  async eval(table: Keys<S>, expr: any, query?: Query) {\n    await this.tasks[table]\n    return this.select(table, query)\n      .evaluate(typeof expr === 'function' ? expr : () => expr)\n      .execute()\n  }\n\n  async set<T extends Keys<S>>(table: T, query: Query<Selection.Resolve<S, T>>, update: Selection.Yield<S[T], Update<S[T]>>) {\n    await this.tasks[table]\n    const sel = this.select(table, query)\n    if (typeof update === 'function') update = update(sel.row)\n    const primary = makeArray(sel.model.primary)\n    if (primary.some(key => key in update)) {\n      throw new TypeError(`cannot modify primary key`)\n    }\n    await sel.action('set', sel.model.format(update)).execute()\n  }\n\n  async remove<T extends Keys<S>>(table: T, query: Query<Selection.Resolve<S, T>>) {\n    await this.tasks[table]\n    const sel = this.select(table, query)\n    await sel.action('remove').execute()\n  }\n\n  async create<T extends Keys<S>>(table: T, data: Partial<S[T]>): Promise<S[T]> {\n    await this.tasks[table]\n    const sel = this.select(table)\n    return sel.action('create', sel.model.create(data)).execute()\n  }\n\n  async upsert<T extends Keys<S>>(table: T, upsert: Selection.Yield<S[T], Update<S[T]>[]>, keys?: MaybeArray<Keys<Flatten<S[T]>, Indexable>>) {\n    await this.tasks[table]\n    const sel = this.select(table)\n    if (typeof upsert === 'function') upsert = upsert(sel.row)\n    upsert = upsert.map(item => sel.model.format(item))\n    keys = makeArray(keys || sel.model.primary) as any\n    await sel.action('upsert', upsert, keys).execute()\n  }\n\n  async stopAll() {\n    const drivers = Object.values(this.drivers)\n    this.drivers = Object.create(null)\n    await Promise.all(drivers.map(driver => driver.stop()))\n  }\n\n  async dropAll() {\n    await Promise.all(Object.values(this.drivers).map(driver => driver.drop()))\n  }\n\n  async stats() {\n    const stats: Driver.Stats = { size: 0, tables: {} }\n    await Promise.all(Object.values(this.drivers).map(async (driver) => {\n      const { size, tables } = await driver.stats()\n      stats.size += size\n      Object.assign(stats.tables, tables)\n    }))\n    return stats\n  }\n}\n\nexport namespace Driver {\n  export type Constructor<T = any> = new (database: Database, config?: T) => Driver\n}\n\nexport abstract class Driver {\n  abstract start(): Promise<void>\n  abstract stop(): Promise<void>\n  abstract drop(): Promise<void>\n  abstract stats(): Promise<Driver.Stats>\n  abstract prepare(name: string): Promise<void>\n  abstract get(sel: Executable, modifier: Modifier): Promise<any>\n  abstract eval(sel: Executable, expr: Eval.Expr): Promise<any>\n  abstract set(sel: Executable, data: Update): Promise<void>\n  abstract remove(sel: Executable): Promise<void>\n  abstract create(sel: Executable, data: any): Promise<any>\n  abstract upsert(sel: Executable, data: any[], keys: string[]): Promise<void>\n\n  constructor(public database: Database) {}\n\n  model(name: string) {\n    const model = this.database.tables[name]\n    if (model) return model\n    throw new TypeError(`unknown table name \"${name}\"`)\n  }\n\n  execute(executable: Executable) {\n    const { type, args } = executable\n    return this[type as any](executable, ...args)\n  }\n}\n", "import { clone, isNullable, makeArray, MaybeArray } from 'cosmokit'\nimport { isEvalExpr } from './eval'\nimport { Flatten, Keys } from './utils'\n\nexport interface Field<T = any> {\n  type: Field.Type<T>\n  length?: number\n  nullable?: boolean\n  initial?: T\n  precision?: number\n  scale?: number\n}\n\nexport namespace Field {\n  export const number: Type[] = ['integer', 'unsigned', 'float', 'double', 'decimal']\n  export const string: Type[] = ['char', 'string', 'text']\n  export const boolean: Type[] = ['boolean']\n  export const date: Type[] = ['timestamp', 'date', 'time']\n  export const object: Type[] = ['list', 'json']\n\n  export type Type<T = any> =\n    | T extends number ? 'integer' | 'unsigned' | 'float' | 'double' | 'decimal'\n    : T extends string ? 'char' | 'string' | 'text'\n    : T extends boolean ? 'boolean'\n    : T extends Date ? 'timestamp' | 'date' | 'time'\n    : T extends unknown[] ? 'list' | 'json'\n    : T extends object ? 'json'\n    : never\n\n  type Shorthand<S extends string> = S | `${S}(${any})`\n\n  type MapField<O = any> = {\n    [K in keyof O]?: O[K] extends (...args: any) => any\n      ? O[K]\n      : Field<O[K]> | Shorthand<Type<O[K]>>\n  }\n\n  export type Extension<O = any> = MapField<Flatten<O>>\n\n  export type Config<O = any> = {\n    [K in keyof O]?: O[K] extends (...args: any) => any ? never : Field<O[K]>\n  }\n\n  export type Internal<O = any> = {\n    [K in keyof O]?: O[K] extends (...args: any) => any ? O[K] : never\n  }\n\n  const regexp = /^(\\w+)(?:\\((.+)\\))?$/\n\n  export function parse(source: string | Field): Field {\n    if (typeof source !== 'string') return { initial: null, ...source }\n\n    // parse string definition\n    const capture = regexp.exec(source)\n    if (!capture) throw new TypeError('invalid field definition')\n    const type = capture[1] as Type\n    const args = (capture[2] || '').split(',')\n    const field: Field = { type }\n\n    // set default initial value\n    if (field.initial === undefined) {\n      if (number.includes(field.type)) field.initial = 0\n      if (string.includes(field.type)) field.initial = ''\n      if (field.type === 'list') field.initial = []\n      if (field.type === 'json') field.initial = {}\n    }\n\n    // set length information\n    if (type === 'decimal') {\n      field.precision = +args[0]\n      field.scale = +args[1]\n    } else if (args[0]) {\n      field.length = +args[0]\n    }\n\n    return field\n  }\n}\n\nexport namespace Model {\n  export interface Config<O = {}> {\n    driver?: keyof any\n    autoInc?: boolean\n    primary?: MaybeArray<Keys<O>>\n    unique?: MaybeArray<Keys<O>>[]\n    foreign?: {\n      [K in keyof O]?: [string, string]\n    }\n  }\n}\n\nexport interface Model<S> extends Model.Config<S> {}\n\nexport class Model<S = any> {\n  fields: Field.Config<S> = {}\n  internal: Field.Internal<S> = { '': {} } as never\n\n  constructor(public name: string) {\n    this.primary = 'id' as never\n    this.unique = []\n    this.foreign = {}\n  }\n\n  extend(fields: Field.Extension<S>, config?: Model.Config<S>): void\n  extend(fields = {}, config: Model.Config = {}) {\n    const { primary, autoInc, unique = [] as [], foreign } = config\n\n    this.primary = primary || this.primary\n    this.autoInc = autoInc || this.autoInc\n    this.unique.push(...unique)\n    Object.assign(this.foreign, foreign)\n\n    for (const key in fields) {\n      if (typeof fields[key] === 'function') {\n        const index = key.lastIndexOf('.')\n        const prefix = key.slice(0, index + 1)\n        const method = key.slice(index + 1)\n        ;(this.internal[prefix] ??= {})[method] = fields[key]\n      } else {\n        this.fields[key] = Field.parse(fields[key])\n      }\n    }\n\n    // check index\n    this.checkIndex(this.primary)\n    this.unique.forEach(index => this.checkIndex(index))\n  }\n\n  private checkIndex(index: MaybeArray<string>) {\n    for (const key of makeArray(index)) {\n      if (!this.fields[key]) {\n        throw new TypeError(`missing field definition for index key \"${key}\"`)\n      }\n    }\n  }\n\n  resolveValue(key: string, value: any) {\n    if (isNullable(value)) return value\n    if (this.fields[key]?.type === 'time') {\n      const date = new Date(0)\n      date.setHours(value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds())\n      return date\n    }\n    return value\n  }\n\n  format(source: object, strict = true, prefix = '', result = {} as S) {\n    const fields = Object.keys(this.fields)\n    Object.entries(source).map(([key, value]) => {\n      key = prefix + key\n      if (fields.includes(key)) {\n        result[key] = value\n      } else if (!value || typeof value !== 'object' || isEvalExpr(value)) {\n        const field = fields.find(field => key.startsWith(field + '.'))\n        if (field) {\n          result[key] = value\n        } else if (strict) {\n          throw new TypeError(`unknown field \"${key}\" in model ${this.name}`)\n        }\n      } else {\n        this.format(value, strict, key + '.', result)\n      }\n    })\n    return result\n  }\n\n  parse(source: object) {\n    const result: any = Object.create(this.internal[''])\n    for (const key in source) {\n      let node = result\n      const segments = key.split('.').reverse()\n      let prefix = ''\n      for (let index = segments.length - 1; index > 0; index--) {\n        const segment = segments[index]\n        prefix += segment + '.'\n        node = node[segment] ??= Object.create(this.internal[prefix] ?? {})\n      }\n      if (key in source) {\n        const value = this.resolveValue(key, source[key])\n        node[segments[0]] = value\n      }\n    }\n    return result\n  }\n\n  create(data?: {}) {\n    const result = {} as S\n    const keys = makeArray(this.primary)\n    for (const key in this.fields) {\n      if (!keys.includes(key) && !isNullable(this.fields[key].initial)) {\n        result[key] = clone(this.fields[key].initial)\n      }\n    }\n    return this.parse({ ...result, ...data })\n  }\n}\n", "import { isNullable } from 'cosmokit'\nimport { Comparable, Flatten, isComparable } from './utils'\n\n// for backwards compatibility, TODO remove in v2\nexport function isEvalExpr(value: any): value is Eval.Expr {\n  return value && Object.keys(value).some(key => key.startsWith('$'))\n}\n\ntype $Date = Date\n\nexport type Uneval<U> =\n  | U extends number ? Eval.Number\n  : U extends string ? Eval.String\n  : U extends boolean ? Eval.Boolean\n  : U extends $Date ? Eval.Date\n  : any\n\nexport type Eval<U> =\n  | U extends Comparable ? U\n  : U extends Eval.Expr<infer T> ? T\n  : never\n\nconst kExpr = Symbol('expr')\nconst kType = Symbol('type')\n\nexport namespace Eval {\n  export interface Expr<T = any> {\n    [kExpr]: true\n    [kType]?: T\n  }\n\n  export type Number = number | Expr<number>\n  export type String = string | Expr<string>\n  export type Boolean = boolean | Expr<boolean>\n  export type Date = $Date | Expr<$Date>\n  export type Any = Comparable | Expr\n\n  export interface Comparator {\n    (x: Number, y: Number): Expr<boolean>\n    (x: String, y: String): Expr<boolean>\n    (x: Date, y: Date): Expr<boolean>\n  }\n\n  export interface Static {\n    (key: string, value: any): Eval.Expr\n\n    // univeral\n    if<T extends Comparable>(cond: Any, vThen: T | Expr<T>, vElse: T | Expr<T>): Expr<T>\n    ifNull<T extends Comparable>(...args: (T | Expr<T>)[]): Expr<T>\n\n    // arithmetic\n    add(...args: Number[]): Expr<number>\n    multiply(...args: Number[]): Expr<number>\n    subtract(x: Number, y: Number): Expr<number>\n    divide(x: Number, y: Number): Expr<number>\n\n    // comparison\n    eq(x: Any, y: Any): Expr<boolean>\n    ne(x: Any, y: Any): Expr<boolean>\n    gt: Comparator\n    gte: Comparator\n    lt: Comparator\n    lte: Comparator\n\n    // string\n    concat(...args: String[]): Expr<string>\n\n    // logical\n    and(...args: Boolean[]): Expr<boolean>\n    or(...args: Boolean[]): Expr<boolean>\n    not(value: Boolean): Expr<boolean>\n\n    // aggregation\n    sum(value: Number): Expr<number>\n    avg(value: Number): Expr<number>\n    max(value: Number): Expr<number>\n    min(value: Number): Expr<number>\n    count(value: Any): Expr<number>\n  }\n}\n\nexport const Eval = ((key, value) => ({ [kExpr]: true, ['$' + key]: value })) as Eval.Static\n\nconst operators = {} as Record<keyof Eval.Static, (args: any, data: any) => any>\n\noperators['$'] = getRecursive\n\ntype UnaryCallback<T> = T extends (value: infer R) => Eval.Expr<infer S> ? (value: R, data: any[]) => S : never\nfunction unary<K extends keyof Eval.Static>(key: K, callback: UnaryCallback<Eval.Static[K]>): Eval.Static[K] {\n  operators['$' + key] = callback\n  return (value: any) => Eval(key, value)\n}\n\ntype MultaryCallback<T> = T extends (...args: infer R) => Eval.Expr<infer S> ? (args: R, data: any) => S : never\nfunction multary<K extends keyof Eval.Static>(key: K, callback: MultaryCallback<Eval.Static[K]>): Eval.Static[K] {\n  operators['$' + key] = callback\n  return (...args: any) => Eval(key, args)\n}\n\n// univeral\nEval.if = multary('if', ([cond, vThen, vElse], data) => executeEval(data, cond) ? executeEval(data, vThen) : executeEval(data, vElse))\nEval.ifNull = multary('ifNull', ([value, fallback], data) => executeEval(data, value) ?? executeEval(data, fallback))\n\n// arithmetic\nEval.add = multary('add', (args, data) => args.reduce<number>((prev, curr) => prev + executeEval(data, curr), 0))\nEval.multiply = multary('multiply', (args, data) => args.reduce<number>((prev, curr) => prev * executeEval(data, curr), 1))\nEval.subtract = multary('subtract', ([left, right], data) => executeEval(data, left) - executeEval(data, right))\nEval.divide = multary('divide', ([left, right], data) => executeEval(data, left) / executeEval(data, right))\n\n// comparison\nEval.eq = multary('eq', ([left, right], data) => executeEval(data, left).valueOf() === executeEval(data, right).valueOf())\nEval.ne = multary('ne', ([left, right], data) => executeEval(data, left).valueOf() !== executeEval(data, right).valueOf())\nEval.gt = multary('gt', ([left, right], data) => executeEval(data, left).valueOf() > executeEval(data, right).valueOf())\nEval.gte = multary('gte', ([left, right], data) => executeEval(data, left).valueOf() >= executeEval(data, right).valueOf())\nEval.lt = multary('lt', ([left, right], data) => executeEval(data, left).valueOf() < executeEval(data, right).valueOf())\nEval.lte = multary('lte', ([left, right], data) => executeEval(data, left).valueOf() <= executeEval(data, right).valueOf())\n\n// string\nEval.concat = multary('concat', (args, data) => args.map(arg => executeEval(data, arg)).join(''))\n\n// logical\nEval.and = multary('and', (args, data) => args.every(arg => executeEval(data, arg)))\nEval.or = multary('or', (args, data) => args.some(arg => executeEval(data, arg)))\nEval.not = unary('not', (value, data) => !executeEval(data, value))\n\n// aggregation\nEval.sum = unary('sum', (expr, table) => table.reduce<number>((prev, curr) => prev + executeAggr(expr, curr), 0))\nEval.avg = unary('avg', (expr, table) => table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) / table.length)\nEval.max = unary('max', (expr, table) => Math.max(...table.map(data => executeAggr(expr, data))))\nEval.min = unary('min', (expr, table) => Math.min(...table.map(data => executeAggr(expr, data))))\nEval.count = unary('count', (expr, table) => new Set(table.map(data => executeAggr(expr, data))).size)\n\nexport { Eval as $ }\n\ntype MapUneval<S> = {\n  [K in keyof S]?: Uneval<S[K]>\n}\n\nexport type Update<T = any> = MapUneval<Flatten<T>>\n\nfunction getRecursive(args: string | string[], data: any) {\n  if (typeof args === 'string') {\n    // for backwards compatibility, TODO remove in v2\n    return getRecursive(['_', args], data)\n  }\n\n  const [ref, path] = args\n  let value = data[ref]\n  for (const key of path.split('.')) {\n    if (!value) return\n    value = value[key]\n  }\n  return value\n}\n\nfunction executeEvalExpr(expr: any, data: any) {\n  for (const key in expr) {\n    if (key in operators) {\n      return operators[key](expr[key], data)\n    }\n  }\n  return expr\n}\n\nfunction executeAggr(expr: any, data: any) {\n  if (typeof expr === 'string') {\n    return getRecursive(expr, data)\n  }\n  return executeEvalExpr(expr, data)\n}\n\nexport function executeEval(data: any, expr: any) {\n  if (isComparable(expr) || isNullable(expr)) {\n    return expr\n  }\n  return executeEvalExpr(expr, data)\n}\n\nexport function executeUpdate(data: any, update: any, ref: string) {\n  for (const key in update) {\n    let root = data\n    const path = key.split('.')\n    const last = path.pop()\n    for (const key of path) {\n      root = root[key] ||= {}\n    }\n    root[last] = executeEval({ [ref]: data, _: data }, update[key])\n  }\n  return data\n}\n", "import { Intersect } from 'cosmokit'\n\nexport type Values<S> = S[keyof S]\n\nexport type Keys<O, T = any> = Values<{\n  [K in keyof O]: O[K] extends T ? K : never\n}> & string\n\nexport type Atomic = number | string | boolean | bigint | symbol | Date\nexport type Indexable = string | number\nexport type Comparable = string | number | boolean | Date\n\ntype FlatWrap<S, T, P extends string> = { [K in P]?: S }\n  // rule out atomic / recursive types\n  | (S extends Atomic | T ? never\n  // rule out array types\n  : S extends any[] ? never\n  // rule out dict / infinite types\n  : string extends keyof S ? never\n  : FlatMap<S, T, `${P}.`>)\n\ntype FlatMap<S, T = never, P extends string = ''> = Values<{\n  [K in keyof S & string as `${P}${K}`]: FlatWrap<S[K], S | T, `${P}${K}`>\n}>\n\nexport type Flatten<S> = Intersect<FlatMap<S>>\n\nexport function isComparable(value: any): value is Comparable {\n  return typeof value === 'string'\n    || typeof value === 'number'\n    || typeof value === 'boolean'\n    || value instanceof Date\n}\n\nconst letters = 'abcdefghijklmnopqrstuvwxyz'\n\nexport function randomId() {\n  return Array(8).fill(0).map(() => letters[Math.floor(Math.random() * letters.length)]).join('')\n}\n", "import { defineProperty, Dict, pick, valueMap } from 'cosmokit'\nimport { Driver } from './driver'\nimport { Eval, executeEval } from './eval'\nimport { Model } from './model'\nimport { Query } from './query'\nimport { Comparable, Keys, randomId } from './utils'\n\nexport type Direction = 'asc' | 'desc'\n\nexport interface Modifier {\n  limit: number\n  offset: number\n  sort: [Eval.Expr, Direction][]\n}\n\nexport namespace Executable {\n  export type Action = 'get' | 'set' | 'remove' | 'create' | 'upsert' | 'eval'\n\n  export interface Payload {\n    type: Action\n    table: string\n    ref: string\n    query: Query.Expr\n    fields?: Dict<Eval.Expr>\n    expr?: Eval.Expr\n    args?: any[]\n  }\n}\n\nconst createRow = (ref: string, prefix = '', expr = {}) => new Proxy(expr, {\n  get(target, key) {\n    if (typeof key === 'symbol' || key.startsWith('$')) return Reflect.get(target, key)\n    return createRow(ref, `${prefix}${key}.`, Eval('', [ref, `${prefix}${key}`]))\n  },\n})\n\nexport interface Executable extends Executable.Payload {}\n\nexport class Executable<S = any, T = any> {\n  #row: Selection.Row<S>\n  #model: Model\n\n  public driver: Driver\n\n  constructor(driver: Driver, payload?: Executable.Payload) {\n    defineProperty(this, 'driver', driver)\n    Object.assign(this, payload)\n  }\n\n  get row() {\n    return this.#row ||= createRow(this.ref)\n  }\n\n  get model() {\n    return this.#model ||= this.driver.model(this.table)\n  }\n\n  protected resolveQuery(query: Query<S>): Query.Expr<S>\n  protected resolveQuery(query: Query<S> = {}): any {\n    if (typeof query === 'function') return { $expr: query(this.row) }\n    if (Array.isArray(query) || query instanceof RegExp || ['string', 'number'].includes(typeof query)) {\n      const { primary } = this.model\n      if (Array.isArray(primary)) {\n        throw new TypeError('invalid shorthand for composite primary key')\n      }\n      return { [primary]: query }\n    }\n    return query\n  }\n\n  resolveData(data: any, fields: Dict<Eval.Expr<any>>) {\n    data = this.model.format(data, false)\n    for (const key in this.model.fields) {\n      data[key] ??= null\n    }\n    if (!fields) return this.model.parse(data)\n    return this.model.parse(pick(data, Object.keys(fields)))\n  }\n\n  protected resolveField(field: Selection.Field<S>): Eval.Expr {\n    if (typeof field === 'string') {\n      return this.row[field]\n    } else if (typeof field === 'function') {\n      return field(this.row)\n    }\n  }\n\n  execute(): Promise<T> {\n    return this.driver.execute(this)\n  }\n}\n\nexport namespace Selection {\n  export type Callback<S, T = any> = (row: Row<S>) => Eval.Expr<T>\n  export type Field<S = any> = Keys<S> | Callback<S>\n  export type Take<S, F extends Field<S>> =\n    | F extends Keys<S> ? S[F]\n    : F extends Callback<S> ? Eval<ReturnType<F>>\n    : never\n\n  export type Row<S> = {\n    [K in keyof S]: Eval.Expr<S[K]> & (S[K] extends Comparable ? {} : Row<S[K]>)\n  }\n\n  export type Yield<S, T> = T | ((row: Row<S>) => T)\n\n  export type Project<S, T extends Dict<Field<S>>> = {\n    [K in keyof T]: Take<S, T[K]>\n  }\n\n  export type Selector<S> = Keys<S>// | Selection\n\n  export type Resolve<S, T> =\n    | T extends Keys<S> ? S[T]\n    // : T extends Selection<infer U> ? U\n    : never\n}\n\nexport class Selection<S = any> extends Executable<S, S[]> {\n  args: [Modifier]\n\n  constructor(driver: Driver, table: string, query: Query) {\n    super(driver)\n    this.type = 'get'\n    this.ref = randomId()\n    this.table = table\n    this.query = this.resolveQuery(query)\n    this.args = [{ sort: [], limit: Infinity, offset: 0 }]\n  }\n\n  limit(limit: number) {\n    this.args[0].limit = limit\n    return this\n  }\n\n  offset(offset: number) {\n    this.args[0].offset = offset\n    return this\n  }\n\n  orderBy(field: Selection.Field<S>, direction?: Direction) {\n    this.args[0].sort.push([this.resolveField(field), direction])\n    return this\n  }\n\n  project<T extends Keys<S>>(fields: T[]): Selection<Pick<S, T>>\n  project<T extends Dict<Selection.Field<S>>>(fields: T): Selection<Selection.Project<S, T>>\n  project(fields: Keys<S>[] | Dict<Selection.Field<S>>) {\n    if (Array.isArray(fields)) {\n      const modelFields = Object.keys(this.model.fields)\n      const keys = fields.flatMap((key) => {\n        if (this.model.fields[key]) return key\n        return modelFields.filter(path => path.startsWith(key + '.'))\n      })\n      this.fields = Object.fromEntries(keys.map(key => [key, this.row[key]]))\n    } else {\n      this.fields = valueMap(fields, field => this.resolveField(field))\n    }\n    return this as any\n  }\n\n  action(type: Executable.Action, ...args: any[]) {\n    return new Executable(this.driver, { ...this, type, args })\n  }\n\n  evaluate<T>(callback: Selection.Callback<S, T>): Executable<S, T> {\n    return this.action('eval', this.resolveField(callback))\n  }\n}\n\nexport function executeSort(data: any[], modifier: Modifier, name: string) {\n  const { limit, offset, sort } = modifier\n\n  // step 1: sort data\n  data.sort((a, b) => {\n    for (const [field, direction] of sort) {\n      const sign = direction === 'asc' ? 1 : -1\n      const x = executeEval({ [name]: a, _: a }, field)\n      const y = executeEval({ [name]: b, _: b }, field)\n      if (x < y) return -sign\n      if (x > y) return sign\n    }\n    return 0\n  })\n\n  // step 2: truncate data\n  return data.slice(offset, offset + limit)\n}\n", "export namespace RuntimeError {\n  export type Code =\n    | 'duplicate-entry'\n    | 'unsupported-expression'\n}\n\nexport class RuntimeError<T extends RuntimeError.Code> extends Error {\n  name = 'RuntimeError'\n\n  constructor(public code: T, message?: string) {\n    super(message || code.replace('-', ' '))\n  }\n\n  static check<T extends RuntimeError.Code>(error: any, code?: RuntimeError.Code): error is RuntimeError<T> {\n    if (!(error instanceof RuntimeError)) return false\n    return !code || error.message === code\n  }\n}\n", "import { Extract, isNullable } from 'cosmokit'\nimport { Eval, executeEval } from './eval'\nimport { Comparable, Indexable, isComparable } from './utils'\nimport { Selection } from './selection'\n\nexport type Query<T = any> = Query.Expr<T> | Query.Shorthand<Indexable> | Selection.Callback<T, boolean>\n\nexport namespace Query {\n  export interface FieldExpr<T = any> {\n    // logical\n    $or?: FieldQuery<T>[]\n    $and?: FieldQuery<T>[]\n    $not?: FieldQuery<T>\n\n    // existence\n    $exists?: boolean\n\n    // membership\n    $in?: Extract<T, Indexable, T[]>\n    $nin?: Extract<T, Indexable, T[]>\n\n    // arithmatic\n    $eq?: Extract<T, Comparable>\n    $ne?: Extract<T, Comparable>\n    $gt?: Extract<T, Comparable>\n    $gte?: Extract<T, Comparable>\n    $lt?: Extract<T, Comparable>\n    $lte?: Extract<T, Comparable>\n\n    // list\n    $el?: T extends (infer U)[] ? FieldQuery<U> : never\n    $size?: Extract<T, any[], number>\n\n    // regexp\n    $regex?: Extract<T, string, RegExp>\n    $regexFor?: Extract<T, string>\n\n    // bitwise\n    $bitsAllClear?: Extract<T, number>\n    $bitsAllSet?: Extract<T, number>\n    $bitsAnyClear?: Extract<T, number>\n    $bitsAnySet?: Extract<T, number>\n  }\n\n  export interface LogicalExpr<T = any> {\n    $or?: Expr<T>[]\n    $and?: Expr<T>[]\n    $not?: Expr<T>\n    /** @deprecated use query callback instead */\n    $expr?: Eval.Expr<boolean>\n  }\n\n  export type Shorthand<T = any> =\n    | Extract<T, Comparable>\n    | Extract<T, Indexable, T[]>\n    | Extract<T, string, RegExp>\n\n  export type FieldQuery<T = any> = FieldExpr<T> | Shorthand<T>\n\n  export type Expr<T = any> = LogicalExpr<T> & {\n    [K in keyof T]?: FieldQuery<T[K]>\n  }\n}\n\ntype QueryOperators = {\n  [K in keyof Query.FieldExpr]?: (query: Query.FieldExpr[K], data: any) => boolean\n}\n\nconst queryOperators: QueryOperators = {\n  // logical\n  $or: (query, data) => query.reduce((prev, query) => prev || executeFieldQuery(query, data), false),\n  $and: (query, data) => query.reduce((prev, query) => prev && executeFieldQuery(query, data), true),\n  $not: (query, data) => !executeFieldQuery(query, data),\n\n  // existence\n  $exists: (query, data) => query !== isNullable(data),\n\n  // comparison\n  $eq: (query, data) => data.valueOf() === query.valueOf(),\n  $ne: (query, data) => data.valueOf() !== query.valueOf(),\n  $gt: (query, data) => data.valueOf() > query.valueOf(),\n  $gte: (query, data) => data.valueOf() >= query.valueOf(),\n  $lt: (query, data) => data.valueOf() < query.valueOf(),\n  $lte: (query, data) => data.valueOf() <= query.valueOf(),\n\n  // membership\n  $in: (query, data) => query.includes(data),\n  $nin: (query, data) => !query.includes(data),\n\n  // regexp\n  $regex: (query, data) => query.test(data),\n  $regexFor: (query, data) => new RegExp(data, 'i').test(query),\n\n  // bitwise\n  $bitsAllSet: (query, data) => (query & data) === query,\n  $bitsAllClear: (query, data) => (query & data) === 0,\n  $bitsAnySet: (query, data) => (query & data) !== 0,\n  $bitsAnyClear: (query, data) => (query & data) !== query,\n\n  // list\n  $el: (query, data) => data.some(item => executeFieldQuery(query, item)),\n  $size: (query, data) => data.length === query,\n}\n\nfunction executeFieldQuery(query: Query.FieldQuery, data: any) {\n  // shorthand syntax\n  if (Array.isArray(query)) {\n    return query.includes(data)\n  } else if (query instanceof RegExp) {\n    return query.test(data)\n  } else if (isComparable(query)) {\n    return data.valueOf() === query.valueOf()\n  } else if (isNullable(query)) {\n    return isNullable(data)\n  }\n\n  for (const key in query) {\n    if (key in queryOperators) {\n      if (!queryOperators[key](query[key], data)) return false\n    }\n  }\n\n  return true\n}\n\nexport function executeQuery(data: any, query: Query.Expr, ref: string): boolean {\n  const entries: [string, any][] = Object.entries(query)\n  return entries.every(([key, value]) => {\n    // execute logical query\n    if (key === '$and') {\n      return (value as Query.Expr[]).reduce((prev, query) => prev && executeQuery(data, query, ref), true)\n    } else if (key === '$or') {\n      return (value as Query.Expr[]).reduce((prev, query) => prev || executeQuery(data, query, ref), false)\n    } else if (key === '$not') {\n      return !executeQuery(data, value, ref)\n    } else if (key === '$expr') {\n      return executeEval({ [ref]: data, _: data }, value)\n    }\n\n    // execute field query\n    try {\n      return executeFieldQuery(value, data[key])\n    } catch {\n      return false\n    }\n  })\n}\n"],
  "mappings": "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",
  "names": ["import_cosmokit", "import_cosmokit", "key", "Field", "field", "import_cosmokit", "import_cosmokit", "query"]
}
