var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/mysql/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_mysql = require("@vlasky/mysql");
var import_cosmokit = require("cosmokit");
var import_core = require("@minatojs/core");
var import_sql_utils = require("@minatojs/sql-utils");
var import_reggol = __toESM(require("reggol"));
var logger = new import_reggol.default("mysql");
var DEFAULT_DATE = new Date("1970-01-01");
function getIntegerType(length = 11) {
  if (length <= 4)
    return "tinyint";
  if (length <= 6)
    return "smallint";
  if (length <= 9)
    return "mediumint";
  if (length <= 11)
    return "int";
  return "bigint";
}
__name(getIntegerType, "getIntegerType");
function getTypeDefinition({ type, length, precision, scale }) {
  switch (type) {
    case "float":
    case "double":
    case "date":
    case "time":
      return type;
    case "timestamp":
      return "datetime(3)";
    case "boolean":
      return "bit";
    case "integer":
      return getIntegerType(length);
    case "unsigned":
      return `${getIntegerType(length)} unsigned`;
    case "decimal":
      return `decimal(${precision}, ${scale}) unsigned`;
    case "char":
      return `char(${length || 255})`;
    case "string":
      return `varchar(${length || 255})`;
    case "text":
      return `text(${length || 65535})`;
    case "list":
      return `text(${length || 65535})`;
    case "json":
      return `text(${length || 65535})`;
  }
}
__name(getTypeDefinition, "getTypeDefinition");
function backtick(str) {
  return "`" + str + "`";
}
__name(backtick, "backtick");
function createIndex(keys) {
  return (0, import_cosmokit.makeArray)(keys).map(backtick).join(", ");
}
__name(createIndex, "createIndex");
var MySQLBuilder = class extends import_sql_utils.Builder {
  constructor(models) {
    super();
    this.models = models;
  }
  format(sql, values, stringifyObjects, timeZone) {
    return (0, import_mysql.format)(sql, values, stringifyObjects, timeZone);
  }
  escapeId(value, forbidQualified) {
    return (0, import_mysql.escapeId)(value, forbidQualified);
  }
  escape(value, table, field) {
    return (0, import_mysql.escape)(this.stringify(value, table, field));
  }
  stringify(value, table, field) {
    var _a;
    const meta = (_a = this.models[table]) == null ? void 0 : _a.fields[field];
    if ((meta == null ? void 0 : meta.type) === "json") {
      return JSON.stringify(value);
    } else if ((meta == null ? void 0 : meta.type) === "list") {
      return value.join(",");
    } else if (import_core.Field.date.includes(meta == null ? void 0 : meta.type)) {
      return import_cosmokit.Time.template("yyyy-MM-dd hh:mm:ss", value);
    }
    return value;
  }
};
__name(MySQLBuilder, "MySQLBuilder");
var MySQLDriver = class extends import_core.Driver {
  constructor(database, config) {
    super(database);
    this._queryTasks = [];
    this._joinKeys = (keys) => {
      return keys ? keys.map((key) => key.includes("`") ? key : `\`${key}\``).join(",") : "*";
    };
    this._formatValues = (table, data, keys) => {
      return keys.map((key) => this.sql.stringify(data[key], table, key));
    };
    this.config = {
      host: "localhost",
      port: 3306,
      charset: "utf8mb4_general_ci",
      multipleStatements: true,
      typeCast: (field, next) => {
        var _a, _b;
        const { orgName, orgTable } = field.packet;
        const meta = (_a = this.database.tables[orgTable]) == null ? void 0 : _a.fields[orgName];
        if (import_core.Field.string.includes(meta == null ? void 0 : meta.type)) {
          return field.string();
        } else if ((meta == null ? void 0 : meta.type) === "json") {
          const source = field.string();
          return source ? JSON.parse(source) : meta.initial;
        } else if ((meta == null ? void 0 : meta.type) === "list") {
          const source = field.string();
          return source ? source.split(",") : [];
        } else if ((meta == null ? void 0 : meta.type) === "time") {
          const source = field.string();
          if (!source)
            return meta.initial;
          const time = new Date(DEFAULT_DATE);
          const [h, m, s] = source.split(":");
          time.setHours(parseInt(h));
          time.setMinutes(parseInt(m));
          time.setSeconds(parseInt(s));
          return time;
        }
        if (field.type === "BIT") {
          return Boolean((_b = field.buffer()) == null ? void 0 : _b.readUInt8(0));
        } else {
          return next();
        }
      },
      ...config
    };
    this.sql = new MySQLBuilder(database.tables);
  }
  async start() {
    this.pool = (0, import_mysql.createPool)(this.config);
  }
  async stop() {
    this.pool.end();
  }
  _getColDefs(name, columns, indexes) {
    const table = this.model(name);
    const { primary, foreign, autoInc } = table;
    const fields = { ...table.fields };
    const unique = [...table.unique];
    const create = [];
    const update = [];
    for (const key in fields) {
      let shouldUpdate = false;
      const legacy = columns.find((info) => info.COLUMN_NAME === key);
      const { initial, nullable = true } = fields[key];
      let def = backtick(key);
      if (key === primary && autoInc) {
        def += " int unsigned not null auto_increment";
      } else {
        const typedef = getTypeDefinition(fields[key]);
        def += " " + typedef;
        if ((0, import_cosmokit.makeArray)(primary).includes(key)) {
          def += " not null";
        } else {
          def += (nullable ? " " : " not ") + "null";
        }
        if (initial && !typedef.startsWith("text")) {
          def += " default " + this.sql.escape(initial, name, key);
        }
      }
      if (!legacy) {
        create.push(def);
      } else if (shouldUpdate) {
        update.push(def);
      }
    }
    if (!columns.length) {
      create.push(`primary key (${createIndex(primary)})`);
      for (const key in foreign) {
        const [table2, key2] = foreign[key];
        create.push(`foreign key (${backtick(key)}) references ${(0, import_mysql.escapeId)(table2)} (${backtick(key2)})`);
      }
    }
    for (const key of unique) {
      const name2 = (0, import_cosmokit.makeArray)(key).join("_");
      const legacy = indexes.find((info) => info.INDEX_NAME === name2);
      if (!legacy)
        create.push(`unique index (${createIndex(key)})`);
    }
    return [create, update];
  }
  async prepare(name) {
    const [columns, indexes] = await Promise.all([
      this.queue(`
        SELECT COLUMN_NAME, IS_NULLABLE, DATA_TYPE
        FROM information_schema.columns
        WHERE TABLE_SCHEMA = ? && TABLE_NAME = ?
      `, [this.config.database, name]),
      this.queue(`
        SELECT COLUMN_NAME, INDEX_NAME
        FROM information_schema.statistics
        WHERE TABLE_SCHEMA = ? && TABLE_NAME = ?
      `, [this.config.database, name])
    ]);
    const [create, update] = this._getColDefs(name, columns, indexes);
    if (!columns.length) {
      logger.info("auto creating table %c", name);
      return this.queue(`CREATE TABLE ?? (${create.join(",")}) COLLATE = ?`, [name, this.config.charset]);
    }
    const operations = [
      ...create.map((def) => "ADD " + def),
      ...update.map((def) => "MODIFY " + def)
    ];
    if (operations.length) {
      logger.info("auto updating table %c", name);
      await this.queue(`ALTER TABLE ?? ${operations.join(",")}`, [name]);
    }
  }
  _inferFields(table, keys) {
    if (!keys)
      return;
    return keys;
  }
  query(sql, values) {
    const error = new Error();
    return new Promise((resolve, reject) => {
      sql = (0, import_mysql.format)(sql, values);
      logger.debug(sql);
      this.pool.query(sql, (err, results) => {
        if (!err)
          return resolve(results);
        logger.warn(sql);
        if (err["code"] === "ER_DUP_ENTRY") {
          err = new import_core.RuntimeError("duplicate-entry", err.message);
        }
        err.stack = err.message + error.stack.slice(5);
        reject(err);
      });
    });
  }
  queue(sql, values) {
    if (!this.config.multipleStatements) {
      return this.query(sql, values);
    }
    sql = (0, import_mysql.format)(sql, values);
    return new Promise((resolve, reject) => {
      this._queryTasks.push({ sql, resolve, reject });
      process.nextTick(() => this._flushTasks());
    });
  }
  async _flushTasks() {
    const tasks = this._queryTasks;
    if (!tasks.length)
      return;
    this._queryTasks = [];
    try {
      let results = await this.query(tasks.map((task) => task.sql).join("; "));
      if (tasks.length === 1)
        results = [results];
      tasks.forEach((task, index) => {
        task.resolve(results[index]);
      });
    } catch (error) {
      tasks.forEach((task) => task.reject(error));
    }
  }
  _select(table, fields, conditional, values = []) {
    logger.debug(`[select] ${table}: ${fields ? fields.join(", ") : "*"}`);
    const sql = "SELECT " + this._joinKeys(fields) + (table.includes(".") ? `FROM ${table}` : " FROM `" + table + "`") + (conditional ? " WHERE " + conditional : "");
    return this.queue(sql, values);
  }
  async drop() {
    const data = await this._select("information_schema.tables", ["TABLE_NAME"], "TABLE_SCHEMA = ?", [this.config.database]);
    if (!data.length)
      return;
    await this.query(data.map(({ TABLE_NAME }) => `DROP TABLE ${this.sql.escapeId(TABLE_NAME)}`).join("; "));
  }
  async stats() {
    const data = await this._select("information_schema.tables", ["TABLE_NAME", "TABLE_ROWS", "DATA_LENGTH"], "TABLE_SCHEMA = ?", [this.config.database]);
    const stats = { size: 0 };
    stats.tables = Object.fromEntries(data.map(({ TABLE_NAME: name, TABLE_ROWS: count, DATA_LENGTH: size }) => {
      stats.size += size;
      return [name, { count, size }];
    }));
    return stats;
  }
  async get(sel, modifier) {
    const { table, fields, query, model } = sel;
    const filter = this.sql.parseQuery(query);
    if (filter === "0")
      return [];
    const { limit, offset, sort } = modifier;
    const keys = this._joinKeys(this._inferFields(table, fields ? Object.keys(fields) : null));
    let sql = `SELECT ${keys} FROM ${table} _${table} WHERE ${filter}`;
    if (sort.length)
      sql += " ORDER BY " + sort.map(([key, order]) => `${backtick(key["$"][1])} ${order}`).join(", ");
    if (limit < Infinity)
      sql += " LIMIT " + limit;
    if (offset > 0)
      sql += " OFFSET " + offset;
    return this.queue(sql).then((data) => {
      return data.map((row) => model.parse(row));
    });
  }
  async eval(sel, expr) {
    const { table, query } = sel;
    const filter = this.sql.parseQuery(query);
    const output = this.sql.parseEval(expr);
    const [data] = await this.queue(`SELECT ${output} AS value FROM ${table} WHERE ${filter}`);
    return data.value;
  }
  toUpdateExpr(table, item, field, upsert) {
    const escaped = backtick(field);
    if (field in item) {
      if ((0, import_core.isEvalExpr)(item[field]) || !upsert) {
        return this.sql.parseEval(item[field], table, field);
      } else {
        return `VALUES(${escaped})`;
      }
    }
    const valueInit = `ifnull(${escaped}, '{}')`;
    let value = valueInit;
    for (const key in item) {
      if (!key.startsWith(field + "."))
        continue;
      const rest = key.slice(field.length + 1).split(".");
      value = `json_set(${value}, '$${rest.map((key2) => `."${key2}"`).join("")}', ${this.sql.parseEval(item[key])})`;
    }
    if (value === valueInit) {
      return escaped;
    } else {
      return value;
    }
  }
  async set(sel, data) {
    const { model, query, table } = sel;
    const filter = this.sql.parseQuery(query);
    const { fields } = model;
    if (filter === "0")
      return;
    const updateFields = [...new Set(Object.keys(data).map((key) => {
      return Object.keys(fields).find((field) => field === key || key.startsWith(field + "."));
    }))];
    const update = updateFields.map((field) => {
      const escaped = backtick(field);
      return `${escaped} = ${this.toUpdateExpr(table, data, field, false)}`;
    }).join(", ");
    await this.query(`UPDATE ${table} SET ${update} WHERE ${filter}`);
  }
  async remove(sel) {
    const { query, table } = sel;
    const filter = this.sql.parseQuery(query);
    if (filter === "0")
      return;
    await this.query("DELETE FROM ?? WHERE " + filter, [table]);
  }
  async create(sel, data) {
    const { table, model } = sel;
    const formatted = model.format(data);
    const { autoInc, primary } = model;
    const keys = Object.keys(formatted);
    const header = await this.query(
      `INSERT INTO ?? (${this._joinKeys(keys)}) VALUES (${keys.map(() => "?").join(", ")})`,
      [table, ...this._formatValues(table, formatted, keys)]
    );
    if (!autoInc)
      return data;
    return { ...data, [primary]: header.insertId };
  }
  async upsert(sel, data, keys) {
    if (!data.length)
      return;
    const { model, table, ref } = sel;
    const merged = {};
    const insertion = data.map((item) => {
      Object.assign(merged, item);
      return model.format((0, import_core.executeUpdate)(model.create(), item, ref));
    });
    const initFields = Object.keys(model.fields);
    const dataFields = [...new Set(Object.keys(merged).map((key) => {
      return initFields.find((field) => field === key || key.startsWith(field + "."));
    }))];
    const updateFields = (0, import_cosmokit.difference)(dataFields, keys);
    const createFilter = /* @__PURE__ */ __name((item) => this.sql.parseQuery((0, import_cosmokit.pick)(item, keys)), "createFilter");
    const createMultiFilter = /* @__PURE__ */ __name((items) => {
      if (items.length === 1) {
        return createFilter(items[0]);
      } else if (keys.length === 1) {
        const key = keys[0];
        return this.sql.parseQuery({ [key]: items.map((item) => item[key]) });
      } else {
        return items.map(createFilter).join(" OR ");
      }
    }, "createMultiFilter");
    const update = updateFields.map((field) => {
      const escaped = backtick(field);
      const branches = {};
      data.forEach((item) => {
        var _a, _b;
        ((_b = branches[_a = this.toUpdateExpr(table, item, field, true)]) != null ? _b : branches[_a] = []).push(item);
      });
      const entries = Object.entries(branches).map(([expr, items]) => [createMultiFilter(items), expr]).sort(([a], [b]) => a.length - b.length).reverse();
      let value = entries[0][1];
      for (let index = 1; index < entries.length; index++) {
        value = `if(${entries[index][0]}, ${entries[index][1]}, ${value})`;
      }
      return `${escaped} = ${value}`;
    }).join(", ");
    const placeholder = `(${initFields.map(() => "?").join(", ")})`;
    await this.query(
      `INSERT INTO ${this.sql.escapeId(table)} (${this._joinKeys(initFields)}) VALUES ${data.map(() => placeholder).join(", ")}
      ON DUPLICATE KEY UPDATE ${update}`,
      [].concat(...insertion.map((item) => this._formatValues(table, item, initFields)))
    );
  }
};
__name(MySQLDriver, "MySQLDriver");
var src_default = MySQLDriver;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map
