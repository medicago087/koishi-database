"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// minato/packages/mysql/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_mysql = require("@vlasky/mysql");
var import_cosmokit = require("cosmokit");
var import_core = require("@minatojs/core");
var import_sql_utils = require("@minatojs/sql-utils");
var import_reggol = __toESM(require("reggol"));
var logger = new import_reggol.default("mysql");
var DEFAULT_DATE = new Date("1970-01-01");
function getIntegerType(length = 11) {
  if (length <= 4)
    return "tinyint";
  if (length <= 6)
    return "smallint";
  if (length <= 9)
    return "mediumint";
  if (length <= 11)
    return "int";
  return "bigint";
}
__name(getIntegerType, "getIntegerType");
function getTypeDef({ type, length, precision, scale }) {
  switch (type) {
    case "float":
    case "double":
    case "date":
    case "time":
      return type;
    case "timestamp":
      return "datetime(3)";
    case "boolean":
      return "bit";
    case "integer":
      return getIntegerType(length);
    case "unsigned":
      return `${getIntegerType(length)} unsigned`;
    case "decimal":
      return `decimal(${precision}, ${scale}) unsigned`;
    case "char":
      return `char(${length || 255})`;
    case "string":
      return `varchar(${length || 255})`;
    case "text":
      return `text(${length || 65535})`;
    case "list":
      return `text(${length || 65535})`;
    case "json":
      return `text(${length || 65535})`;
    default:
      throw new Error(`unsupported type: ${type}`);
  }
}
__name(getTypeDef, "getTypeDef");
function isDefUpdated(field, column, def) {
  const typename = def.split(/[ (]/)[0];
  if (typename === "text")
    return !column.DATA_TYPE.endsWith("text");
  if (typename !== column.DATA_TYPE)
    return true;
  switch (field.type) {
    case "integer":
    case "unsigned":
    case "char":
    case "string":
    case "text":
    case "list":
    case "json":
      return !!field.length && !!column.CHARACTER_MAXIMUM_LENGTH && column.CHARACTER_MAXIMUM_LENGTH !== field.length;
    case "decimal":
      return column.NUMERIC_PRECISION !== field.precision || column.NUMERIC_SCALE !== field.scale;
    default:
      return false;
  }
}
__name(isDefUpdated, "isDefUpdated");
function createIndex(keys) {
  return (0, import_cosmokit.makeArray)(keys).map(import_sql_utils.escapeId).join(", ");
}
__name(createIndex, "createIndex");
var MySQLBuilder = class extends import_sql_utils.Builder {
  constructor(tables) {
    super(tables);
    this.define({
      types: ["list"],
      dump: (value) => value.join(","),
      load: (value) => value ? value.split(",") : []
    });
  }
  escape(value, field) {
    if (value instanceof Date) {
      value = import_cosmokit.Time.template("yyyy-MM-dd hh:mm:ss", value);
    }
    return super.escape(value, field);
  }
};
__name(MySQLBuilder, "MySQLBuilder");
var MySQLDriver = class extends import_core.Driver {
  constructor(database, config) {
    super(database);
    this._queryTasks = [];
    this._joinKeys = (keys) => {
      return keys ? keys.map((key) => key.includes("`") ? key : `\`${key}\``).join(",") : "*";
    };
    this._formatValues = (table, data, keys) => {
      return keys.map((key) => {
        var _a;
        const field = (_a = this.database.tables[table]) == null ? void 0 : _a.fields[key];
        return this.sql.escape(data[key], field);
      }).join(", ");
    };
    this.config = {
      host: "localhost",
      port: 3306,
      charset: "utf8mb4_general_ci",
      multipleStatements: true,
      typeCast: (field, next) => {
        var _a, _b;
        const { orgName, orgTable } = field.packet;
        const meta = (_a = this.database.tables[orgTable]) == null ? void 0 : _a.fields[orgName];
        if (import_core.Field.string.includes(meta == null ? void 0 : meta.type)) {
          return field.string();
        } else if ((meta == null ? void 0 : meta.type) === "json") {
          const source = field.string();
          return source ? JSON.parse(source) : meta.initial;
        } else if ((meta == null ? void 0 : meta.type) === "time") {
          const source = field.string();
          if (!source)
            return meta.initial;
          const time = new Date(DEFAULT_DATE);
          const [h, m, s] = source.split(":");
          time.setHours(parseInt(h));
          time.setMinutes(parseInt(m));
          time.setSeconds(parseInt(s));
          return time;
        }
        if (field.type === "BIT") {
          return Boolean((_b = field.buffer()) == null ? void 0 : _b.readUInt8(0));
        } else {
          return next();
        }
      },
      ...config
    };
    this.sql = new MySQLBuilder(database.tables);
  }
  async start() {
    this.pool = (0, import_mysql.createPool)(this.config);
  }
  async stop() {
    this.pool.end();
  }
  async prepare(name) {
    const [columns, indexes] = await Promise.all([
      this.queue([
        `SELECT *`,
        `FROM information_schema.columns`,
        `WHERE TABLE_SCHEMA = ? && TABLE_NAME = ?`
      ].join(" "), [this.config.database, name]),
      this.queue([
        `SELECT *`,
        `FROM information_schema.statistics`,
        `WHERE TABLE_SCHEMA = ? && TABLE_NAME = ?`
      ].join(" "), [this.config.database, name])
    ]);
    const table = this.model(name);
    const { primary, foreign, autoInc } = table;
    const fields = { ...table.fields };
    const unique = [...table.unique];
    const create = [];
    const update = [];
    for (const key in fields) {
      const { initial, nullable = true } = fields[key];
      const legacy = [key, ...fields[key].legacy || []];
      const column = columns.find((info) => legacy.includes(info.COLUMN_NAME));
      let shouldUpdate = (column == null ? void 0 : column.COLUMN_NAME) !== key;
      let def = (0, import_sql_utils.escapeId)(key);
      if (key === primary && autoInc) {
        def += " int unsigned not null auto_increment";
      } else {
        const typedef = getTypeDef(fields[key]);
        if (column && !shouldUpdate) {
          shouldUpdate = isDefUpdated(fields[key], column, typedef);
        }
        def += " " + typedef;
        if ((0, import_cosmokit.makeArray)(primary).includes(key)) {
          def += " not null";
        } else {
          def += (nullable ? " " : " not ") + "null";
        }
        if (initial && !typedef.startsWith("text")) {
          def += " default " + this.sql.escape(initial, fields[key]);
        }
      }
      if (!column) {
        create.push(def);
      } else if (shouldUpdate) {
        update.push(`CHANGE ${(0, import_sql_utils.escapeId)(column.COLUMN_NAME)} ${def}`);
      }
    }
    if (!columns.length) {
      create.push(`PRIMARY KEY (${createIndex(primary)})`);
      for (const key in foreign) {
        const [table2, key2] = foreign[key];
        create.push(`FOREIGN KEY (${(0, import_sql_utils.escapeId)(key)}) REFERENCES ${(0, import_sql_utils.escapeId)(table2)} (${(0, import_sql_utils.escapeId)(key2)})`);
      }
    }
    for (const key of unique) {
      let shouldUpdate = false;
      const oldKeys = (0, import_cosmokit.makeArray)(key).map((key2) => {
        const legacy = [key2, ...fields[key2].legacy || []];
        const column = columns.find((info) => legacy.includes(info.COLUMN_NAME));
        if ((column == null ? void 0 : column.COLUMN_NAME) !== key2)
          shouldUpdate = true;
        return column == null ? void 0 : column.COLUMN_NAME;
      });
      const name2 = oldKeys.join("_");
      const index = indexes.find((info) => info.INDEX_NAME === name2);
      if (!index) {
        create.push(`UNIQUE INDEX (${createIndex(key)})`);
      } else if (shouldUpdate) {
        create.push(`UNIQUE INDEX (${createIndex(key)})`);
        update.push(`DROP INDEX ${(0, import_sql_utils.escapeId)(name2)}`);
      }
    }
    if (!columns.length) {
      logger.info("auto creating table %c", name);
      return this.queue(`CREATE TABLE ?? (${create.join(", ")}) COLLATE = ?`, [name, this.config.charset]);
    }
    const operations = [
      ...create.map((def) => "ADD " + def),
      ...update
    ];
    if (operations.length) {
      logger.info("auto updating table %c", name);
      console.log(operations);
      await this.queue(`ALTER TABLE ?? ${operations.join(", ")}`, [name]);
    }
  }
  query(sql) {
    const error = new Error();
    return new Promise((resolve, reject) => {
      this.pool.query(sql, (err, results) => {
        if (!err)
          return resolve(results);
        logger.warn(sql);
        if (err["code"] === "ER_DUP_ENTRY") {
          err = new import_core.RuntimeError("duplicate-entry", err.message);
        }
        err.stack = err.message + error.stack.slice(5);
        reject(err);
      });
    });
  }
  queue(sql, values) {
    sql = (0, import_mysql.format)(sql, values);
    logger.debug("> %s", sql);
    if (!this.config.multipleStatements) {
      return this.query(sql);
    }
    return new Promise((resolve, reject) => {
      this._queryTasks.push({ sql, resolve, reject });
      process.nextTick(() => this._flushTasks());
    });
  }
  async _flushTasks() {
    const tasks = this._queryTasks;
    if (!tasks.length)
      return;
    this._queryTasks = [];
    try {
      let results = await this.query(tasks.map((task) => task.sql).join("; "));
      if (tasks.length === 1)
        results = [results];
      tasks.forEach((task, index) => {
        task.resolve(results[index]);
      });
    } catch (error) {
      tasks.forEach((task) => task.reject(error));
    }
  }
  _select(table, fields, conditional, values = []) {
    let sql = `SELECT ${this._joinKeys(fields)} FROM ${table}`;
    if (conditional)
      sql += ` WHERE ${conditional}`;
    return this.queue(sql, values);
  }
  async drop() {
    const data = await this._select("information_schema.tables", ["TABLE_NAME"], "TABLE_SCHEMA = ?", [this.config.database]);
    if (!data.length)
      return;
    await this.query(data.map(({ TABLE_NAME }) => `DROP TABLE ${(0, import_sql_utils.escapeId)(TABLE_NAME)}`).join("; "));
  }
  async stats() {
    const data = await this._select("information_schema.tables", ["TABLE_NAME", "TABLE_ROWS", "DATA_LENGTH"], "TABLE_SCHEMA = ?", [this.config.database]);
    const stats = { size: 0 };
    stats.tables = Object.fromEntries(data.map(({ TABLE_NAME: name, TABLE_ROWS: count, DATA_LENGTH: size }) => {
      stats.size += size;
      return [name, { count, size }];
    }));
    return stats;
  }
  async get(sel) {
    const { model, tables } = sel;
    const builder = new MySQLBuilder(tables);
    const sql = builder.get(sel);
    if (!sql)
      return [];
    return this.queue(sql).then((data) => {
      return data.map((row) => this.sql.load(model, row));
    });
  }
  async eval(sel, expr) {
    const output = this.sql.parseEval(expr);
    let sql = this.sql.get(sel.table);
    const prefix = `SELECT ${output} AS value `;
    if (sql.startsWith("SELECT * ")) {
      sql = prefix + sql.slice(9);
    } else {
      sql = `${prefix}FROM (${sql}) ${sql.ref}`;
    }
    const [data] = await this.queue(sql);
    return data.value;
  }
  toUpdateExpr(item, key, field, upsert) {
    const escaped = (0, import_sql_utils.escapeId)(key);
    if (key in item) {
      if (!(0, import_core.isEvalExpr)(item[key]) && upsert) {
        return `VALUES(${escaped})`;
      } else if ((0, import_core.isEvalExpr)(item[key])) {
        return this.sql.parseEval(item[key]);
      } else {
        return this.sql.escape(item[key], field);
      }
    }
    const valueInit = `ifnull(${escaped}, '{}')`;
    let value = valueInit;
    for (const prop in item) {
      if (!prop.startsWith(key + "."))
        continue;
      const rest = prop.slice(key.length + 1).split(".");
      value = `json_set(${value}, '$${rest.map((key2) => `."${key2}"`).join("")}', ${this.sql.parseEval(item[prop])})`;
    }
    if (value === valueInit) {
      return escaped;
    } else {
      return value;
    }
  }
  async set(sel, data) {
    const { model, query, table } = sel;
    const filter = this.sql.parseQuery(query);
    const { fields } = model;
    if (filter === "0")
      return;
    const updateFields = [...new Set(Object.keys(data).map((key) => {
      return Object.keys(fields).find((field) => field === key || key.startsWith(field + "."));
    }))];
    const update = updateFields.map((field) => {
      const escaped = (0, import_sql_utils.escapeId)(field);
      return `${escaped} = ${this.toUpdateExpr(data, field, fields[field], false)}`;
    }).join(", ");
    await this.query(`UPDATE ${table} SET ${update} WHERE ${filter}`);
  }
  async remove(sel) {
    const { query, table } = sel;
    const filter = this.sql.parseQuery(query);
    if (filter === "0")
      return;
    await this.query(`DELETE FROM ${(0, import_sql_utils.escapeId)(table)} WHERE ` + filter);
  }
  async create(sel, data) {
    const { table, model } = sel;
    const { autoInc, primary } = model;
    const formatted = this.sql.dump(model, data);
    const keys = Object.keys(formatted);
    const header = await this.query([
      `INSERT INTO ${(0, import_sql_utils.escapeId)(table)} (${keys.map(import_sql_utils.escapeId).join(", ")})`,
      `VALUES (${keys.map((key) => this.sql.escape(formatted[key])).join(", ")})`
    ].join(" "));
    if (!autoInc)
      return data;
    return { ...data, [primary]: header.insertId };
  }
  async upsert(sel, data, keys) {
    if (!data.length)
      return;
    const { model, table, ref } = sel;
    const merged = {};
    const insertion = data.map((item) => {
      Object.assign(merged, item);
      return model.format((0, import_core.executeUpdate)(model.create(), item, ref));
    });
    const initFields = Object.keys(model.fields);
    const dataFields = [...new Set(Object.keys(merged).map((key) => {
      return initFields.find((field) => field === key || key.startsWith(field + "."));
    }))];
    const updateFields = (0, import_cosmokit.difference)(dataFields, keys);
    const createFilter = /* @__PURE__ */ __name((item) => this.sql.parseQuery((0, import_cosmokit.pick)(item, keys)), "createFilter");
    const createMultiFilter = /* @__PURE__ */ __name((items) => {
      if (items.length === 1) {
        return createFilter(items[0]);
      } else if (keys.length === 1) {
        const key = keys[0];
        return this.sql.parseQuery({ [key]: items.map((item) => item[key]) });
      } else {
        return items.map(createFilter).join(" OR ");
      }
    }, "createMultiFilter");
    const update = updateFields.map((field) => {
      const escaped = (0, import_sql_utils.escapeId)(field);
      const branches = {};
      data.forEach((item) => {
        var _a, _b;
        ((_b = branches[_a = this.toUpdateExpr(item, field, model.fields[field], true)]) != null ? _b : branches[_a] = []).push(item);
      });
      const entries = Object.entries(branches).map(([expr, items]) => [createMultiFilter(items), expr]).sort(([a], [b]) => a.length - b.length).reverse();
      let value = entries[0][1];
      for (let index = 1; index < entries.length; index++) {
        value = `if(${entries[index][0]}, ${entries[index][1]}, ${value})`;
      }
      return `${escaped} = ${value}`;
    }).join(", ");
    await this.query([
      `INSERT INTO ${(0, import_sql_utils.escapeId)(table)} (${initFields.map(import_sql_utils.escapeId).join(", ")})`,
      `VALUES (${insertion.map((item) => this._formatValues(table, item, initFields)).join("), (")})`,
      `ON DUPLICATE KEY UPDATE ${update}`
    ].join(" "));
  }
};
__name(MySQLDriver, "MySQLDriver");
var src_default = MySQLDriver;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map
