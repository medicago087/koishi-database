"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// minato/packages/mongo/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_mongodb = require("mongodb");
var import_cosmokit2 = require("cosmokit");
var import_core = require("@minatojs/core");
var import_url = require("url");

// minato/packages/mongo/src/utils.ts
var import_cosmokit = require("cosmokit");
function createFieldFilter(query, key) {
  const filters = [];
  const result = {};
  const child = transformFieldQuery(query, key, filters);
  if (child === false)
    return false;
  if (child !== true)
    result[key] = child;
  if (filters.length)
    result.$and = filters;
  if (Object.keys(result).length)
    return result;
  return true;
}
__name(createFieldFilter, "createFieldFilter");
function transformFieldQuery(query, key, filters) {
  if (typeof query === "string" || typeof query === "number" || query instanceof Date) {
    return { $eq: query };
  } else if (Array.isArray(query)) {
    if (!query.length)
      return false;
    return { $in: query };
  } else if (query instanceof RegExp) {
    return { $regex: query };
  } else if ((0, import_cosmokit.isNullable)(query)) {
    return { $exists: false };
  }
  const result = {};
  for (const prop in query) {
    if (prop === "$and") {
      for (const item of query[prop]) {
        const child = createFieldFilter(item, key);
        if (child === false)
          return false;
        if (child !== true)
          filters.push(child);
      }
    } else if (prop === "$or") {
      const $or = [];
      if (!query[prop].length)
        return false;
      const always = query[prop].some((item) => {
        const child = createFieldFilter(item, key);
        if (typeof child === "boolean")
          return child;
        $or.push(child);
      });
      if (!always)
        filters.push({ $or });
    } else if (prop === "$not") {
      const child = createFieldFilter(query[prop], key);
      if (child === true)
        return false;
      if (child !== false)
        filters.push({ $nor: [child] });
    } else if (prop === "$el") {
      const child = transformFieldQuery(query[prop], key, filters);
      if (child === false)
        return false;
      if (child !== true)
        result.$elemMatch = child;
    } else if (prop === "$regexFor") {
      filters.push({
        $expr: {
          $function: {
            body: function(data, value) {
              return new RegExp(data, "i").test(value);
            }.toString(),
            args: ["$" + key, query.$regexFor],
            lang: "js"
          }
        }
      });
    } else {
      result[prop] = query[prop];
    }
  }
  if (!Object.keys(result).length)
    return true;
  return result;
}
__name(transformFieldQuery, "transformFieldQuery");
var aggrKeys = ["$sum", "$avg", "$min", "$max", "$count"];
var Transformer = class {
  constructor(virtualKey) {
    this.virtualKey = virtualKey;
    this.counter = 0;
  }
  createKey() {
    return "_temp_" + ++this.counter;
  }
  getActualKey(key) {
    return key === this.virtualKey ? "_id" : key;
  }
  transformEvalExpr(expr, group) {
    if (expr.$) {
      if (typeof expr.$ === "string") {
        return "$" + this.getActualKey(expr.$);
      } else {
        return "$" + this.getActualKey(expr.$[1]);
      }
    }
    if (expr.$if) {
      return { $cond: expr.$if.map((val) => this.eval(val, group)) };
    }
    return (0, import_cosmokit.valueMap)(expr, (value) => {
      if (Array.isArray(value)) {
        return value.map((val) => this.eval(val, group));
      } else {
        return this.eval(value, group);
      }
    });
  }
  transformAggr(expr) {
    if (typeof expr === "number" || typeof expr === "boolean") {
      return expr;
    }
    if (typeof expr === "string") {
      return "$" + expr;
    }
    return this.transformEvalExpr(expr);
  }
  eval(expr, group) {
    if (typeof expr === "number" || typeof expr === "string" || typeof expr === "boolean") {
      return expr;
    }
    for (const type of aggrKeys) {
      if (!expr[type])
        continue;
      const key = this.createKey();
      const value = this.transformAggr(expr[type]);
      if (type !== "$count") {
        group[key] = { [type]: value };
        return "$" + key;
      } else {
        group[key] = { $addToSet: value };
        return { $size: "$" + key };
      }
    }
    return this.transformEvalExpr(expr, group);
  }
  query(query) {
    const filter = {};
    const additional = [];
    for (const key in query) {
      const value = query[key];
      if (key === "$and" || key === "$or") {
        if (value.length) {
          filter[key] = value.map((query2) => this.query(query2));
        } else if (key === "$or") {
          return;
        }
      } else if (key === "$not") {
        const query2 = this.query(value);
        if (query2)
          filter.$nor = [query2];
      } else if (key === "$expr") {
        additional.push({ $expr: this.eval(value) });
      } else {
        const actualKey = this.getActualKey(key);
        const query2 = transformFieldQuery(value, actualKey, additional);
        if (query2 === false)
          return;
        if (query2 !== true)
          filter[actualKey] = query2;
      }
    }
    if (additional.length) {
      (filter.$and || (filter.$and = [])).push(...additional);
    }
    return filter;
  }
  modifier(stages, sel) {
    const { args, model } = sel;
    const { fields, offset, limit, sort, group, having } = args[0];
    const $set = {};
    const $sort = {};
    const $unset = [];
    for (const [expr, dir] of sort) {
      const value = this.eval(expr);
      if (typeof value === "string") {
        $sort[value.slice(1)] = dir === "desc" ? -1 : 1;
      } else {
        const key = this.createKey();
        $set[key] = value;
        $sort[key] = dir === "desc" ? -1 : 1;
        $unset.push(key);
      }
    }
    if ($unset.length)
      stages.push({ $set });
    if (Object.keys($sort).length)
      stages.push({ $sort });
    if ($unset.length)
      stages.push({ $unset });
    if (limit < Infinity) {
      stages.push({ $limit: offset + limit });
    }
    if (offset) {
      stages.push({ $skip: offset });
    }
    if (group.length) {
      const $group = { _id: {} };
      const $project = { _id: 0 };
      stages.push({ $group });
      for (const key in fields) {
        if (group.includes(key)) {
          $group._id[key] = this.eval(fields[key]);
          $project[key] = "$_id." + key;
        } else {
          $project[key] = this.eval(fields[key], $group);
        }
      }
      if (having["$and"].length) {
        const $expr = this.eval(having, $group);
        stages.push({ $match: { $expr } });
      }
      stages.push({ $project });
    } else if (fields) {
      const $project = (0, import_cosmokit.valueMap)(fields, (expr) => this.eval(expr));
      $project._id = 0;
      stages.push({ $project });
    } else {
      const $project = { _id: 0 };
      for (const key in model.fields) {
        $project[key] = key === this.virtualKey ? "$_id" : 1;
      }
      stages.push({ $project });
    }
  }
};
__name(Transformer, "Transformer");

// minato/packages/mongo/src/index.ts
var import_reggol = __toESM(require("reggol"));
var logger = new import_reggol.default("mongo");
var MongoDriver = class extends import_core.Driver {
  constructor(database, config) {
    super(database);
    this.config = config;
    this.mongo = this;
    this._evalTasks = [];
    this._createTasks = {};
  }
  connectionStringFromConfig() {
    const {
      authDatabase,
      connectOptions,
      host = "localhost",
      database,
      password,
      protocol = "mongodb",
      port = protocol.includes("srv") ? null : 27017,
      username
    } = this.config;
    let mongourl = `${protocol}://`;
    if (username)
      mongourl += `${encodeURIComponent(username)}${password ? `:${encodeURIComponent(password)}` : ""}@`;
    mongourl += `${host}${port ? `:${port}` : ""}/${authDatabase || database}`;
    if (connectOptions) {
      const params = new import_url.URLSearchParams(connectOptions);
      mongourl += `?${params}`;
    }
    return mongourl;
  }
  async start() {
    const url = this.config.uri || this.connectionStringFromConfig();
    this.client = await import_mongodb.MongoClient.connect(url);
    this.db = this.client.db(this.config.database);
  }
  stop() {
    return this.client.close();
  }
  async _createIndexes(table) {
    const { fields, primary, unique } = this.model(table);
    const coll = this.db.collection(table);
    const newSpecs = [];
    const oldSpecs = await coll.indexes();
    [primary, ...unique].forEach((keys, index) => {
      if (this.config.optimizeIndex && !index && typeof keys === "string")
        return;
      keys = (0, import_cosmokit2.makeArray)(keys);
      const name = (index ? "unique:" : "primary:") + keys.join("+");
      if (oldSpecs.find((spec) => spec.name === name))
        return;
      newSpecs.push({
        name,
        key: Object.fromEntries(keys.map((key) => [key, 1])),
        unique: true,
        partialFilterExpression: Object.fromEntries(keys.map((key) => [key, {
          $type: [import_mongodb.BSONType.date, import_mongodb.BSONType.int, import_mongodb.BSONType.long, import_mongodb.BSONType.string, import_mongodb.BSONType.objectId]
        }]))
      });
    });
    if (!newSpecs.length)
      return;
    await coll.createIndexes(newSpecs);
  }
  async _createFields(table) {
    const { fields } = this.model(table);
    const coll = this.db.collection(table);
    const bulk = coll.initializeOrderedBulkOp();
    for (const key in fields) {
      const { initial, legacy = [] } = fields[key];
      const filter = { [key]: { $exists: false } };
      for (const oldKey of legacy) {
        bulk.find({ ...filter, [oldKey]: { $exists: true } }).update({ $rename: { [oldKey]: key } });
        filter[oldKey] = { $exists: false };
      }
      bulk.find(filter).update({ $set: { [key]: initial } });
      if (legacy.length) {
        const $unset = Object.fromEntries(legacy.map((key2) => [key2, ""]));
        bulk.find({}).update({ $unset });
      }
    }
    if (bulk.batches.length)
      await bulk.execute();
  }
  async _migratePrimary(table) {
    const { primary, autoInc } = this.model(table);
    if (Array.isArray(primary) || !autoInc)
      return;
    const fields = this.db.collection("_fields");
    const meta = { table, field: primary };
    const found = await fields.findOne(meta);
    if (found)
      return;
    const coll = this.db.collection(table);
    const bulk = coll.initializeOrderedBulkOp();
    await coll.find().forEach((data) => {
      bulk.find({ [primary]: data[primary] }).update({ $set: { [primary]: +data[primary] } });
    });
    if (bulk.batches.length)
      await bulk.execute();
    const [latest] = await coll.find().sort(primary, -1).limit(1).toArray();
    meta.autoInc = latest ? +latest[primary] : 0;
    await fields.insertOne(meta);
  }
  async _createInternalTable() {
    return this._internalTableTask || (this._internalTableTask = this.db.createCollection("_fields").catch(import_cosmokit2.noop));
  }
  async prepare(table) {
    await Promise.all([
      this._createInternalTable(),
      this.db.createCollection(table).catch(import_cosmokit2.noop)
    ]);
    await Promise.all([
      this._createIndexes(table),
      this._createFields(table),
      this._migratePrimary(table)
    ]);
  }
  async drop(table) {
    if (table) {
      await this.db.dropCollection(table);
      return;
    }
    await Promise.all([
      "_fields",
      ...Object.keys(this.database.tables)
    ].map((name) => this.db.dropCollection(name)));
  }
  async _collStats() {
    const tables = Object.keys(this.database.tables);
    const entries = await Promise.all(tables.map(async (name) => {
      const coll = this.db.collection(name);
      const { count, size } = await coll.stats();
      return [coll.collectionName, { count, size }];
    }));
    return Object.fromEntries(entries);
  }
  async stats() {
    const [stats, tables] = await Promise.all([
      this.db.stats(),
      this._collStats()
    ]);
    const totalSize = stats.indexSize + stats.storageSize;
    return { size: totalSize, tables };
  }
  getVirtualKey(table) {
    const { primary } = this.model(table);
    if (typeof primary === "string" && this.config.optimizeIndex) {
      return primary;
    }
  }
  patchVirtual(table, row) {
    const { primary } = this.model(table);
    if (typeof primary === "string" && this.config.optimizeIndex) {
      row[primary] = row["_id"];
      delete row["_id"];
    }
    return row;
  }
  unpatchVirtual(table, row) {
    const { primary } = this.model(table);
    if (typeof primary === "string" && this.config.optimizeIndex) {
      row["_id"] = row[primary];
      delete row[primary];
    }
    return row;
  }
  transformQuery(query, table) {
    return new Transformer(this.getVirtualKey(table)).query(query);
  }
  createPipeline(sel) {
    const { table, query } = sel;
    const pipeline = [];
    const result = { pipeline };
    const transformer = new Transformer();
    if (typeof table === "string") {
      result.table = table;
      transformer.virtualKey = this.getVirtualKey(table);
    } else {
      const predecessor = this.createPipeline(table);
      if (!predecessor)
        return;
      result.table = predecessor.table;
      pipeline.unshift(...predecessor.pipeline);
    }
    const filter = transformer.query(query);
    if (!filter)
      return;
    if (Object.keys(filter).length) {
      pipeline.push({ $match: filter });
    }
    if (sel.type === "get") {
      transformer.modifier(pipeline, sel);
    }
    return result;
  }
  async get(sel) {
    const result = this.createPipeline(sel);
    if (!result)
      return [];
    logger.debug("%s %s", result.table, JSON.stringify(result.pipeline));
    return this.db.collection(result.table).aggregate(result.pipeline, { allowDiskUse: true }).toArray();
  }
  async eval(sel, expr) {
    const result = this.createPipeline(sel);
    if (!result)
      return;
    return new Promise((resolve, reject) => {
      this._evalTasks.push({ expr, ...result, resolve, reject });
      process.nextTick(() => this._flushEvalTasks());
    });
  }
  async _flushEvalTasks() {
    const tasks = this._evalTasks;
    if (!tasks.length)
      return;
    this._evalTasks = [];
    const stages = [{ $match: { _id: null } }];
    const transformer = new Transformer();
    for (const task of tasks) {
      const { expr, table, pipeline } = task;
      const $ = transformer.createKey();
      const $group = { _id: null };
      const $project = { _id: 0 };
      pipeline.push({ $group }, { $project });
      task.expr = { $ };
      $project[$] = transformer.eval(expr, $group);
      stages.push({
        $unionWith: { coll: table, pipeline }
      });
    }
    let data;
    try {
      const results = await this.db.collection("_fields").aggregate(stages, { allowDiskUse: true }).toArray();
      data = Object.assign({}, ...results);
    } catch (error) {
      tasks.forEach((task) => task.reject(error));
      return;
    }
    for (const { expr, resolve, reject } of tasks) {
      try {
        resolve((0, import_core.executeEval)({ _: data }, expr));
      } catch (error) {
        reject(error);
      }
    }
  }
  async set(sel, update) {
    const { query, table, ref } = sel;
    const filter = this.transformQuery(query, table);
    if (!filter)
      return;
    const indexFields = (0, import_cosmokit2.makeArray)(sel.model.primary);
    const coll = this.db.collection(table);
    const original = await coll.find(filter).toArray();
    if (!original.length)
      return;
    const updateFields = new Set(Object.keys(update).map((key) => key.split(".", 1)[0]));
    const bulk = coll.initializeUnorderedBulkOp();
    for (const item of original) {
      const row = this.patchVirtual(table, item);
      const query2 = this.transformQuery((0, import_cosmokit2.pick)(row, indexFields), table);
      if (!query2)
        continue;
      bulk.find(query2).updateOne({
        $set: (0, import_cosmokit2.pick)((0, import_core.executeUpdate)(row, update, ref), updateFields)
      });
    }
    await bulk.execute();
  }
  async remove(sel) {
    const { query, table } = sel;
    const filter = this.transformQuery(query, table);
    if (!filter)
      return;
    await this.db.collection(table).deleteMany(filter);
  }
  async create(sel, data) {
    const { table } = sel;
    const lastTask = Promise.resolve(this._createTasks[table]).catch(import_cosmokit2.noop);
    return this._createTasks[table] = lastTask.then(async () => {
      const model = this.model(table);
      const coll = this.db.collection(table);
      const { primary, autoInc } = model;
      if (typeof primary === "string" && !(primary in data)) {
        if (autoInc) {
          const { value } = await this.db.collection("_fields").findOneAndUpdate(
            { table, field: primary },
            { $inc: { autoInc: 1 } },
            { upsert: true, returnDocument: "after" }
          );
          data[primary] = value.autoInc;
        }
      }
      try {
        data = model.create(data);
        const copy = this.unpatchVirtual(table, { ...data });
        await coll.insertOne(copy);
        return data;
      } catch (err) {
        if (err instanceof import_mongodb.MongoError && err.code === 11e3) {
          throw new import_core.RuntimeError("duplicate-entry", err.message);
        }
        throw err;
      }
    });
  }
  async upsert(sel, data, keys) {
    if (!data.length)
      return;
    const { table, ref, model } = sel;
    const coll = this.db.collection(table);
    const original = (await coll.find({
      $or: data.map((item) => {
        return this.transformQuery((0, import_cosmokit2.pick)(item, keys), table);
      })
    }).toArray()).map((row) => this.patchVirtual(table, row));
    const bulk = coll.initializeUnorderedBulkOp();
    for (const update of data) {
      const item = original.find((item2) => keys.every((key) => item2[key].valueOf() === update[key].valueOf()));
      if (item) {
        const updateFields = new Set(Object.keys(update).map((key) => key.split(".", 1)[0]));
        const override = (0, import_cosmokit2.omit)((0, import_cosmokit2.pick)((0, import_core.executeUpdate)(item, update, ref), updateFields), keys);
        const query = this.transformQuery((0, import_cosmokit2.pick)(item, keys), table);
        if (!query)
          continue;
        bulk.find(query).updateOne({ $set: override });
      } else {
        const copy = (0, import_core.executeUpdate)(model.create(), update, ref);
        bulk.insert(this.unpatchVirtual(table, copy));
      }
    }
    await bulk.execute();
  }
};
__name(MongoDriver, "MongoDriver");
var src_default = MongoDriver;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map
