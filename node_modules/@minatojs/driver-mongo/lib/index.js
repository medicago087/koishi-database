var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/mongo/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_mongodb = require("mongodb");
var import_cosmokit2 = require("cosmokit");
var import_core = require("@minatojs/core");
var import_url = require("url");

// packages/mongo/src/utils.ts
var import_cosmokit = require("cosmokit");
function createFieldFilter(query, key) {
  const filters = [];
  const result = {};
  const child = transformFieldQuery(query, key, filters);
  if (child === false)
    return false;
  if (child !== true)
    result[key] = child;
  if (filters.length)
    result.$and = filters;
  if (Object.keys(result).length)
    return result;
  return true;
}
__name(createFieldFilter, "createFieldFilter");
function transformFieldQuery(query, key, filters) {
  if (typeof query === "string" || typeof query === "number" || query instanceof Date) {
    return { $eq: query };
  } else if (Array.isArray(query)) {
    if (!query.length)
      return false;
    return { $in: query };
  } else if (query instanceof RegExp) {
    return { $regex: query };
  } else if ((0, import_cosmokit.isNullable)(query)) {
    return { $exists: false };
  }
  const result = {};
  for (const prop in query) {
    if (prop === "$and") {
      for (const item of query[prop]) {
        const child = createFieldFilter(item, key);
        if (child === false)
          return false;
        if (child !== true)
          filters.push(child);
      }
    } else if (prop === "$or") {
      const $or = [];
      if (!query[prop].length)
        return false;
      const always = query[prop].some((item) => {
        const child = createFieldFilter(item, key);
        if (typeof child === "boolean")
          return child;
        $or.push(child);
      });
      if (!always)
        filters.push({ $or });
    } else if (prop === "$not") {
      const child = createFieldFilter(query[prop], key);
      if (child === true)
        return false;
      if (child !== false)
        filters.push({ $nor: [child] });
    } else if (prop === "$el") {
      const child = transformFieldQuery(query[prop], key, filters);
      if (child === false)
        return false;
      if (child !== true)
        result.$elemMatch = child;
    } else if (prop === "$regexFor") {
      filters.push({
        $expr: {
          $function: {
            body: function(data, value) {
              return new RegExp(data, "i").test(value);
            }.toString(),
            args: ["$" + key, query.$regexFor],
            lang: "js"
          }
        }
      });
    } else {
      result[prop] = query[prop];
    }
  }
  if (!Object.keys(result).length)
    return true;
  return result;
}
__name(transformFieldQuery, "transformFieldQuery");
function transformQuery(query, virtualKey) {
  const filter = {};
  const additional = [];
  for (const key in query) {
    const value = query[key];
    if (key === "$and" || key === "$or") {
      if (value.length) {
        filter[key] = value.map((query2) => transformQuery(query2, virtualKey));
      } else if (key === "$or") {
        return;
      }
    } else if (key === "$not") {
      const query2 = transformQuery(value, virtualKey);
      if (query2)
        filter.$nor = [query2];
    } else if (key === "$expr") {
      additional.push({ $expr: transformEval(value, virtualKey) });
    } else {
      const actualKey = getActualKey(key, virtualKey);
      const query2 = transformFieldQuery(value, actualKey, additional);
      if (query2 === false)
        return;
      if (query2 !== true)
        filter[actualKey] = query2;
    }
  }
  if (additional.length) {
    (filter.$and || (filter.$and = [])).push(...additional);
  }
  return filter;
}
__name(transformQuery, "transformQuery");
function transformEvalExpr(expr, virtualKey, onAggr) {
  return (0, import_cosmokit.valueMap)(expr, (value) => {
    if (Array.isArray(value)) {
      return value.map((val) => transformEval(val, virtualKey, onAggr));
    } else {
      return transformEval(value, virtualKey, onAggr);
    }
  });
}
__name(transformEvalExpr, "transformEvalExpr");
function transformAggr(expr, virtualKey) {
  if (typeof expr === "string") {
    return "$" + expr;
  }
  return transformEvalExpr(expr, virtualKey);
}
__name(transformAggr, "transformAggr");
var aggrKeys = ["$sum", "$avg", "$min", "$max", "$count"];
var letters = "abcdefghijklmnopqrstuvwxyz";
function getActualKey(key, virtualKey) {
  return key === virtualKey ? "_id" : key;
}
__name(getActualKey, "getActualKey");
function transformEval(expr, virtualKey, onAggr) {
  if (typeof expr === "number" || typeof expr === "string" || typeof expr === "boolean") {
    return expr;
  } else if (expr.$) {
    if (typeof expr.$ === "string") {
      return "$" + getActualKey(expr.$, virtualKey);
    } else {
      return "$" + getActualKey(expr.$[1], virtualKey);
    }
  }
  for (const key of aggrKeys) {
    if (!expr[key])
      continue;
    const value = transformAggr(expr[key], virtualKey);
    const $ = Array(8).fill(0).map(() => letters[Math.floor(Math.random() * letters.length)]).join("");
    if (key === "$count") {
      onAggr([
        { $group: { _id: value } },
        { $group: { _id: null, [$]: { $count: {} } } }
      ]);
    } else {
      onAggr([{ $group: { _id: null, [$]: { [key]: value } } }]);
    }
    return { $ };
  }
  return transformEvalExpr(expr, virtualKey, onAggr);
}
__name(transformEval, "transformEval");

// packages/mongo/src/index.ts
var MongoDriver = class extends import_core.Driver {
  constructor(database, config) {
    super(database);
    this.config = config;
    this.mongo = this;
    this._evalTasks = [];
    this._createTasks = {};
  }
  connectionStringFromConfig() {
    const {
      authDatabase,
      connectOptions,
      host = "localhost",
      database,
      password,
      protocol = "mongodb",
      port = protocol.includes("srv") ? null : 27017,
      username
    } = this.config;
    let mongourl = `${protocol}://`;
    if (username)
      mongourl += `${encodeURIComponent(username)}${password ? `:${encodeURIComponent(password)}` : ""}@`;
    mongourl += `${host}${port ? `:${port}` : ""}/${authDatabase || database}`;
    if (connectOptions) {
      const params = new import_url.URLSearchParams(connectOptions);
      mongourl += `?${params}`;
    }
    return mongourl;
  }
  async start() {
    const url = this.config.uri || this.connectionStringFromConfig();
    this.client = await import_mongodb.MongoClient.connect(url);
    this.db = this.client.db(this.config.database);
  }
  stop() {
    return this.client.close();
  }
  async _createIndexes(table) {
    const { primary, unique } = this.model(table);
    const coll = this.db.collection(table);
    const newSpecs = [];
    const oldSpecs = await coll.indexes();
    [primary, ...unique].forEach((keys, index) => {
      if (this.config.virtualKey && !index && typeof keys === "string")
        return;
      keys = (0, import_cosmokit2.makeArray)(keys);
      const name = (index ? "unique:" : "primary:") + keys.join("+");
      if (oldSpecs.find((spec) => spec.name === name))
        return;
      newSpecs.push({
        name,
        key: Object.fromEntries(keys.map((key) => [key, 1])),
        unique: true,
        partialFilterExpression: Object.fromEntries(keys.map((key) => [key, { $exists: true }]))
      });
    });
    if (!newSpecs.length)
      return;
    await coll.createIndexes(newSpecs);
  }
  async _createFields(table) {
    const { fields } = this.model(table);
    const coll = this.db.collection(table);
    await Promise.all(Object.keys(fields).map((key) => {
      if ((0, import_cosmokit2.isNullable)(fields[key].initial))
        return;
      return coll.updateMany({ [key]: { $exists: false } }, { $set: { [key]: fields[key].initial } });
    }));
  }
  async prepare(table) {
    await this.db.createCollection(table).catch(import_cosmokit2.noop);
    await Promise.all([
      this._createIndexes(table),
      this._createFields(table)
    ]);
  }
  async drop() {
    await Promise.all(Object.keys(this.database.tables).map((name) => this.db.dropCollection(name)));
  }
  async _collStats() {
    const tables = Object.keys(this.database.tables);
    const entries = await Promise.all(tables.map(async (name) => {
      const coll = this.db.collection(name);
      const { count, size } = await coll.stats();
      return [coll.collectionName, { count, size }];
    }));
    return Object.fromEntries(entries);
  }
  async stats() {
    const [stats, tables] = await Promise.all([
      this.db.stats(),
      this._collStats()
    ]);
    const totalSize = stats.indexSize + stats.storageSize;
    return { size: totalSize, tables };
  }
  getVirtualKey(table) {
    const { primary } = this.model(table);
    if (typeof primary === "string" && this.config.virtualKey) {
      return primary;
    }
  }
  patchVirtual(table, row) {
    const { primary } = this.model(table);
    if (typeof primary === "string" && this.config.virtualKey) {
      row[primary] = row["_id"];
      delete row["_id"];
    }
    return row;
  }
  unpatchVirtual(table, row) {
    const { primary } = this.model(table);
    if (typeof primary === "string" && this.config.virtualKey) {
      row["_id"] = row[primary];
      delete row[primary];
    }
    return row;
  }
  transformQuery(query, table) {
    return transformQuery(query, this.getVirtualKey(table));
  }
  async get(sel, modifier) {
    const { table, fields, query } = sel;
    const { offset, limit, sort } = modifier;
    const filter = this.transformQuery(query, table);
    if (!filter)
      return [];
    let cursor = this.db.collection(table).find(filter);
    if (limit < Infinity) {
      cursor = cursor.limit(offset + limit);
    }
    cursor = cursor.skip(offset);
    cursor = cursor.sort(Object.fromEntries(sort.map(([k, v]) => [k["$"][1], v === "desc" ? -1 : 1])));
    const data = await cursor.toArray();
    return data.map((row) => {
      row = this.patchVirtual(table, row);
      return sel.resolveData(row, fields);
    });
  }
  async eval(sel, expr) {
    const { table, query } = sel;
    return new Promise((resolve, reject) => {
      this._evalTasks.push({ expr, table, query, resolve, reject });
      process.nextTick(() => this._flushEvalTasks());
    });
  }
  async _flushEvalTasks() {
    const tasks = this._evalTasks;
    if (!tasks.length)
      return;
    this._evalTasks = [];
    const stages = [{ $match: { _id: null } }];
    for (const task of tasks) {
      const { expr, table, query } = task;
      task.expr = transformEval(expr, this.getVirtualKey(table), (pipeline) => {
        const filter = this.transformQuery(query, table) || { _id: null };
        pipeline.unshift({ $match: filter });
        stages.push({ $unionWith: { coll: table, pipeline } });
      });
    }
    let data;
    try {
      const results = await this.db.collection("user").aggregate(stages).toArray();
      data = Object.assign({}, ...results);
    } catch (error) {
      tasks.forEach((task) => task.reject(error));
      return;
    }
    for (const { expr, resolve, reject } of tasks) {
      try {
        resolve((0, import_core.executeEval)({ _: data }, expr));
      } catch (error) {
        reject(error);
      }
    }
  }
  async set(sel, update) {
    const { query, table, ref } = sel;
    const filter = this.transformQuery(query, table);
    if (!filter)
      return;
    const indexFields = (0, import_cosmokit2.makeArray)(sel.model.primary);
    const coll = this.db.collection(table);
    const original = await coll.find(filter).toArray();
    if (!original.length)
      return;
    const updateFields = new Set(Object.keys(update).map((key) => key.split(".", 1)[0]));
    const bulk = coll.initializeUnorderedBulkOp();
    for (const item of original) {
      const row = this.patchVirtual(table, item);
      const query2 = this.transformQuery((0, import_cosmokit2.pick)(row, indexFields), table);
      bulk.find(query2).updateOne({
        $set: (0, import_cosmokit2.pick)((0, import_core.executeUpdate)(row, update, ref), updateFields)
      });
    }
    await bulk.execute();
  }
  async remove(sel) {
    const { query, table } = sel;
    const filter = this.transformQuery(query, table);
    if (!filter)
      return;
    await this.db.collection(table).deleteMany(filter);
  }
  async create(sel, data) {
    const { table } = sel;
    const lastTask = Promise.resolve(this._createTasks[table]).catch(import_cosmokit2.noop);
    return this._createTasks[table] = lastTask.then(async () => {
      const model = this.model(table);
      const coll = this.db.collection(table);
      const { primary, fields, autoInc } = model;
      if (typeof primary === "string" && !(primary in data)) {
        const key = this.config.virtualKey ? "_id" : primary;
        if (autoInc) {
          const [latest] = await coll.find().sort(key, -1).limit(1).toArray();
          data[primary] = latest ? +latest[key] + 1 : 1;
          if (import_core.Field.string.includes(fields[primary].type)) {
            data[primary] += "";
            data[primary] = data[primary].padStart(8, "0");
          }
        }
      }
      try {
        data = model.create(data);
        const copy = this.unpatchVirtual(table, { ...data });
        await coll.insertOne(copy);
        return data;
      } catch (err) {
        if (err instanceof import_mongodb.MongoError && err.code === 11e3) {
          throw new import_core.RuntimeError("duplicate-entry", err.message);
        }
        throw err;
      }
    });
  }
  async upsert(sel, data, keys) {
    if (!data.length)
      return;
    const { table, ref, model } = sel;
    const coll = this.db.collection(table);
    const original = (await coll.find({
      $or: data.map((item) => {
        return this.transformQuery((0, import_cosmokit2.pick)(item, keys), table);
      })
    }).toArray()).map((row) => this.patchVirtual(table, row));
    const bulk = coll.initializeUnorderedBulkOp();
    for (const update of data) {
      const item = original.find((item2) => keys.every((key) => item2[key].valueOf() === update[key].valueOf()));
      if (item) {
        const updateFields = new Set(Object.keys(update).map((key) => key.split(".", 1)[0]));
        const override = (0, import_cosmokit2.omit)((0, import_cosmokit2.pick)((0, import_core.executeUpdate)(item, update, ref), updateFields), keys);
        const query = this.transformQuery((0, import_cosmokit2.pick)(item, keys), table);
        bulk.find(query).updateOne({ $set: override });
      } else {
        const copy = (0, import_core.executeUpdate)(model.create(), update, ref);
        bulk.insert(this.unpatchVirtual(table, copy));
      }
    }
    await bulk.execute();
  }
};
__name(MongoDriver, "MongoDriver");
var src_default = MongoDriver;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map
