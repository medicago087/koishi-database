var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// adapters/kook/src/index.ts
var src_exports = {};
__export(src_exports, {
  HttpServer: () => HttpServer,
  Kook: () => types_exports,
  KookBot: () => KookBot,
  KookMessenger: () => KookMessenger,
  WsClient: () => WsClient,
  adaptAuthor: () => adaptAuthor,
  adaptGroup: () => adaptGroup,
  adaptMessage: () => adaptMessage,
  adaptSession: () => adaptSession,
  adaptUser: () => adaptUser,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// adapters/kook/src/bot.ts
var import_satori5 = require("@satorijs/satori");

// adapters/kook/src/utils.ts
var import_satori = require("@satorijs/satori");

// adapters/kook/src/types.ts
var types_exports = {};
__export(types_exports, {
  Internal: () => Internal,
  Signal: () => Signal,
  Type: () => Type,
  UserStatus: () => UserStatus
});
var Signal = /* @__PURE__ */ ((Signal2) => {
  Signal2[Signal2["event"] = 0] = "event";
  Signal2[Signal2["hello"] = 1] = "hello";
  Signal2[Signal2["ping"] = 2] = "ping";
  Signal2[Signal2["pong"] = 3] = "pong";
  Signal2[Signal2["reconnect"] = 4] = "reconnect";
  Signal2[Signal2["resume"] = 5] = "resume";
  return Signal2;
})(Signal || {});
var Type = /* @__PURE__ */ ((Type2) => {
  Type2[Type2["text"] = 1] = "text";
  Type2[Type2["image"] = 2] = "image";
  Type2[Type2["video"] = 3] = "video";
  Type2[Type2["file"] = 4] = "file";
  Type2[Type2["unknown"] = 7] = "unknown";
  Type2[Type2["audio"] = 8] = "audio";
  Type2[Type2["kmarkdown"] = 9] = "kmarkdown";
  Type2[Type2["card"] = 10] = "card";
  Type2[Type2["system"] = 255] = "system";
  return Type2;
})(Type || {});
var UserStatus = /* @__PURE__ */ ((UserStatus2) => {
  UserStatus2[UserStatus2["normal"] = 0] = "normal";
  UserStatus2[UserStatus2["banned"] = 10] = "banned";
  return UserStatus2;
})(UserStatus || {});
var Internal = class {
  constructor(http) {
    this.http = http;
  }
  static define(name, method, path) {
    Internal.prototype[name] = function(...args) {
      const config = {};
      if (method === "GET" || method === "DELETE") {
        config.params = args[0];
      } else {
        config.data = args[0];
      }
      return this.http(method, path, config);
    };
  }
};
__name(Internal, "Internal");
Internal.define("getGuildList", "GET", "/guild/list");
Internal.define("getGuildView", "GET", "/guild/view");
Internal.define("getGuildUserList", "GET", "/guild/user-list");
Internal.define("setGuildUserNickname", "POST", "/guild/nickname");
Internal.define("leaveGuild", "POST", "/guild/leave");
Internal.define("kickoutGuildUser", "POST", "/guild/kickout");
Internal.define("getGuildMuteList", "GET", "/guild-mute/list");
Internal.define("setGuildMute", "POST", "/guild-mute/create");
Internal.define("unsetGuildMute", "POST", "/guild-mute/delete");

// adapters/kook/src/utils.ts
var adaptGroup = /* @__PURE__ */ __name((data) => ({
  guildId: data.id,
  guildName: data.name
}), "adaptGroup");
var adaptUser = /* @__PURE__ */ __name((user) => ({
  userId: user.id,
  avatar: user.avatar,
  username: user.username,
  discriminator: user.identify_num
}), "adaptUser");
var adaptAuthor = /* @__PURE__ */ __name((author) => ({
  ...adaptUser(author),
  nickname: author.nickname
}), "adaptAuthor");
function adaptMessageMeta(base, meta, session = {}) {
  var _a;
  if (meta.author) {
    session.author = adaptAuthor(meta.author);
    session.userId = meta.author.id;
  }
  if (base.type === 1 /* text */) {
    session.content = base.content.replace(/@(.+?)#(\d+)/, (_, name, id) => (0, import_satori.segment)("at", { id, name }).toString()).replace(/@全体成员/, () => (0, import_satori.segment)("at", { type: "all" }).toString()).replace(/@在线成员/, () => (0, import_satori.segment)("at", { type: "here" }).toString()).replace(/@role:(\d+);/, (_, role) => (0, import_satori.segment)("at", { role }).toString()).replace(/#channel:(\d+);/, (_, id) => import_satori.segment.sharp(id).toString());
    session.elements = import_satori.segment.parse(session.content);
  } else if (base.type === 2 /* image */) {
    const element = (0, import_satori.segment)("image", { url: base.content, file: (_a = meta.attachments) == null ? void 0 : _a.name });
    session.elements = [element];
    session.content = element.toString();
  } else if (base.type == 9 /* kmarkdown */) {
    session.content = base.content.replace(/\(met\)all\(met\)/g, () => (0, import_satori.segment)("at", { type: "all" }).toString()).replace(/\(met\)here\(met\)/g, () => (0, import_satori.segment)("at", { type: "here" }).toString()).replace(/\(chn\)(\d+)\(chn\)/g, (_, id) => import_satori.segment.sharp(id).toString());
    for (const mention of meta.kmarkdown.mention_part) {
      session.content = session.content.replace(`(met)${mention.id}(met)`, import_satori.segment.at(mention.id, { name: mention.username }).toString());
    }
    for (const mention of meta.kmarkdown.mention_role_part) {
      const element = (0, import_satori.segment)("at", { role: mention.role_id, name: mention.name });
      session.content = session.content.replace(`(rol)${mention.role_id}(rol)`, element.toString());
    }
    session.content = session.content.replace(/\\\*/g, () => "*").replace(/\\\\/g, () => "\\").replace(/\\\(/g, () => "(").replace(/\\\)/g, () => ")");
    session.elements = import_satori.segment.parse(session.content);
  }
  return session;
}
__name(adaptMessageMeta, "adaptMessageMeta");
function adaptMessage(message, session = {}) {
  adaptMessageMeta(message, message, session);
  session.messageId = message.id;
  return session;
}
__name(adaptMessage, "adaptMessage");
function adaptMessageSession(data, meta, session = {}) {
  adaptMessageMeta(data, meta, session);
  session.messageId = data.msg_id;
  session.timestamp = data.msg_timestamp;
  const subtype = data.channel_type === "GROUP" ? "group" : "private";
  session.subtype = subtype;
  if (meta.quote) {
    session.quote = adaptMessageMeta(meta.quote, meta.quote);
    session.quote.messageId = meta.quote.id;
    session.quote.channelId = session.channelId;
    session.quote.subtype = subtype;
  }
  return session;
}
__name(adaptMessageSession, "adaptMessageSession");
function adaptMessageCreate(data, meta, session) {
  adaptMessageSession(data, meta, session);
  session.guildId = meta.guild_id;
  session.channelName = meta.channel_name;
  if (data.channel_type === "GROUP") {
    session.subtype = "group";
    session.channelId = data.target_id;
  } else {
    session.subtype = "private";
    session.channelId = meta.code;
  }
}
__name(adaptMessageCreate, "adaptMessageCreate");
function adaptMessageModify(data, meta, session) {
  adaptMessageSession(data, meta, session);
  session.messageId = meta.msg_id;
  session.channelId = meta.channel_id;
}
__name(adaptMessageModify, "adaptMessageModify");
function adaptReaction(body, session) {
  session.channelId = body.channel_id;
  session.messageId = body.msg_id;
  session.userId = body.user_id;
  session["emoji"] = body.emoji.id;
}
__name(adaptReaction, "adaptReaction");
function adaptSession(bot, input) {
  const session = bot.session();
  if (input.type === 255 /* system */) {
    const { type, body } = input.extra;
    switch (type) {
      case "updated_message":
      case "updated_private_message":
        session.type = "message-updated";
        adaptMessageModify(input, body, session);
        break;
      case "deleted_message":
      case "deleted_private_message":
        session.type = "message-deleted";
        adaptMessageModify(input, body, session);
        break;
      case "added_reaction":
      case "private_added_reaction":
        session.type = "reaction-added";
        adaptReaction(body, session);
        break;
      case "deleted_reaction":
      case "private_deleted_reaction":
        session.type = "reaction-deleted";
        adaptReaction(body, session);
        break;
      default:
        return;
    }
  } else {
    session.type = "message";
    adaptMessageCreate(input, input.extra, session);
    if (!session.content)
      return;
  }
  return session;
}
__name(adaptSession, "adaptSession");

// adapters/kook/src/bot.ts
var import_form_data2 = __toESM(require("form-data"));

// adapters/kook/src/ws.ts
var import_satori2 = require("@satorijs/satori");
var import_ws = __toESM(require("ws"));
var logger = new import_satori2.Logger("kook");
var heartbeatIntervals = [6, 2, 4];
var WsClient = class extends import_satori2.Adapter.WsClient {
  constructor() {
    super(...arguments);
    this._sn = 0;
  }
  async prepare(bot) {
    const { url } = await bot.request("GET", "/gateway/index?compress=0");
    const headers = { Authorization: `Bot ${bot.config.token}` };
    return new import_ws.default(url, { headers });
  }
  heartbeat(bot) {
    if (!bot.socket || bot.status !== "online") {
      clearInterval(this._heartbeat);
      return;
    }
    let trials = 0;
    const send = /* @__PURE__ */ __name(() => {
      if (!bot.socket)
        return;
      if (trials >= 2) {
        return bot.socket.close(1013);
      }
      bot.socket.send(JSON.stringify({ s: 2 /* ping */, sn: this._sn }));
      this._ping = setTimeout(send, heartbeatIntervals[trials++] * import_satori2.Time.second);
    }, "send");
    send();
  }
  async accept(bot) {
    this._sn = 0;
    clearInterval(this._heartbeat);
    bot.socket.on("message", async (data) => {
      let parsed;
      try {
        parsed = JSON.parse(data.toString());
      } catch (error) {
        return logger.warn("cannot parse message", data);
      }
      if (parsed.s === 0 /* event */) {
        this._sn = Math.max(this._sn, parsed.sn);
        const session = adaptSession(bot, parsed.d);
        if (session)
          bot.dispatch(session);
      } else if (parsed.s === 1 /* hello */) {
        this._heartbeat = setInterval(() => this.heartbeat(bot), import_satori2.Time.minute * 0.5);
        Object.assign(bot, await bot.getSelf());
        bot.online();
      } else if (parsed.s === 3 /* pong */) {
        clearTimeout(this._ping);
      } else if (parsed.s === 5 /* resume */) {
        bot.socket.close(1013);
      }
    });
  }
};
__name(WsClient, "WsClient");
((WsClient2) => {
  WsClient2.Config = import_satori2.Schema.intersect([
    import_satori2.Schema.object({
      protocol: import_satori2.Schema.const("ws").required(),
      token: import_satori2.Schema.string().description("机器人的用户令牌。").role("secret").required()
    }),
    import_satori2.Adapter.WsClient.Config
  ]);
})(WsClient || (WsClient = {}));

// adapters/kook/src/http.ts
var import_satori3 = require("@satorijs/satori");
var logger2 = new import_satori3.Logger("kook");
var HttpServer = class extends import_satori3.Adapter.Server {
  constructor(ctx, bot) {
    super();
    let { path } = bot.config;
    path = (0, import_satori3.sanitize)(path);
    ctx.router.post(path, (ctx2) => {
      const { body } = ctx2.request;
      logger2.debug("receive %o", body);
      const { challenge } = body.d;
      ctx2.status = 200;
      if (challenge) {
        ctx2.body = { challenge };
        return;
      }
      const bot2 = this.bots.find((bot3) => bot3.config.verifyToken === body.d.verify_token);
      if (!bot2)
        return;
      const session = adaptSession(bot2, body.d);
      if (session)
        bot2.dispatch(session);
    });
  }
  async start(bot) {
    Object.assign(bot, await bot.getSelf());
    bot.online();
  }
};
__name(HttpServer, "HttpServer");
((HttpServer2) => {
  HttpServer2.Config = import_satori3.Schema.object({
    protocol: import_satori3.Schema.const("http").required(),
    path: import_satori3.Schema.string().description("服务器监听的路径。").default("/kook"),
    token: import_satori3.Schema.string().description("机器人的用户令牌。").role("secret").required(),
    verifyToken: import_satori3.Schema.string().description("机器人的验证令牌。").role("secret").required()
  });
})(HttpServer || (HttpServer = {}));

// adapters/kook/src/message.ts
var import_satori4 = require("@satorijs/satori");
var import_form_data = __toESM(require("form-data"));
var attachmentTypes = ["image", "video", "audio", "file"];
var KookMessenger = class extends import_satori4.Messenger {
  constructor(bot, channelId, guildId) {
    super(bot, channelId, guildId);
    this.params = {};
    this.additional = {};
    this.buffer = "";
    if (channelId.length > 30) {
      this.params.chat_code = channelId;
      this.path = "/user-chat/create-msg";
    } else {
      this.params.target_id = channelId;
      this.path = "/message/create";
    }
  }
  async post(type, content) {
    try {
      const params = { ...this.params, ...this.additional, type, content };
      const result = await this.bot.request("POST", this.path, params);
      const session = this.bot.session();
      adaptMessage(result, session);
      this.results.push(session);
      session.app.emit(session, "send", session);
    } catch (e) {
      this.errors.push(e);
    }
  }
  async transformUrl({ type, attrs }) {
    if (["file:", "base64:", "data:"].some((protocol) => attrs.url.startsWith(protocol))) {
      const payload = new import_form_data.default();
      const result = await this.bot.ctx.http.file(attrs.url);
      payload.append("file", Buffer.from(result.data), {
        filename: attrs.file || result.filename
      });
      const { url } = await this.bot.request("POST", "/asset/create", payload, payload.getHeaders());
      return url;
    } else if (!attrs.url.includes("kaiheila")) {
      const res = await this.bot.ctx.http.get(attrs.url, {
        headers: { accept: type + "/*" },
        responseType: "stream"
      });
      const payload = new import_form_data.default();
      payload.append("file", res, {
        filename: "file"
      });
      const { url } = await this.bot.request("POST", "/asset/create", payload, payload.getHeaders());
      return url;
    }
  }
  async _sendCard(chain, useMarkdown) {
    const type = useMarkdown ? "kmarkdown" : "plain-text";
    let text = { type, content: "" };
    let card = { type: "card", modules: [] };
    const output = [];
    const flushText = /* @__PURE__ */ __name(() => {
      text.content = text.content.trim();
      if (!text.content)
        return;
      card.modules.push({ type: "section", text });
      text = { type, content: "" };
    }, "flushText");
    const flushCard = /* @__PURE__ */ __name(() => {
      flushText();
      if (!card.modules.length)
        return;
      output.push(card);
      card = { type: "card", modules: [] };
    }, "flushCard");
    for (const element of chain) {
      const { type: type2, attrs } = element;
      if (type2 === "text") {
        text.content += attrs.content;
      } else if (type2 === "at") {
        if (attrs.id) {
          text.content += `@user#${attrs.id}`;
        } else if (attrs.type === "all") {
          text.content += "@全体成员";
        } else if (attrs.type === "here") {
          text.content += "@在线成员";
        } else if (attrs.role) {
          text.content += `@role:${attrs.role};`;
        }
      } else if (type2 === "sharp") {
        text.content += `#channel:${attrs.id};`;
      } else if (attachmentTypes.includes(type2)) {
        flushText();
        await this.transformUrl(element);
        if (type2 === "image") {
          card.modules.push({
            type: "image-group",
            elements: [{
              type: "image",
              src: attrs.url
            }]
          });
        } else {
          card.modules.push({
            type: type2,
            src: attrs.url
          });
        }
      } else if (type2 === "card") {
        flushCard();
        output.push(JSON.parse(attrs.content));
      }
    }
    flushCard();
    await this.post(10 /* card */, JSON.stringify(output));
  }
  async flush() {
    const content = this.buffer.trim();
    if (!content)
      return;
    await this.post(9 /* kmarkdown */, content);
    this.buffer = "";
    this.additional = {};
  }
  async visit(element) {
    const { type, attrs, children } = element;
    if (type === "text") {
      this.buffer += attrs.content.replace(/[\\*_`~()]/g, "\\$&");
    } else if (type === "b" || type === "strong") {
      this.buffer += "**";
      await this.render(children);
      this.buffer += "**";
    } else if (type === "i" || type === "em") {
      this.buffer += "*";
      await this.render(children);
      this.buffer += "*";
    } else if (type === "u" || type === "ins") {
      this.buffer += "(ins)";
      await this.render(children);
      this.buffer += "(ins)";
    } else if (type === "s" || type === "del") {
      this.buffer += "~~";
      await this.render(children);
      this.buffer += "~~";
    } else if (type === "spl") {
      this.buffer += "(spl)";
      await this.render(children);
      this.buffer += "(spl)";
    } else if (type === "code") {
      this.buffer += "`";
      await this.render(children);
      this.buffer += "`";
    } else if (type === "a") {
      this.buffer += `[`;
      await this.render(children);
      this.buffer += `](${attrs.href})`;
    } else if (type === "p") {
      await this.render(children);
      this.buffer += "\n";
    } else if (type === "at") {
      if (attrs.id) {
        this.buffer += `(met)${attrs.id}(met)`;
      } else if (attrs.type === "all") {
        this.buffer += `(met)all(met)`;
      } else if (attrs.type === "here") {
        this.buffer += `(met)here(met)`;
      } else if (attrs.role) {
        this.buffer += `(rol)${attrs.role}(rol)`;
      }
    } else if (type === "code") {
      this.buffer += `\`${element.toString(true)}\``;
    } else if (type === "sharp") {
      this.buffer += `(chn)${attrs.id}(chn)`;
    } else if (["image", "video", "audio", "file"].includes(type)) {
      await this.flush();
      const url = await this.transformUrl(element);
      await this.post(Type[type], url);
    } else if (type === "quote") {
      await this.flush();
      this.additional.quote = attrs.id;
    } else if (type === "message") {
      await this.flush();
      await this.render(children, true);
    } else {
      await this.render(children);
    }
  }
};
__name(KookMessenger, "KookMessenger");
((KookMessenger2) => {
  KookMessenger2.Config = import_satori4.Schema.object({
    handleMixedContent: import_satori4.Schema.union([
      import_satori4.Schema.const("separate").description("将每个不同形式的内容分开发送"),
      import_satori4.Schema.const("card").description("使用卡片发送内容"),
      import_satori4.Schema.const("mixed").description("使用混合模式发送内容")
    ]).role("radio").description("发送图文等混合内容时采用的方式。").default("separate")
  }).description("发送设置");
})(KookMessenger || (KookMessenger = {}));

// adapters/kook/src/bot.ts
var KookBot = class extends import_satori5.Bot {
  constructor(ctx, config) {
    super(ctx, config);
    this.http = ctx.http.extend({
      headers: {
        "Authorization": `Bot ${config.token}`,
        "Content-Type": "application/json"
      }
    }).extend(config);
    this.internal = new Internal(this.http);
    if (config.protocol === "http") {
      ctx.plugin(HttpServer, this);
    } else if (config.protocol === "ws") {
      ctx.plugin(WsClient, this);
    }
  }
  async request(method, path, data, headers = {}) {
    data = data instanceof import_form_data2.default ? data : JSON.stringify(data);
    return (await this.http(method, path, { data, headers })).data;
  }
  async sendMessage(channelId, content, guildId) {
    return new KookMessenger(this, channelId, guildId).send(content);
  }
  async sendPrivateMessage(target_id, content) {
    const { code } = await this.request("POST", "/user-chat/create", { target_id });
    return this.sendMessage(code, content);
  }
  async deleteMessage(channelId, msg_id) {
    if (channelId.length > 30) {
      await this.request("POST", "/user-chat/delete-msg", { msg_id });
    } else {
      await this.request("POST", "/message/delete", { msg_id });
    }
  }
  async editMessage(channelId, msg_id, content) {
    content = import_satori5.segment.normalize(content).join("");
    if (channelId.length > 30) {
      await this.request("POST", "/user-chat/update-msg", { msg_id, content });
    } else {
      await this.request("POST", "/message/update", { msg_id, content });
    }
  }
  async getMessage(channelId, msg_id) {
    if (channelId.length > 30) {
      return adaptMessage(await this.request("POST", "/user-chat/view", { msg_id }));
    } else {
      return adaptMessage(await this.request("POST", "/message/view", { msg_id }));
    }
  }
  async $createReaction(channelId, msg_id, emoji) {
    if (channelId.length > 30) {
      await this.request("POST", "/direct-message/add-reaction", { msg_id, emoji });
    } else {
      await this.request("POST", "/message/add-reaction", { msg_id, emoji });
    }
  }
  async $deleteReaction(channelId, messageId, emoji, user_id) {
    if (channelId.length > 30) {
      await this.request("POST", "/direct-message/delete-reaction", { msg_id: messageId, emoji });
    } else {
      await this.request("POST", "/message/delete-reaction", { msg_id: messageId, emoji, user_id });
    }
  }
  async getSelf() {
    const data = adaptUser(await this.request("GET", "/user/me"));
    data["selfId"] = data.userId;
    delete data.userId;
    return data;
  }
  async getGuildList() {
    const { items } = await this.request("GET", "/guild/list");
    return items.map(adaptGroup);
  }
  async getGuildMemberList() {
    const { items } = await this.request("GET", "/guild/user-list");
    return items.map(adaptAuthor);
  }
  async setGroupNickname(guild_id, user_id, nickname) {
    await this.request("POST", "/guild/nickname", { guild_id, user_id, nickname });
  }
  async leaveGroup(guild_id) {
    await this.request("POST", "/guild/leave", { guild_id });
  }
  async kickGroup(guild_id, user_id) {
    await this.request("POST", "/guild/kickout", { guild_id, user_id });
  }
};
__name(KookBot, "KookBot");
((KookBot2) => {
  KookBot2.Config = import_satori5.Schema.intersect([
    import_satori5.Schema.object({
      protocol: import_satori5.Schema.union(["http", "ws"]).description("选择要使用的协议。").required()
    }),
    import_satori5.Schema.union([
      WsClient.Config,
      HttpServer.Config
    ]),
    KookMessenger.Config,
    import_satori5.Quester.createConfig("https://www.kookapp.cn/api/v3")
  ]);
})(KookBot || (KookBot = {}));
KookBot.prototype.platform = "kook";

// adapters/kook/src/index.ts
var src_default = KookBot;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HttpServer,
  Kook,
  KookBot,
  KookMessenger,
  WsClient,
  adaptAuthor,
  adaptGroup,
  adaptMessage,
  adaptSession,
  adaptUser
});
//# sourceMappingURL=index.js.map
