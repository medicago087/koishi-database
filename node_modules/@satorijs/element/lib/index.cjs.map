{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import { Awaitable, camelize, capitalize, defineProperty, Dict, hyphenate, is, isNullable } from 'cosmokit'\n\nconst kElement = Symbol('element')\n\nfunction isElement(source: any): source is Element {\n  return source && typeof source === 'object' && source[kElement]\n}\n\nfunction toElement(content: string | Element) {\n  if (typeof content !== 'string') return content\n  return Element('text', { content })\n}\n\nfunction toElementArray(input: Element.Fragment) {\n  if (Array.isArray(input)) {\n    return input.map(toElement)\n  } else if (typeof input === 'string') {\n    return [toElement(input)]\n  } else if (!input.type) {\n    return input.children\n  } else {\n    return [input]\n  }\n}\n\ninterface Element {\n  [kElement]: true\n  type: string\n  attrs: Dict<string>\n  /** @deprecated use `attrs` instead */\n  data: Dict<string>\n  children: Element[]\n  source?: string\n  toString(strip?: boolean): string\n}\n\ninterface ElementConstructor extends Element {}\n\nclass ElementConstructor {\n  get data() {\n    return this.attrs\n  }\n\n  toString(strip = false) {\n    if (this.type === 'text') return Element.escape(this.attrs.content)\n    const inner = this.children.map(child => child.toString(strip)).join('')\n    if (!this.type || strip) return inner\n    const attrs = Object.entries(this.attrs).map(([key, value]) => {\n      if (isNullable(value)) return ''\n      key = hyphenate(key)\n      if (value === '') return ` ${key}`\n      return ` ${key}=\"${Element.escape(value, true)}\"`\n    }).join('')\n    if (!this.children.length) return `<${this.type}${attrs}/>`\n    return `<${this.type}${attrs}>${inner}</${this.type}>`\n  }\n}\n\ndefineProperty(ElementConstructor, 'name', 'Element')\ndefineProperty(ElementConstructor.prototype, kElement, true)\n\nfunction Element(type: string, children?: Element.Fragment): Element\nfunction Element(type: string, attrs: Dict<any>, children?: Element.Fragment): Element\nfunction Element(type: string, ...args: any[]) {\n  const el = Object.create(ElementConstructor.prototype)\n  let attrs: Dict<string> = {}, children: Element[] = []\n  if (args[0] && typeof args[0] === 'object' && !isElement(args[0]) && !Array.isArray(args[0])) {\n    for (const [key, value] of Object.entries(args.shift())) {\n      if (isNullable(value)) continue\n      if (value === true) {\n        attrs[key] = ''\n      } else if (value === false) {\n        attrs['no' + capitalize(key)] = ''\n      } else {\n        attrs[key] = '' + value\n      }\n    }\n  }\n  if (args[0]) children = toElementArray(args[0])\n  return Object.assign(el, { type, attrs, children })\n}\n\nnamespace Element {\n  export type Fragment = string | Element | (string | Element)[]\n  export type Render<T, S> = (attrs: Dict<any>, children: Element[], session: S) => T\n  export type Transformer<S> = boolean | Fragment | Render<boolean | Fragment, S>\n  export type AsyncTransformer<S> = boolean | Fragment | Render<Awaitable<boolean | Fragment>, S>\n\n  export function normalize(source: Fragment) {\n    if (typeof source !== 'string') return toElementArray(source)\n    return Element.parse(source)\n  }\n\n  export function escape(source: string, inline = false) {\n    const result = source\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n    return inline\n      ? result.replace(/\"/g, '&quot;')\n      : result\n  }\n\n  export function unescape(source: string) {\n    return source\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&quot;/g, '\"')\n      .replace(/&amp;/g, '&')\n  }\n\n  export interface FindOptions {\n    type?: string\n    caret?: boolean\n  }\n\n  /** @deprecated use `Element.select()` instead */\n  export function from(source: string, options: FindOptions = {}): Element {\n    const elements = parse(source)\n    if (options.caret) {\n      if (options.type && elements[0]?.type !== options.type) return\n      return elements[0]\n    }\n    return select(elements, options.type || '*')[0]\n  }\n\n  type Combinator = ' ' | '>' | '+' | '~'\n\n  export interface Selector {\n    type: string\n    combinator: Combinator\n  }\n\n  const combRegExp = / *([ >+~]) */g\n\n  export function parseSelector(input: string): Selector[][] {\n    return input.split(',').map((query) => {\n      const selectors: Selector[] = []\n      query = query.trim()\n      let combCap: RegExpExecArray, combinator: Combinator = ' '\n      while ((combCap = combRegExp.exec(query))) {\n        selectors.push({ type: query.slice(0, combCap.index), combinator })\n        combinator = combCap[1] as Combinator\n        query = query.slice(combCap.index + combCap[0].length)\n      }\n      selectors.push({ type: query, combinator })\n      return selectors\n    })\n  }\n\n  export function select(source: string | Element[], query: string | Selector[][]): Element[] {\n    if (typeof source === 'string') source = parse(source)\n    if (typeof query === 'string') query = parseSelector(query)\n    if (!query.length) return\n    let adjacent: Selector[][] = []\n    const results: Element[] = []\n    for (const [index, element] of source.entries()) {\n      const inner: Selector[][] = []\n      const local = [...query, ...adjacent]\n      adjacent = []\n      let matched = false\n      for (const group of local) {\n        const { type, combinator } = group[0]\n        if (type === element.type || type === '*') {\n          if (group.length === 1) {\n            matched = true\n          } else if ([' ', '>'].includes(group[1].combinator)) {\n            inner.push(group.slice(1))\n          } else if (group[1].combinator === '+') {\n            adjacent.push(group.slice(1))\n          } else {\n            query.push(group.slice(1))\n          }\n        }\n        if (combinator === ' ') {\n          inner.push(group)\n        }\n      }\n      if (matched) results.push(source[index])\n      results.push(...select(element.children, inner))\n    }\n    return results\n  }\n\n  const tagRegExp = /<(\\/?)\\s*([^\\s>/]+)([^>]*?)\\s*(\\/?)>/\n  const attrRegExp = /([^\\s=]+)(?:=\"([^\"]*)\"|=([^\"\\s]+))?/g\n\n  interface Token {\n    tag: string\n    close: string\n    empty: string\n    attrs: Dict<string>\n    source: string\n  }\n\n  export function parse(source: string) {\n    const tokens: (string | Token)[] = []\n    let tagCap: RegExpExecArray\n    while ((tagCap = tagRegExp.exec(source))) {\n      if (tagCap.index) {\n        tokens.push(unescape(source.slice(0, tagCap.index)))\n      }\n      const [_, close, tag, attrs, empty] = tagCap\n      const token: Token = { source: _, tag, close, empty, attrs: {} }\n      let attrCap: RegExpExecArray\n      while ((attrCap = attrRegExp.exec(attrs))) {\n        const [_, key, v1 = '', v2 = v1] = attrCap\n        token.attrs[camelize(key)] = unescape(v2)\n      }\n      tokens.push(token)\n      source = source.slice(tagCap.index + tagCap[0].length)\n    }\n    if (source) tokens.push(unescape(source))\n    const stack = [Element(null)]\n    function rollback(index: number) {\n      for (; index > 0; index--) {\n        const { children } = stack.shift()\n        const { source } = stack[0].children.pop()\n        stack[0].children.push(Element('text', { content: source }))\n        stack[0].children.push(...children)\n      }\n    }\n    for (const token of tokens) {\n      if (typeof token === 'string') {\n        stack[0].children.push(Element('text', { content: token }))\n      } else if (token.close) {\n        let index = 0\n        while (index < stack.length && stack[index].type !== token.tag) index++\n        if (index === stack.length) {\n          // no matching open tag\n          stack[0].children.push(Element('text', { content: token.source }))\n        } else {\n          rollback(index)\n          const element = stack.shift()\n          delete element.source\n        }\n      } else {\n        const element = Element(token.tag, token.attrs)\n        stack[0].children.push(element)\n        if (!token.empty) {\n          element.source = token.source\n          stack.unshift(element)\n        }\n      }\n    }\n    rollback(stack.length - 1)\n    return stack[0].children\n  }\n\n  export function transform<S>(source: string, rules: Dict<Transformer<S>>, session?: S): string\n  export function transform<S>(source: Element[], rules: Dict<Transformer<S>>, session?: S): Element[]\n  export function transform<S>(source: string | Element[], rules: Dict<Transformer<S>>, session?: S) {\n    const elements = typeof source === 'string' ? parse(source) : source\n    const output: Element[] = []\n    elements.forEach((element) => {\n      const { type, attrs, children } = element\n      let result = rules[type] ?? rules.default ?? true\n      if (typeof result === 'function') {\n        result = result(attrs, children, session)\n      }\n      if (result === true) {\n        output.push(Element(type, attrs, transform(children, rules)))\n      } else if (result !== false) {\n        output.push(...toElementArray(result))\n      }\n    })\n    return typeof source === 'string' ? output.join('') : output\n  }\n\n  export async function transformAsync<S>(source: string, rules: Dict<AsyncTransformer<S>>, session?: S): Promise<string>\n  export async function transformAsync<S>(source: Element[], rules: Dict<AsyncTransformer<S>>, session?: S): Promise<Element[]>\n  export async function transformAsync<S>(source: string | Element[], rules: Dict<AsyncTransformer<S>>, session?: S) {\n    const elements = typeof source === 'string' ? parse(source) : source\n    const children = (await Promise.all(elements.map(async (element) => {\n      const { type, attrs, children } = element\n      let result = rules[type] ?? rules.default ?? true\n      if (typeof result === 'function') {\n        result = await result(attrs, children, session)\n      }\n      if (result === true) {\n        return [Element(type, attrs, await transformAsync(children, rules))]\n      } else if (result !== false) {\n        return toElementArray(result)\n      } else {\n        return []\n      }\n    }))).flat(1)\n    return typeof source === 'string' ? children.join('') : children\n  }\n\n  /** @deprecated use `elements.join('')` instead */\n  export function join(elements: Element[]) {\n    return elements.join('')\n  }\n\n  export type Factory<R extends any[]> = (...args: [...rest: R, attrs?: Dict<any>]) => Element\n\n  function createFactory<R extends any[] = any[]>(type: string, ...keys: string[]): Factory<R> {\n    return (...args: any[]) => {\n      const element = Element(type)\n      keys.forEach((key, index) => {\n        if (!isNullable(args[index])) {\n          element.attrs[key] = args[index]\n        }\n      })\n      if (args[keys.length]) {\n        Object.assign(element.attrs, args[keys.length])\n      }\n      return element\n    }\n  }\n\n  function createAssetFactory(type: string): Factory<[data: string | Buffer | ArrayBuffer]> {\n    return (value, attrs = {}) => {\n      if (is('Buffer', value)) {\n        value = 'base64://' + value.toString('base64')\n      } else if (is('ArrayBuffer', value)) {\n        value = 'base64://' + Buffer.from(value).toString('base64')\n      }\n      return Element(type, { ...attrs, url: value })\n    }\n  }\n\n  export const at = createFactory<[id: any]>('at', 'id')\n  export const sharp = createFactory<[id: any]>('sharp', 'id')\n  export const quote = createFactory<[id: any]>('quote', 'id')\n  export const image = createAssetFactory('image')\n  export const video = createAssetFactory('video')\n  export const audio = createAssetFactory('audio')\n  export const file = createAssetFactory('file')\n}\n\nexport = Element\n"],
  "mappings": ";;;;AAAA,sBAAiG;AAEjG,IAAM,WAAW,OAAO,SAAS;AAEjC,SAAS,UAAU,QAAgC;AACjD,SAAO,UAAU,OAAO,WAAW,YAAY,OAAO;AACxD;AAFS;AAIT,SAAS,UAAU,SAA2B;AAC5C,MAAI,OAAO,YAAY;AAAU,WAAO;AACxC,SAAO,QAAQ,QAAQ,EAAE,QAAQ,CAAC;AACpC;AAHS;AAKT,SAAS,eAAe,OAAyB;AAC/C,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAO,MAAM,IAAI,SAAS;AAAA,EAC5B,WAAW,OAAO,UAAU,UAAU;AACpC,WAAO,CAAC,UAAU,KAAK,CAAC;AAAA,EAC1B,WAAW,CAAC,MAAM,MAAM;AACtB,WAAO,MAAM;AAAA,EACf,OAAO;AACL,WAAO,CAAC,KAAK;AAAA,EACf;AACF;AAVS;AAyBT,IAAM,qBAAN,MAAyB;AAAA,EACvB,IAAI,OAAO;AACT,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,SAAS,QAAQ,OAAO;AACtB,QAAI,KAAK,SAAS;AAAQ,aAAO,QAAQ,OAAO,KAAK,MAAM,OAAO;AAClE,UAAM,QAAQ,KAAK,SAAS,IAAI,WAAS,MAAM,SAAS,KAAK,CAAC,EAAE,KAAK,EAAE;AACvE,QAAI,CAAC,KAAK,QAAQ;AAAO,aAAO;AAChC,UAAM,QAAQ,OAAO,QAAQ,KAAK,KAAK,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AAC7D,cAAI,4BAAW,KAAK;AAAG,eAAO;AAC9B,gBAAM,2BAAU,GAAG;AACnB,UAAI,UAAU;AAAI,eAAO,IAAI;AAC7B,aAAO,IAAI,QAAQ,QAAQ,OAAO,OAAO,IAAI;AAAA,IAC/C,CAAC,EAAE,KAAK,EAAE;AACV,QAAI,CAAC,KAAK,SAAS;AAAQ,aAAO,IAAI,KAAK,OAAO;AAClD,WAAO,IAAI,KAAK,OAAO,SAAS,UAAU,KAAK;AAAA,EACjD;AACF;AAlBM;AAAA,IAoBN,gCAAe,oBAAoB,QAAQ,SAAS;AAAA,IACpD,gCAAe,mBAAmB,WAAW,UAAU,IAAI;AAI3D,SAAS,QAAQ,SAAiB,MAAa;AAC7C,QAAM,KAAK,OAAO,OAAO,mBAAmB,SAAS;AACrD,MAAI,QAAsB,CAAC,GAAG,WAAsB,CAAC;AACrD,MAAI,KAAK,MAAM,OAAO,KAAK,OAAO,YAAY,CAAC,UAAU,KAAK,EAAE,KAAK,CAAC,MAAM,QAAQ,KAAK,EAAE,GAAG;AAC5F,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,KAAK,MAAM,CAAC,GAAG;AACvD,cAAI,4BAAW,KAAK;AAAG;AACvB,UAAI,UAAU,MAAM;AAClB,cAAM,OAAO;AAAA,MACf,WAAW,UAAU,OAAO;AAC1B,cAAM,WAAO,4BAAW,GAAG,KAAK;AAAA,MAClC,OAAO;AACL,cAAM,OAAO,KAAK;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AACA,MAAI,KAAK;AAAI,eAAW,eAAe,KAAK,EAAE;AAC9C,SAAO,OAAO,OAAO,IAAI,EAAE,MAAM,OAAO,SAAS,CAAC;AACpD;AAjBS;AAAA,CAmBT,CAAUA,aAAV;AAMS,WAAS,UAAU,QAAkB;AAC1C,QAAI,OAAO,WAAW;AAAU,aAAO,eAAe,MAAM;AAC5D,WAAOA,SAAQ,MAAM,MAAM;AAAA,EAC7B;AAHO,EAAAA,SAAS;AAAA;AAKT,WAAS,OAAO,QAAgB,SAAS,OAAO;AACrD,UAAM,SAAS,OACZ,QAAQ,MAAM,OAAO,EACrB,QAAQ,MAAM,MAAM,EACpB,QAAQ,MAAM,MAAM;AACvB,WAAO,SACH,OAAO,QAAQ,MAAM,QAAQ,IAC7B;AAAA,EACN;AARO,EAAAA,SAAS;AAAA;AAUT,WAAS,SAAS,QAAgB;AACvC,WAAO,OACJ,QAAQ,SAAS,GAAG,EACpB,QAAQ,SAAS,GAAG,EACpB,QAAQ,WAAW,GAAG,EACtB,QAAQ,UAAU,GAAG;AAAA,EAC1B;AANO,EAAAA,SAAS;AAAA;AAcT,WAAS,KAAK,QAAgB,UAAuB,CAAC,GAAY;AArH3E;AAsHI,UAAM,WAAW,MAAM,MAAM;AAC7B,QAAI,QAAQ,OAAO;AACjB,UAAI,QAAQ,UAAQ,cAAS,OAAT,mBAAa,UAAS,QAAQ;AAAM;AACxD,aAAO,SAAS;AAAA,IAClB;AACA,WAAO,OAAO,UAAU,QAAQ,QAAQ,GAAG,EAAE;AAAA,EAC/C;AAPO,EAAAA,SAAS;AAAA;AAgBhB,QAAM,aAAa;AAEZ,WAAS,cAAc,OAA6B;AACzD,WAAO,MAAM,MAAM,GAAG,EAAE,IAAI,CAAC,UAAU;AACrC,YAAM,YAAwB,CAAC;AAC/B,cAAQ,MAAM,KAAK;AACnB,UAAI,SAA0B,aAAyB;AACvD,aAAQ,UAAU,WAAW,KAAK,KAAK,GAAI;AACzC,kBAAU,KAAK,EAAE,MAAM,MAAM,MAAM,GAAG,QAAQ,KAAK,GAAG,WAAW,CAAC;AAClE,qBAAa,QAAQ;AACrB,gBAAQ,MAAM,MAAM,QAAQ,QAAQ,QAAQ,GAAG,MAAM;AAAA,MACvD;AACA,gBAAU,KAAK,EAAE,MAAM,OAAO,WAAW,CAAC;AAC1C,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAbO,EAAAA,SAAS;AAAA;AAeT,WAAS,OAAO,QAA4B,OAAyC;AAC1F,QAAI,OAAO,WAAW;AAAU,eAAS,MAAM,MAAM;AACrD,QAAI,OAAO,UAAU;AAAU,cAAQ,cAAc,KAAK;AAC1D,QAAI,CAAC,MAAM;AAAQ;AACnB,QAAI,WAAyB,CAAC;AAC9B,UAAM,UAAqB,CAAC;AAC5B,eAAW,CAAC,OAAO,OAAO,KAAK,OAAO,QAAQ,GAAG;AAC/C,YAAM,QAAsB,CAAC;AAC7B,YAAM,QAAQ,CAAC,GAAG,OAAO,GAAG,QAAQ;AACpC,iBAAW,CAAC;AACZ,UAAI,UAAU;AACd,iBAAW,SAAS,OAAO;AACzB,cAAM,EAAE,MAAM,WAAW,IAAI,MAAM;AACnC,YAAI,SAAS,QAAQ,QAAQ,SAAS,KAAK;AACzC,cAAI,MAAM,WAAW,GAAG;AACtB,sBAAU;AAAA,UACZ,WAAW,CAAC,KAAK,GAAG,EAAE,SAAS,MAAM,GAAG,UAAU,GAAG;AACnD,kBAAM,KAAK,MAAM,MAAM,CAAC,CAAC;AAAA,UAC3B,WAAW,MAAM,GAAG,eAAe,KAAK;AACtC,qBAAS,KAAK,MAAM,MAAM,CAAC,CAAC;AAAA,UAC9B,OAAO;AACL,kBAAM,KAAK,MAAM,MAAM,CAAC,CAAC;AAAA,UAC3B;AAAA,QACF;AACA,YAAI,eAAe,KAAK;AACtB,gBAAM,KAAK,KAAK;AAAA,QAClB;AAAA,MACF;AACA,UAAI;AAAS,gBAAQ,KAAK,OAAO,MAAM;AACvC,cAAQ,KAAK,GAAG,OAAO,QAAQ,UAAU,KAAK,CAAC;AAAA,IACjD;AACA,WAAO;AAAA,EACT;AAhCO,EAAAA,SAAS;AAAA;AAkChB,QAAM,YAAY;AAClB,QAAM,aAAa;AAUZ,WAAS,MAAM,QAAgB;AACpC,UAAM,SAA6B,CAAC;AACpC,QAAI;AACJ,WAAQ,SAAS,UAAU,KAAK,MAAM,GAAI;AACxC,UAAI,OAAO,OAAO;AAChB,eAAO,KAAK,SAAS,OAAO,MAAM,GAAG,OAAO,KAAK,CAAC,CAAC;AAAA,MACrD;AACA,YAAM,CAAC,GAAG,OAAO,KAAK,OAAO,KAAK,IAAI;AACtC,YAAM,QAAe,EAAE,QAAQ,GAAG,KAAK,OAAO,OAAO,OAAO,CAAC,EAAE;AAC/D,UAAI;AACJ,aAAQ,UAAU,WAAW,KAAK,KAAK,GAAI;AACzC,cAAM,CAACC,IAAG,KAAK,KAAK,IAAI,KAAK,EAAE,IAAI;AACnC,cAAM,UAAM,0BAAS,GAAG,KAAK,SAAS,EAAE;AAAA,MAC1C;AACA,aAAO,KAAK,KAAK;AACjB,eAAS,OAAO,MAAM,OAAO,QAAQ,OAAO,GAAG,MAAM;AAAA,IACvD;AACA,QAAI;AAAQ,aAAO,KAAK,SAAS,MAAM,CAAC;AACxC,UAAM,QAAQ,CAACD,SAAQ,IAAI,CAAC;AAC5B,aAAS,SAAS,OAAe;AAC/B,aAAO,QAAQ,GAAG,SAAS;AACzB,cAAM,EAAE,SAAS,IAAI,MAAM,MAAM;AACjC,cAAM,EAAE,QAAAE,QAAO,IAAI,MAAM,GAAG,SAAS,IAAI;AACzC,cAAM,GAAG,SAAS,KAAKF,SAAQ,QAAQ,EAAE,SAASE,QAAO,CAAC,CAAC;AAC3D,cAAM,GAAG,SAAS,KAAK,GAAG,QAAQ;AAAA,MACpC;AAAA,IACF;AAPS;AAQT,eAAW,SAAS,QAAQ;AAC1B,UAAI,OAAO,UAAU,UAAU;AAC7B,cAAM,GAAG,SAAS,KAAKF,SAAQ,QAAQ,EAAE,SAAS,MAAM,CAAC,CAAC;AAAA,MAC5D,WAAW,MAAM,OAAO;AACtB,YAAI,QAAQ;AACZ,eAAO,QAAQ,MAAM,UAAU,MAAM,OAAO,SAAS,MAAM;AAAK;AAChE,YAAI,UAAU,MAAM,QAAQ;AAE1B,gBAAM,GAAG,SAAS,KAAKA,SAAQ,QAAQ,EAAE,SAAS,MAAM,OAAO,CAAC,CAAC;AAAA,QACnE,OAAO;AACL,mBAAS,KAAK;AACd,gBAAM,UAAU,MAAM,MAAM;AAC5B,iBAAO,QAAQ;AAAA,QACjB;AAAA,MACF,OAAO;AACL,cAAM,UAAUA,SAAQ,MAAM,KAAK,MAAM,KAAK;AAC9C,cAAM,GAAG,SAAS,KAAK,OAAO;AAC9B,YAAI,CAAC,MAAM,OAAO;AAChB,kBAAQ,SAAS,MAAM;AACvB,gBAAM,QAAQ,OAAO;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AACA,aAAS,MAAM,SAAS,CAAC;AACzB,WAAO,MAAM,GAAG;AAAA,EAClB;AApDO,EAAAA,SAAS;AAAA;AAwDT,WAAS,UAAa,QAA4B,OAA6B,SAAa;AACjG,UAAM,WAAW,OAAO,WAAW,WAAW,MAAM,MAAM,IAAI;AAC9D,UAAM,SAAoB,CAAC;AAC3B,aAAS,QAAQ,CAAC,YAAY;AA9PlC;AA+PM,YAAM,EAAE,MAAM,OAAO,SAAS,IAAI;AAClC,UAAI,UAAS,iBAAM,UAAN,YAAe,MAAM,YAArB,YAAgC;AAC7C,UAAI,OAAO,WAAW,YAAY;AAChC,iBAAS,OAAO,OAAO,UAAU,OAAO;AAAA,MAC1C;AACA,UAAI,WAAW,MAAM;AACnB,eAAO,KAAKA,SAAQ,MAAM,OAAO,UAAU,UAAU,KAAK,CAAC,CAAC;AAAA,MAC9D,WAAW,WAAW,OAAO;AAC3B,eAAO,KAAK,GAAG,eAAe,MAAM,CAAC;AAAA,MACvC;AAAA,IACF,CAAC;AACD,WAAO,OAAO,WAAW,WAAW,OAAO,KAAK,EAAE,IAAI;AAAA,EACxD;AAhBO,EAAAA,SAAS;AAAA;AAoBhB,iBAAsB,eAAkB,QAA4B,OAAkC,SAAa;AACjH,UAAM,WAAW,OAAO,WAAW,WAAW,MAAM,MAAM,IAAI;AAC9D,UAAM,YAAY,MAAM,QAAQ,IAAI,SAAS,IAAI,OAAO,YAAY;AAjRxE;AAkRM,YAAM,EAAE,MAAM,OAAO,UAAAG,UAAS,IAAI;AAClC,UAAI,UAAS,iBAAM,UAAN,YAAe,MAAM,YAArB,YAAgC;AAC7C,UAAI,OAAO,WAAW,YAAY;AAChC,iBAAS,MAAM,OAAO,OAAOA,WAAU,OAAO;AAAA,MAChD;AACA,UAAI,WAAW,MAAM;AACnB,eAAO,CAACH,SAAQ,MAAM,OAAO,MAAM,eAAeG,WAAU,KAAK,CAAC,CAAC;AAAA,MACrE,WAAW,WAAW,OAAO;AAC3B,eAAO,eAAe,MAAM;AAAA,MAC9B,OAAO;AACL,eAAO,CAAC;AAAA,MACV;AAAA,IACF,CAAC,CAAC,GAAG,KAAK,CAAC;AACX,WAAO,OAAO,WAAW,WAAW,SAAS,KAAK,EAAE,IAAI;AAAA,EAC1D;AAjBA,EAAAH,SAAsB;AAAA;AAoBf,WAAS,KAAK,UAAqB;AACxC,WAAO,SAAS,KAAK,EAAE;AAAA,EACzB;AAFO,EAAAA,SAAS;AAAA;AAMhB,WAAS,cAAuC,SAAiB,MAA4B;AAC3F,WAAO,IAAI,SAAgB;AACzB,YAAM,UAAUA,SAAQ,IAAI;AAC5B,WAAK,QAAQ,CAAC,KAAK,UAAU;AAC3B,YAAI,KAAC,4BAAW,KAAK,MAAM,GAAG;AAC5B,kBAAQ,MAAM,OAAO,KAAK;AAAA,QAC5B;AAAA,MACF,CAAC;AACD,UAAI,KAAK,KAAK,SAAS;AACrB,eAAO,OAAO,QAAQ,OAAO,KAAK,KAAK,OAAO;AAAA,MAChD;AACA,aAAO;AAAA,IACT;AAAA,EACF;AAbS;AAeT,WAAS,mBAAmB,MAA8D;AACxF,WAAO,CAAC,OAAO,QAAQ,CAAC,MAAM;AAC5B,cAAI,oBAAG,UAAU,KAAK,GAAG;AACvB,gBAAQ,cAAc,MAAM,SAAS,QAAQ;AAAA,MAC/C,eAAW,oBAAG,eAAe,KAAK,GAAG;AACnC,gBAAQ,cAAc,OAAO,KAAK,KAAK,EAAE,SAAS,QAAQ;AAAA,MAC5D;AACA,aAAOA,SAAQ,MAAM,EAAE,GAAG,OAAO,KAAK,MAAM,CAAC;AAAA,IAC/C;AAAA,EACF;AATS;AAWF,EAAMA,SAAA,KAAK,cAAyB,MAAM,IAAI;AAC9C,EAAMA,SAAA,QAAQ,cAAyB,SAAS,IAAI;AACpD,EAAMA,SAAA,QAAQ,cAAyB,SAAS,IAAI;AACpD,EAAMA,SAAA,QAAQ,mBAAmB,OAAO;AACxC,EAAMA,SAAA,QAAQ,mBAAmB,OAAO;AACxC,EAAMA,SAAA,QAAQ,mBAAmB,OAAO;AACxC,EAAMA,SAAA,OAAO,mBAAmB,MAAM;AAAA,GAvPrC;AA0PV,iBAAS;",
  "names": ["Element", "_", "source", "children"]
}
