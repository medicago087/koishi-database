var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// satori/adapters/telegram/src/index.ts
var src_exports = {};
__export(src_exports, {
  HttpPolling: () => HttpPolling,
  HttpServer: () => HttpServer,
  Internal: () => Internal,
  SenderError: () => SenderError,
  Telegram: () => types_exports,
  TelegramBot: () => TelegramBot,
  TelegramMessenger: () => TelegramMessenger,
  adaptGuildMember: () => adaptGuildMember,
  adaptUser: () => adaptUser,
  default: () => src_default,
  handleUpdate: () => handleUpdate
});
module.exports = __toCommonJS(src_exports);

// satori/adapters/telegram/src/bot.ts
var import_satori5 = require("@satorijs/satori");

// satori/adapters/telegram/src/types/index.ts
var types_exports = {};
__export(types_exports, {
  Internal: () => Internal
});

// satori/adapters/telegram/src/types/internal.ts
var import_form_data = __toESM(require("form-data"));
var import_reggol = __toESM(require("reggol"));
var logger = new import_reggol.default("telegram");
var Internal = class {
  constructor(http) {
    this.http = http;
  }
  static define(method) {
    Internal.prototype[method] = async function(data = {}) {
      var _a, _b;
      logger.debug("[request] %s %o", method, data);
      try {
        let response;
        if (data instanceof import_form_data.default) {
          response = await this.http.post("/" + method, data, {
            headers: data.getHeaders()
          });
        } else {
          response = await this.http.post("/" + method, data);
        }
        logger.debug("[response] %o", response);
        const { ok, result } = response;
        if (ok)
          return result;
        throw new Error(`Telegram API error ${response.data.error_code}. ${response.data.description}`);
      } catch (err) {
        if (((_b = (_a = err.response) == null ? void 0 : _a.data) == null ? void 0 : _b.error_code) && err.response.data.description) {
          throw new Error(`Telegram API error ${err.response.data.error_code}. ${err.response.data.description}`);
        } else {
          throw err;
        }
      }
    };
  }
};
__name(Internal, "Internal");

// satori/adapters/telegram/src/types/inline.ts
Internal.define("answerInlineQuery");

// satori/adapters/telegram/src/types/game.ts
Internal.define("sendGame");
Internal.define("setGameScore");
Internal.define("getGameHighScores");

// satori/adapters/telegram/src/types/passport.ts
Internal.define("setPassportDataErrors");

// satori/adapters/telegram/src/types/payment.ts
Internal.define("sendInvoice");
Internal.define("answerShippingQuery");
Internal.define("answerPreCheckoutQuery");

// satori/adapters/telegram/src/types/sticker.ts
Internal.define("sendSticker");
Internal.define("getStickerSet");
Internal.define("uploadStickerFile");
Internal.define("createNewStickerSet");
Internal.define("addStickerToSet");
Internal.define("setStickerPositionInSet");
Internal.define("deleteStickerFromSet");
Internal.define("setStickerSetThumb");

// satori/adapters/telegram/src/types/update.ts
Internal.define("getUpdates");
Internal.define("setWebhook");
Internal.define("deleteWebhook");
Internal.define("getWebhookInfo");

// satori/adapters/telegram/src/types/index.ts
Internal.define("getMe");
Internal.define("logOut");
Internal.define("close");
Internal.define("sendMessage");
Internal.define("forwardMessage");
Internal.define("copyMessage");
Internal.define("sendPhoto");
Internal.define("sendAudio");
Internal.define("sendDocument");
Internal.define("sendVideo");
Internal.define("sendAnimation");
Internal.define("sendVoice");
Internal.define("sendVideoNote");
Internal.define("sendMediaGroup");
Internal.define("sendLocation");
Internal.define("editMessageLiveLocation");
Internal.define("stopMessageLiveLocation");
Internal.define("sendVenue");
Internal.define("sendContact");
Internal.define("sendPoll");
Internal.define("sendDice");
Internal.define("sendChatAction");
Internal.define("getUserProfilePhotos");
Internal.define("getFile");
Internal.define("banChatMember");
Internal.define("unbanChatMember");
Internal.define("restrictChatMember");
Internal.define("promoteChatMember");
Internal.define("setChatAdministratorCustomTitle");
Internal.define("banChatSenderChat");
Internal.define("unbanChatSenderChat");
Internal.define("setChatPermissions");
Internal.define("exportChatInviteLink");
Internal.define("createChatInviteLink");
Internal.define("editChatInviteLink");
Internal.define("revokeChatInviteLink");
Internal.define("approveChatJoinRequest");
Internal.define("declineChatJoinRequest");
Internal.define("setChatPhoto");
Internal.define("deleteChatPhoto");
Internal.define("setChatTitle");
Internal.define("setChatDescription");
Internal.define("pinChatMessage");
Internal.define("unpinChatMessage");
Internal.define("unpinAllChatMessages");
Internal.define("leaveChat");
Internal.define("getChat");
Internal.define("getChatAdministrators");
Internal.define("getChatMemberCount");
Internal.define("getChatMember");
Internal.define("setChatStickerSet");
Internal.define("deleteChatStickerSet");
Internal.define("answerCallbackQuery");
Internal.define("setMyCommands");
Internal.define("deleteMyCommands");
Internal.define("getMyCommands");
Internal.define("editMessageText");
Internal.define("editMessageCaption");
Internal.define("editMessageMedia");
Internal.define("editMessageReplyMarkup");
Internal.define("stopPoll");
Internal.define("deleteMessage");

// satori/adapters/telegram/src/utils.ts
var import_satori = require("@satorijs/satori");
var logger2 = new import_satori.Logger("telegram");
var adaptUser = /* @__PURE__ */ __name((data) => ({
  userId: data.id.toString(),
  username: data.username,
  nickname: data.first_name + (data.last_name ? " " + data.last_name : ""),
  isBot: data.is_bot
}), "adaptUser");
var adaptGuildMember = /* @__PURE__ */ __name((data) => adaptUser(data.user), "adaptGuildMember");
async function handleUpdate(update, bot) {
  logger2.debug("receive %s", JSON.stringify(update));
  const session = bot.session();
  (0, import_satori.defineProperty)(session, "telegram", Object.create(bot.internal));
  Object.assign(session.telegram, update);
  const message = update.message || update.edited_message || update.channel_post || update.edited_channel_post;
  if (message) {
    session.type = update.message || update.channel_post ? "message" : "message-updated";
    await bot.adaptMessage(message, session);
  } else if (update.chat_join_request) {
    session.timestamp = update.chat_join_request.date * 1e3;
    session.type = "guild-member-request";
    session.messageId = `${update.chat_join_request.chat.id}@${update.chat_join_request.from.id}`;
    session.content = "";
    session.channelId = update.chat_join_request.chat.id.toString();
    session.guildId = session.channelId;
  } else if (update.my_chat_member) {
    session.timestamp = update.my_chat_member.date * 1e3;
    session.messageId = `${update.my_chat_member.chat.id}@${update.my_chat_member.from.id}`;
    session.content = "";
    session.channelId = update.my_chat_member.chat.id.toString();
    session.guildId = session.channelId;
    if (update.my_chat_member.old_chat_member.user.id.toString() === bot.selfId) {
      if (update.my_chat_member.new_chat_member.status === "left") {
        session.type = "group-deleted";
      } else if (update.my_chat_member.old_chat_member.status === "left") {
        session.type = "group-added";
      }
    }
  } else {
    const subtype = Object.keys(update).filter((v) => v !== "update_id")[0];
    if (subtype) {
      session.type = "telegram";
      session.subtype = (0, import_satori.hyphenate)(subtype);
    }
  }
  bot.dispatch(session);
}
__name(handleUpdate, "handleUpdate");

// satori/adapters/telegram/src/message.ts
var import_fs = require("fs");
var import_url = require("url");
var import_satori2 = require("@satorijs/satori");
var import_file_type = require("file-type");
var import_form_data2 = __toESM(require("form-data"));
var logger3 = new import_satori2.Logger("telegram");
async function maybeFile(payload, field) {
  if (!payload[field])
    return [];
  let content;
  let filename = "file";
  const { protocol } = new URL(payload[field]);
  let data = payload[field].split("://")[1];
  if (protocol === "file:") {
    content = (0, import_fs.createReadStream)((0, import_url.fileURLToPath)(payload[field]));
    delete payload[field];
  } else if (protocol === "base64:") {
    content = Buffer.from(data, "base64");
    delete payload[field];
  } else if (protocol === "data:") {
    data = payload[field].split("base64,")[1];
    content = Buffer.from(data, "base64");
    delete payload[field];
  }
  if (field === "document" && (protocol === "base64:" || protocol === "data:")) {
    const type = await (0, import_file_type.fromBuffer)(content);
    if (!type) {
      logger3.warn("Can not infer file mime");
    } else
      filename = `file.${type.ext}`;
  }
  return [field, content, filename];
}
__name(maybeFile, "maybeFile");
async function isGif(url) {
  if (url.toLowerCase().endsWith(".gif"))
    return true;
  const { protocol } = new URL(url);
  let data;
  if (protocol === "base64:") {
    data = url.split("://")[1];
  } else if (protocol === "data:") {
    data = url.split("base64,")[1];
  }
  if (data) {
    const type = await (0, import_file_type.fromBuffer)(Buffer.from(data, "base64"));
    if (!type) {
      logger3.warn("Can not infer file mime");
    } else if (type.ext === "gif")
      return true;
  }
  return false;
}
__name(isGif, "isGif");
var assetApi = {
  photo: "sendPhoto",
  audio: "sendAudio",
  document: "sendDocument",
  video: "sendVideo",
  animation: "sendAnimation"
};
var supportedElements = ["b", "strong", "i", "em", "u", "ins", "s", "del", "a"];
var TelegramMessenger = class extends import_satori2.Messenger {
  constructor(bot, channelId, guildId) {
    super(bot, channelId, guildId);
    this.assetType = null;
    this.mode = "default";
    const chat_id = channelId.startsWith("private:") ? channelId.slice(8) : channelId;
    this.payload = { chat_id, parse_mode: "html", caption: "" };
  }
  async addResult(result) {
    const session = this.bot.session();
    await this.bot.adaptMessage(result, session);
    this.results.push(session);
    session.app.emit(session, "send", session);
  }
  async sendAsset() {
    const [field, content, filename] = await maybeFile(this.payload, this.assetType);
    const payload = new import_form_data2.default();
    for (const key in this.payload) {
      payload.append(key, this.payload[key].toString());
    }
    if (field && content)
      payload.append(field, content, filename);
    const result = await this.bot.internal[assetApi[this.assetType]](payload);
    await this.addResult(result);
    delete this.payload[this.assetType];
    delete this.payload.reply_to_message;
    this.assetType = null;
    this.payload.caption = "";
  }
  async flush() {
    if (this.assetType) {
      await this.sendAsset();
    } else if (this.payload.caption) {
      const result = await this.bot.internal.sendMessage({
        chat_id: this.payload.chat_id,
        text: this.payload.caption,
        parse_mode: this.payload.parse_mode,
        reply_to_message_id: this.payload.reply_to_message_id
      });
      await this.addResult(result);
      delete this.payload.reply_to_message;
      this.payload.caption = "";
    }
  }
  async visit(element) {
    const { type, attrs, children } = element;
    if (type === "text") {
      this.payload.caption += import_satori2.segment.escape(attrs.content);
    } else if (type === "p") {
      await this.render(children);
      this.payload.caption += "\n";
    } else if (supportedElements.includes(type)) {
      this.payload.caption += element.toString();
    } else if (type === "spl") {
      this.payload.caption += "<tg-spoiler>";
      await this.render(children);
      this.payload.caption += "</tg-spoiler>";
    } else if (type === "code") {
      const { lang } = attrs;
      this.payload.caption += `<code${lang ? ` class="language-${lang}"` : ""}>${import_satori2.segment.escape(attrs.content)}</code>`;
    } else if (type === "at") {
      if (attrs.id) {
        this.payload.caption += `<a href="tg://user?id=${attrs.id}">@${attrs.name || attrs.id}</a>`;
      }
    } else if (["image", "audio", "video", "file"].includes(type)) {
      if (this.mode === "default") {
        await this.flush();
      }
      if (type === "image") {
        this.assetType = await isGif(attrs.url) ? "animation" : "photo";
      } else if (type === "file") {
        this.assetType = "document";
      } else {
        this.assetType = type;
      }
      this.payload[this.assetType] = attrs.url;
    } else if (type === "figure") {
      await this.flush();
      this.mode = "figure";
      await this.render(children);
      await this.flush();
      this.mode = "default";
    } else if (type === "quote") {
      await this.flush();
      this.payload.reply_to_message_id = attrs.id;
    } else if (type === "message") {
      if (this.mode === "figure") {
        await this.render(children);
        this.payload.caption += "\n";
      } else {
        await this.flush();
        await this.render(children);
        await this.flush();
      }
    } else {
      await this.render(children);
    }
  }
};
__name(TelegramMessenger, "TelegramMessenger");

// satori/adapters/telegram/src/server.ts
var import_satori3 = require("@satorijs/satori");
var import_cosmokit = require("cosmokit");
var logger4 = new import_satori3.Logger("telegram");
var HttpServer = class extends import_satori3.Adapter.Server {
  async start(bot) {
    let { token, path, selfUrl } = bot.config;
    path = (0, import_cosmokit.sanitize)(path || "/telegram");
    if (selfUrl) {
      selfUrl = (0, import_cosmokit.trimSlash)(selfUrl);
    } else {
      selfUrl = bot.ctx.root.config.selfUrl;
    }
    bot.ctx.router.post(path, async (ctx) => {
      var _a;
      const payload = ctx.request.body;
      const token2 = ctx.request.query.token;
      const [selfId] = token2.split(":");
      const bot2 = this.bots.find((bot3) => bot3.selfId === selfId);
      if (!(((_a = bot2 == null ? void 0 : bot2.config) == null ? void 0 : _a.token) === token2))
        return ctx.status = 403;
      ctx.body = "OK";
      await handleUpdate(payload, bot2);
    });
    bot.initialize(async (bot2) => {
      const info = await bot2.internal.setWebhook({
        url: selfUrl + path + "?token=" + token,
        drop_pending_updates: true
      });
      if (!info)
        throw new Error("Set webhook failed");
      logger4.debug("listening updates %c", "telegram: " + bot2.selfId);
    });
  }
  async stop() {
    logger4.debug("http server closing");
  }
};
__name(HttpServer, "HttpServer");
((HttpServer2) => {
  HttpServer2.Config = import_satori3.Schema.object({
    protocol: import_satori3.Schema.const("server").required(),
    path: import_satori3.Schema.string().description("服务器监听的路径。").default("/telegram"),
    selfUrl: import_satori3.Schema.string().role("link").description("服务器暴露在公网的地址。缺省时将使用全局配置。")
  });
})(HttpServer || (HttpServer = {}));

// satori/adapters/telegram/src/polling.ts
var import_satori4 = require("@satorijs/satori");
var logger5 = new import_satori4.Logger("telegram");
var HttpPolling = class extends import_satori4.Adapter.Client {
  constructor() {
    super(...arguments);
    this.offset = 0;
  }
  async start(bot) {
    bot.initialize(async () => {
      let _retryCount = 0;
      let _initial = true;
      const { retryTimes, retryInterval } = bot.config;
      const { url } = await bot.internal.getWebhookInfo();
      if (url) {
        logger5.warn("Bot currently has a webhook set up, trying to remove it...");
        await bot.internal.setWebhook({ url: "" });
      }
      const previousUpdates = await bot.internal.getUpdates({
        allowed_updates: [],
        timeout: 0
      });
      previousUpdates.forEach((e) => {
        this.offset = Math.max(this.offset, e.update_id);
      });
      const polling = /* @__PURE__ */ __name(async () => {
        var _a;
        if (bot.status === "disconnect") {
          return bot.offline();
        }
        try {
          const updates = await bot.internal.getUpdates({
            offset: this.offset + 1,
            timeout: bot.config.pollingTimeout
          });
          bot.online();
          _retryCount = 0;
          _initial = false;
          for (const e of updates) {
            this.offset = Math.max(this.offset, e.update_id);
            handleUpdate(e, bot);
          }
          setTimeout(polling, 0);
        } catch (e) {
          if (!import_satori4.Quester.isAxiosError(e) || !((_a = e.response) == null ? void 0 : _a.data)) {
            logger5.warn("failed to get updates. reason: %s", e.message);
          } else {
            const { error_code, description } = e.response.data;
            logger5.warn("failed to get updates: %c %s", error_code, description);
          }
          if (_initial && _retryCount > retryTimes) {
            bot.error = e;
            return bot.status = "offline";
          }
          _retryCount++;
          bot.status = "reconnect";
          setTimeout(() => polling(), retryInterval);
        }
      }, "polling");
      polling();
      logger5.debug("listening updates %c", "telegram: " + bot.selfId);
    });
  }
  async stop() {
  }
};
__name(HttpPolling, "HttpPolling");
((HttpPolling2) => {
  HttpPolling2.Config = import_satori4.Schema.object({
    protocol: import_satori4.Schema.const("polling").required(),
    pollingTimeout: import_satori4.Schema.natural().role("time").default(import_satori4.Time.minute).description("通过长轮询获取更新时请求的超时 (单位为秒)。"),
    retryTimes: import_satori4.Schema.natural().description("初次连接时的最大重试次数。").default(6),
    retryInterval: import_satori4.Schema.natural().role("ms").default(import_satori4.Time.second * 5).description("长轮询断开后的重试时间间隔 (单位为毫秒)。")
  });
})(HttpPolling || (HttpPolling = {}));

// satori/adapters/telegram/src/bot.ts
var import_file_type2 = require("file-type");
var import_fs2 = __toESM(require("fs"));
var logger6 = new import_satori5.Logger("telegram");
var SenderError = class extends Error {
  constructor(args, url, retcode, selfId) {
    super(`Error when trying to send to ${url}, args: ${JSON.stringify(args)}, retcode: ${retcode}`);
    Object.defineProperties(this, {
      name: { value: "SenderError" },
      selfId: { value: selfId },
      code: { value: retcode },
      args: { value: args },
      url: { value: url }
    });
  }
};
__name(SenderError, "SenderError");
var TelegramBot = class extends import_satori5.Bot {
  constructor(ctx, config) {
    var _a;
    super(ctx, config);
    this.selfId = config.token.split(":")[0];
    this.local = config.files.local;
    this.http = this.ctx.http.extend({
      ...config,
      endpoint: `${config.endpoint}/bot${config.token}`
    });
    this.file = this.ctx.http.extend({
      ...config,
      endpoint: `${config.files.endpoint || config.endpoint}/file/bot${config.token}`
    });
    this.internal = new Internal(this.http);
    if (config.protocol === "server") {
      ctx.plugin(HttpServer, this);
    } else if (config.protocol === "polling") {
      ctx.plugin(HttpPolling, this);
    }
    const selfUrl = config["selfUrl"] || ctx.root.config.selfUrl;
    if ((_a = config.files.server) != null ? _a : selfUrl) {
      const route = `/telegram/${this.selfId}`;
      this.server = selfUrl + route;
      ctx.router.get(route + "/:file+", async (ctx2) => {
        const { buffer, mime } = await this.$getFile(ctx2.params.file);
        ctx2.set("content-type", mime);
        ctx2.body = buffer;
      });
    }
  }
  async initialize(callback) {
    const { username, userId, avatar, nickname } = await this.getLoginInfo();
    this.username = username;
    this.avatar = avatar;
    this.selfId = userId;
    this.nickname = nickname;
    await callback(this);
    logger6.debug("connected to %c", "telegram:" + this.selfId);
    this.online();
  }
  async adaptMessage(message, session) {
    const parseText = /* @__PURE__ */ __name((text, entities) => {
      let curr = 0;
      const segs = [];
      for (const e of entities) {
        const eText = text.substr(e.offset, e.length);
        if (e.type === "mention") {
          if (eText[0] !== "@")
            throw new Error("Telegram mention does not start with @: " + eText);
          const atName = eText.slice(1);
          if (eText === "@" + this.username) {
            segs.push((0, import_satori5.segment)("at", { id: this.selfId, name: atName }));
          } else {
            segs.push((0, import_satori5.segment)("text", { content: eText }));
          }
        } else if (e.type === "text_mention") {
          segs.push((0, import_satori5.segment)("at", { id: e.user.id }));
        } else {
          continue;
        }
        if (e.offset > curr) {
          segs.splice(-1, 0, (0, import_satori5.segment)("text", { content: text.slice(curr, e.offset) }));
          curr = e.offset + e.length;
        }
      }
      if (curr < (text == null ? void 0 : text.length) || 0) {
        segs.push((0, import_satori5.segment)("text", { content: text.slice(curr) }));
      }
      return segs;
    }, "parseText");
    session.messageId = message.message_id.toString();
    session.timestamp = message.date * 1e3;
    const segments = [];
    if (message.reply_to_message) {
      session.quote = {};
      await this.adaptMessage(message.reply_to_message, session.quote);
    }
    const msgText = message.text || message.caption;
    segments.push(...parseText(msgText, message.entities || []));
    if (message.caption) {
      segments.push((0, import_satori5.segment)("text", { content: " " }));
    }
    if (message.location) {
      segments.push((0, import_satori5.segment)("location", { lat: message.location.latitude, lon: message.location.longitude }));
    }
    if (message.photo) {
      const photo = message.photo.sort((s1, s2) => s2.file_size - s1.file_size)[0];
      segments.push((0, import_satori5.segment)("image", await this.$getFileFromId(photo.file_id)));
    }
    if (message.sticker) {
      try {
        const file = await this.internal.getFile({ file_id: message.sticker.file_id });
        if (file.file_path.endsWith(".tgs")) {
          throw new Error("tgs is not supported now");
        }
        segments.push((0, import_satori5.segment)("image", await this.$getFileFromPath(file.file_path)));
      } catch (e) {
        logger6.warn("get file error", e);
        segments.push((0, import_satori5.segment)("text", { content: `[${message.sticker.set_name || "sticker"} ${message.sticker.emoji || ""}]` }));
      }
    } else if (message.animation) {
      segments.push((0, import_satori5.segment)("image", await this.$getFileFromId(message.animation.file_id)));
    } else if (message.voice) {
      segments.push((0, import_satori5.segment)("audio", await this.$getFileFromId(message.voice.file_id)));
    } else if (message.video) {
      segments.push((0, import_satori5.segment)("video", await this.$getFileFromId(message.video.file_id)));
    } else if (message.document) {
      segments.push((0, import_satori5.segment)("file", await this.$getFileFromId(message.document.file_id)));
    }
    session.content = segments.join("");
    session.userId = message.from.id.toString();
    session.author = adaptUser(message.from);
    session.channelId = message.chat.id.toString();
    if (message.chat.type === "private") {
      session.subtype = "private";
      session.channelId = "private:" + session.channelId;
    } else {
      session.subtype = "group";
      session.guildId = session.channelId;
    }
  }
  async sendMessage(channelId, fragment, guildId) {
    return new TelegramMessenger(this, channelId, guildId).send(fragment);
  }
  async sendPrivateMessage(userId, content) {
    return this.sendMessage("private:" + userId, content);
  }
  async getMessage() {
    return null;
  }
  async deleteMessage(chat_id, message_id) {
    message_id = +message_id;
    await this.internal.deleteMessage({ chat_id, message_id });
  }
  static adaptGroup(data) {
    data["guildId"] = data.id + "";
    data["guildName"] = data.title;
    delete data.id;
    delete data.title;
    return data;
  }
  async getGuild(chat_id) {
    const data = await this.internal.getChat({ chat_id });
    return TelegramBot.adaptGroup(data);
  }
  async getGuildList() {
    return [];
  }
  async getGuildMember(chat_id, user_id) {
    user_id = +user_id;
    if (Number.isNaN(user_id))
      return null;
    const data = await this.internal.getChatMember({ chat_id, user_id });
    const user = adaptGuildMember(data);
    await this.setAvatarUrl(user);
    return user;
  }
  async getGuildMemberList(chat_id) {
    const data = await this.internal.getChatAdministrators({ chat_id });
    const users = data.map(adaptGuildMember);
    await Promise.all(users.map(this.setAvatarUrl.bind(this)));
    return users;
  }
  async kickGuildMember(chat_id, user_id, permanent) {
    user_id = +user_id;
    await this.internal.banChatMember({
      chat_id,
      user_id,
      until_date: Date.now() + (permanent ? 0 : import_satori5.Time.minute),
      revoke_messages: true
    });
  }
  setGroupLeave(chat_id) {
    return this.internal.leaveChat({ chat_id });
  }
  async handleGuildMemberRequest(messageId, approve, comment) {
    const [chat_id, user_id] = messageId.split("@");
    const method = approve ? "approveChatJoinRequest" : "declineChatJoinRequest";
    const success = await this.internal[method]({ chat_id, user_id: +user_id });
    if (!success)
      throw new Error(`handel guild member request field ${success}`);
  }
  async getLoginInfo() {
    const data = await this.internal.getMe();
    const user = adaptUser(data);
    await this.setAvatarUrl(user);
    return user;
  }
  async $getFile(filePath) {
    let buffer;
    if (this.local) {
      buffer = await import_fs2.default.promises.readFile(filePath);
    } else {
      buffer = await this.file.get(`/${filePath}`, { responseType: "arraybuffer" });
    }
    const { mime } = await (0, import_file_type2.fromBuffer)(buffer);
    return { mime, buffer };
  }
  async $getFileFromId(file_id) {
    try {
      const file = await this.internal.getFile({ file_id });
      return await this.$getFileFromPath(file.file_path);
    } catch (e) {
      logger6.warn("get file error", e);
    }
  }
  async $getFileFromPath(filePath) {
    if (this.server) {
      return { url: `${this.server}/${filePath}` };
    }
    const { mime, buffer } = await this.$getFile(filePath);
    const base64 = `data:${mime};base64,` + buffer.toString("base64");
    return { url: base64 };
  }
  async setAvatarUrl(user) {
    const { photos: [avatar] } = await this.internal.getUserProfilePhotos({ user_id: +user.userId });
    if (!avatar)
      return;
    const { file_id } = avatar[avatar.length - 1];
    const file = await this.internal.getFile({ file_id });
    if (this.server) {
      user.avatar = `${this.server}/${file.file_path}`;
    } else {
      const { endpoint } = this.file.config;
      user.avatar = `${endpoint}/${file.file_path}`;
    }
  }
};
__name(TelegramBot, "TelegramBot");
TelegramBot.prototype.platform = "telegram";
((TelegramBot2) => {
  TelegramBot2.Config = import_satori5.Schema.intersect([
    import_satori5.Schema.object({
      token: import_satori5.Schema.string().description("机器人的用户令牌。").role("secret").required(),
      protocol: import_satori5.Schema.union(["server", "polling"]).description("选择要使用的协议。").required()
    }),
    import_satori5.Schema.union([
      HttpServer.Config,
      HttpPolling.Config
    ]).description("推送设置"),
    import_satori5.Quester.createConfig("https://api.telegram.org"),
    import_satori5.Schema.object({
      files: import_satori5.Schema.object({
        endpoint: import_satori5.Schema.string().description("文件请求的终结点。"),
        local: import_satori5.Schema.boolean().description("是否启用 [Telegram Bot API](https://github.com/tdlib/telegram-bot-api) 本地模式。"),
        server: import_satori5.Schema.boolean().description("是否启用文件代理。若开启将会使用 `selfUrl` 进行反代，否则会下载所有资源文件 (包括图片、视频等)。当配置了 `selfUrl` 时将默认开启。")
      })
    }).description("文件设置")
  ]);
})(TelegramBot || (TelegramBot = {}));

// satori/adapters/telegram/src/index.ts
var src_default = TelegramBot;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  HttpPolling,
  HttpServer,
  Internal,
  SenderError,
  Telegram,
  TelegramBot,
  TelegramMessenger,
  adaptGuildMember,
  adaptUser,
  handleUpdate
});
//# sourceMappingURL=index.js.map
