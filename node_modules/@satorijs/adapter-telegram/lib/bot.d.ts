/// <reference types="node" />
import { Bot, Context, Dict, Fragment, Quester, Schema, Session, Universal } from '@satorijs/satori';
import * as Telegram from './types';
import { HttpServer } from './server';
import { HttpPolling } from './polling';
export declare class SenderError extends Error {
    constructor(args: Dict<any>, url: string, retcode: number, selfId: string);
}
export interface TelegramResponse {
    ok: boolean;
    result: any;
}
export declare class TelegramBot<T extends TelegramBot.Config = TelegramBot.Config> extends Bot<T> {
    http: Quester;
    file: Quester;
    internal?: Telegram.Internal;
    local?: boolean;
    server?: string;
    constructor(ctx: Context, config: T);
    initialize(callback: (bot: this) => Promise<void>): Promise<void>;
    adaptMessage(message: Telegram.Message, session: Session): Promise<void>;
    sendMessage(channelId: string, fragment: Fragment, guildId?: string): any;
    sendPrivateMessage(userId: string, content: Fragment): any;
    getMessage(): Promise<any>;
    deleteMessage(chat_id: string, message_id: string | number): Promise<void>;
    static adaptGroup(data: Telegram.Chat): Universal.Guild;
    getGuild(chat_id: string): Promise<Universal.Guild>;
    getGuildList(): Promise<any[]>;
    getGuildMember(chat_id: string, user_id: string | number): Promise<Universal.GuildMember>;
    getGuildMemberList(chat_id: string): Promise<Universal.GuildMember[]>;
    kickGuildMember(chat_id: string, user_id: string | number, permanent?: boolean): Promise<void>;
    setGroupLeave(chat_id: string): Promise<boolean>;
    handleGuildMemberRequest(messageId: string, approve: boolean, comment?: string): Promise<void>;
    getLoginInfo(): Promise<Universal.User>;
    $getFile(filePath: string): Promise<{
        mime: import("file-type/core").MimeType;
        buffer: Buffer;
    }>;
    $getFileFromId(file_id: string): Promise<{
        url: string;
    }>;
    $getFileFromPath(filePath: string): Promise<{
        url: string;
    }>;
    private setAvatarUrl;
}
export declare namespace TelegramBot {
    interface BaseConfig extends Bot.Config, Quester.Config {
        protocol: 'server' | 'polling';
        token: string;
        files?: Config.Files;
    }
    type Config = BaseConfig & (HttpServer.Config | HttpPolling.Config);
    namespace Config {
        interface Files {
            endpoint?: string;
            local?: boolean;
            server?: boolean;
        }
    }
    const Config: Schema<Config>;
}
