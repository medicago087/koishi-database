var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// satori/adapters/onebot/src/index.ts
var src_exports = {};
__export(src_exports, {
  BaseBot: () => BaseBot,
  CQCode: () => CQCode,
  HttpServer: () => HttpServer,
  OneBot: () => utils_exports,
  OneBotBot: () => OneBotBot,
  QQGuildBot: () => QQGuildBot,
  WsClient: () => WsClient,
  WsServer: () => WsServer,
  accept: () => accept,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// satori/adapters/onebot/src/bot/index.ts
var import_satori8 = require("@satorijs/satori");

// satori/adapters/onebot/src/http.ts
var import_satori3 = require("@satorijs/satori");

// satori/adapters/onebot/src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  Internal: () => Internal,
  SafetyLevel: () => SafetyLevel,
  TimeoutError: () => TimeoutError,
  adaptAuthor: () => adaptAuthor,
  adaptChannel: () => adaptChannel,
  adaptGuild: () => adaptGuild,
  adaptGuildMember: () => adaptGuildMember,
  adaptMessage: () => adaptMessage,
  adaptQQGuildMemberInfo: () => adaptQQGuildMemberInfo,
  adaptQQGuildMemberProfile: () => adaptQQGuildMemberProfile,
  adaptSession: () => adaptSession,
  adaptUser: () => adaptUser,
  dispatchSession: () => dispatchSession
});
var import_satori2 = require("@satorijs/satori");
var qface = __toESM(require("qface"));

// satori/adapters/onebot/src/types.ts
var import_satori = require("@satorijs/satori");
var SafetyLevel = /* @__PURE__ */ ((SafetyLevel2) => {
  SafetyLevel2[SafetyLevel2["safe"] = 0] = "safe";
  SafetyLevel2[SafetyLevel2["unknown"] = 1] = "unknown";
  SafetyLevel2[SafetyLevel2["danger"] = 2] = "danger";
  return SafetyLevel2;
})(SafetyLevel || {});
var TimeoutError = class extends Error {
  constructor(args, url) {
    super(`Timeout with request ${url}, args: ${JSON.stringify(args)}`);
    Object.defineProperties(this, {
      args: { value: args },
      url: { value: url }
    });
  }
};
__name(TimeoutError, "TimeoutError");
var SenderError = class extends Error {
  constructor(args, url, retcode) {
    super(`Error with request ${url}, args: ${JSON.stringify(args)}, retcode: ${retcode}`);
    Object.defineProperties(this, {
      code: { value: retcode },
      args: { value: args },
      url: { value: url }
    });
  }
};
__name(SenderError, "SenderError");
var logger = new import_satori.Logger("onebot");
var _Internal = class {
  async _get(action, params = {}) {
    logger.debug("[request] %s %o", action, params);
    const response = await this._request(action, params);
    logger.debug("[response] %o", response);
    const { data, retcode } = response;
    if (retcode === 0)
      return data;
    throw new SenderError(params, action, retcode);
  }
  async setGroupAnonymousBan(group_id, meta, duration) {
    const args = { group_id, duration };
    args[typeof meta === "string" ? "flag" : "anonymous"] = meta;
    await this._get("set_group_anonymous_ban", args);
  }
  async setGroupAnonymousBanAsync(group_id, meta, duration) {
    const args = { group_id, duration };
    args[typeof meta === "string" ? "flag" : "anonymous"] = meta;
    await this._get("set_group_anonymous_ban_async", args);
  }
  static prepareMethod(name) {
    const prop = (0, import_satori.camelize)(name.replace(/^[_.]/, ""));
    const isAsync = _Internal.asyncPrefixes.some((prefix) => prop.startsWith(prefix));
    return [prop, isAsync];
  }
  static define(name, ...params) {
    const [prop, isAsync] = _Internal.prepareMethod(name);
    _Internal.prototype[prop] = async function(...args) {
      const data = await this._get(name, Object.fromEntries(params.map((name2, index) => [name2, args[index]])));
      if (!isAsync)
        return data;
    };
    isAsync && (_Internal.prototype[prop + "Async"] = async function(...args) {
      await this._get(name + "_async", Object.fromEntries(params.map((name2, index) => [name2, args[index]])));
    });
  }
  static defineExtract(name, key, ...params) {
    const [prop, isAsync] = _Internal.prepareMethod(name);
    _Internal.prototype[prop] = async function(...args) {
      const data = await this._get(name, Object.fromEntries(params.map((name2, index) => [name2, args[index]])));
      return data[key];
    };
    isAsync && (_Internal.prototype[prop + "Async"] = async function(...args) {
      await this._get(name + "_async", Object.fromEntries(params.map((name2, index) => [name2, args[index]])));
    });
  }
};
var Internal = _Internal;
__name(Internal, "Internal");
Internal.asyncPrefixes = ["set", "send", "delete", "create", "upload"];
Internal.defineExtract("send_private_msg", "message_id", "user_id", "message", "auto_escape");
Internal.defineExtract("send_group_msg", "message_id", "group_id", "message", "auto_escape");
Internal.defineExtract("send_group_forward_msg", "message_id", "group_id", "messages");
Internal.defineExtract("send_private_forward_msg", "message_id", "user_id", "messages");
Internal.define("delete_msg", "message_id");
Internal.define("mark_msg_as_read", "message_id");
Internal.define("set_essence_msg", "message_id");
Internal.define("delete_essence_msg", "message_id");
Internal.define("send_group_sign", "group_id");
Internal.define("send_like", "user_id", "times");
Internal.define("get_msg", "message_id");
Internal.define("get_essence_msg_list", "group_id");
Internal.define("ocr_image", "image");
Internal.defineExtract("get_forward_msg", "messages", "message_id");
Internal.defineExtract(".get_word_slices", "slices", "content");
Internal.define("get_group_msg_history", "group_id", "message_seq");
Internal.define("set_friend_add_request", "flag", "approve", "remark");
Internal.define("set_group_add_request", "flag", "sub_type", "approve", "reason");
Internal.defineExtract("_get_model_show", "variants", "model");
Internal.define("_set_model_show", "model", "model_show");
Internal.define("set_group_kick", "group_id", "user_id", "reject_add_request");
Internal.define("set_group_ban", "group_id", "user_id", "duration");
Internal.define("set_group_whole_ban", "group_id", "enable");
Internal.define("set_group_admin", "group_id", "user_id", "enable");
Internal.define("set_group_anonymous", "group_id", "enable");
Internal.define("set_group_card", "group_id", "user_id", "card");
Internal.define("set_group_leave", "group_id", "is_dismiss");
Internal.define("set_group_special_title", "group_id", "user_id", "special_title", "duration");
Internal.define("set_group_name", "group_id", "group_name");
Internal.define("set_group_portrait", "group_id", "file", "cache");
Internal.define("_send_group_notice", "group_id", "content");
Internal.define("_get_group_notice", "group_id");
Internal.define("_del_group_notice", "group_id", "notice_id");
Internal.define("get_group_at_all_remain", "group_id");
Internal.define("get_login_info");
Internal.define("qidian_get_login_info");
Internal.define("set_qq_profile", "nickname", "company", "email", "college", "personal_note");
Internal.define("get_stranger_info", "user_id", "no_cache");
Internal.define("_get_vip_info", "user_id");
Internal.define("get_friend_list");
Internal.define("get_unidirectional_friend_list");
Internal.define("delete_friend", "user_id");
Internal.define("delete_unidirectional_friend", "user_id");
Internal.define("get_group_info", "group_id", "no_cache");
Internal.define("get_group_list");
Internal.define("get_group_member_info", "group_id", "user_id", "no_cache");
Internal.define("get_group_member_list", "group_id");
Internal.define("get_group_honor_info", "group_id", "type");
Internal.define("get_group_system_msg");
Internal.define("get_group_file_system_info", "group_id");
Internal.define("get_group_root_files", "group_id");
Internal.define("get_group_files_by_folder", "group_id", "folder_id");
Internal.define("upload_private_file", "user_id", "file", "name");
Internal.define("upload_group_file", "group_id", "file", "name", "folder");
Internal.define("create_group_file_folder", "group_id", "folder_id", "name");
Internal.define("delete_group_folder", "group_id", "folder_id");
Internal.define("delete_group_file", "group_id", "folder_id", "file_id", "busid");
Internal.defineExtract("get_group_file_url", "url", "group_id", "file_id", "busid");
Internal.defineExtract("download_file", "file", "url", "headers", "thread_count");
Internal.defineExtract("get_online_clients", "clients", "no_cache");
Internal.defineExtract("check_url_safely", "level", "url");
Internal.defineExtract("get_cookies", "cookies", "domain");
Internal.defineExtract("get_csrf_token", "token");
Internal.define("get_credentials", "domain");
Internal.define("get_record", "file", "out_format", "full_path");
Internal.define("get_image", "file");
Internal.defineExtract("can_send_image", "yes");
Internal.defineExtract("can_send_record", "yes");
Internal.define("get_status");
Internal.define("get_version_info");
Internal.define("set_restart", "delay");
Internal.define("reload_event_filter");
Internal.define("get_guild_service_profile");
Internal.define("get_guild_list");
Internal.define("get_guild_meta_by_guest", "guild_id");
Internal.define("get_guild_channel_list", "guild_id", "no_cache");
Internal.define("get_guild_member_list", "guild_id", "next_token");
Internal.define("get_guild_member_profile", "guild_id", "user_id");
Internal.defineExtract("send_guild_channel_msg", "message_id", "guild_id", "channel_id", "message");

// satori/adapters/onebot/src/utils.ts
var logger2 = new import_satori2.Logger("onebot");
var adaptUser = /* @__PURE__ */ __name((user) => ({
  userId: user.tiny_id || user.user_id.toString(),
  avatar: user.user_id ? `http://q.qlogo.cn/headimg_dl?dst_uin=${user.user_id}&spec=640` : void 0,
  username: user.nickname
}), "adaptUser");
var adaptGuildMember = /* @__PURE__ */ __name((user) => ({
  ...adaptUser(user),
  nickname: user.card,
  roles: [user.role]
}), "adaptGuildMember");
var adaptQQGuildMemberInfo = /* @__PURE__ */ __name((user) => ({
  userId: user.tiny_id,
  username: user.nickname,
  nickname: user.nickname,
  roles: user.role_name ? [user.role_name] : [],
  isBot: user.role_name === "机器人"
}), "adaptQQGuildMemberInfo");
var adaptQQGuildMemberProfile = /* @__PURE__ */ __name((user) => {
  var _a, _b;
  return {
    userId: user.tiny_id,
    username: user.nickname,
    nickname: user.nickname,
    roles: ((_a = user.roles) == null ? void 0 : _a.map((r) => r.role_name)) || [],
    isBot: (_b = user.roles) == null ? void 0 : _b.some((r) => r.role_name === "机器人")
  };
}, "adaptQQGuildMemberProfile");
var adaptAuthor = /* @__PURE__ */ __name((user, anonymous) => ({
  ...adaptUser(user),
  nickname: (anonymous == null ? void 0 : anonymous.name) || user.card,
  anonymous: anonymous == null ? void 0 : anonymous.flag,
  roles: [user.role]
}), "adaptAuthor");
async function adaptMessage(bot, message, result = {}) {
  var _a;
  result.author = adaptAuthor(message.sender, message.anonymous);
  result.userId = result.author.userId;
  result.messageId = message.message_id.toString();
  result.timestamp = message.time * 1e3;
  if (message.guild_id) {
    result.guildId = message.guild_id;
    result.channelId = message.channel_id;
  } else if (message.group_id) {
    result.guildId = result.channelId = message.group_id.toString();
  } else {
    result.channelId = "private:" + result.author.userId;
  }
  result.elements = import_satori2.segment.transform(CQCode.parse(message.message), {
    at({ qq }) {
      if (qq !== "all")
        return import_satori2.segment.at(qq);
      return (0, import_satori2.segment)("at", { type: "all" });
    },
    face: ({ id }) => (0, import_satori2.segment)("face", { id, url: qface.getUrl(id) })
  });
  if (((_a = result.elements[0]) == null ? void 0 : _a.type) === "reply") {
    const reply = result.elements.shift();
    result.quote = await bot.getMessage(result.channelId, reply.attrs.id).catch((error) => {
      logger2.warn(error);
      return void 0;
    });
  }
  result.content = result.elements.join("");
  return result;
}
__name(adaptMessage, "adaptMessage");
var adaptGuild = /* @__PURE__ */ __name((info) => {
  if (info.guild_id) {
    const guild = info;
    return {
      guildId: guild.guild_id,
      guildName: guild.guild_name
    };
  } else {
    const group = info;
    return {
      guildId: group.group_id.toString(),
      guildName: group.group_name
    };
  }
}, "adaptGuild");
var adaptChannel = /* @__PURE__ */ __name((info) => {
  if (info.channel_id) {
    const channel = info;
    return {
      channelId: channel.channel_id.toString(),
      channelName: channel.channel_name
    };
  } else {
    const group = info;
    return {
      channelId: group.group_id.toString(),
      channelName: group.group_name
    };
  }
}, "adaptChannel");
async function dispatchSession(bot, data) {
  if (data.self_tiny_id) {
    bot = bot["guildBot"];
    if (!bot)
      return;
  }
  const session = await adaptSession(bot, data);
  if (!session)
    return;
  (0, import_satori2.defineProperty)(session, "onebot", Object.create(bot.internal));
  Object.assign(session.onebot, data);
  bot.dispatch(session);
}
__name(dispatchSession, "dispatchSession");
async function adaptSession(bot, data) {
  const session = bot.session();
  session.selfId = data.self_tiny_id ? data.self_tiny_id : "" + data.self_id;
  session.type = data.post_type;
  if (data.post_type === "message" || data.post_type === "message_sent") {
    await adaptMessage(bot, data, session);
    if (data.post_type === "message_sent" && !session.guildId) {
      session.channelId = "private:" + data.target_id;
    }
    session.type = "message";
    session.subtype = data.message_type === "guild" ? "group" : data.message_type;
    session.subsubtype = data.message_type;
    return session;
  }
  session.subtype = data.sub_type;
  if (data.user_id)
    session.userId = "" + data.user_id;
  if (data.group_id)
    session.guildId = session.channelId = "" + data.group_id;
  if (data.guild_id)
    session.guildId = "" + data.guild_id;
  if (data.channel_id)
    session.channelId = "" + data.channel_id;
  if (data.target_id)
    session.targetId = "" + data.target_id;
  if (data.operator_id)
    session.operatorId = "" + data.operator_id;
  if (data.message_id)
    session.messageId = "" + data.message_id;
  if (data.post_type === "request") {
    session.content = data.comment;
    session.messageId = data.flag;
    if (data.request_type === "friend") {
      session.type = "friend-request";
      session.channelId = `private:${session.userId}`;
    } else if (data.sub_type === "add") {
      session.type = "guild-member-request";
    } else {
      session.type = "guild-request";
    }
  } else if (data.post_type === "notice") {
    switch (data.notice_type) {
      case "group_recall":
        session.type = "message-deleted";
        session.subtype = "group";
        session.subsubtype = "group";
        break;
      case "friend_recall":
        session.type = "message-deleted";
        session.subtype = "private";
        session.channelId = `private:${session.userId}`;
        session.subsubtype = "private";
        break;
      case "guild_channel_recall":
        session.type = "message-deleted";
        session.subtype = "guild";
        session.subsubtype = "guild";
        break;
      case "friend_add":
        session.type = "friend-added";
        break;
      case "group_upload":
        session.type = "guild-file-added";
        break;
      case "group_admin":
        session.type = "guild-member";
        session.subtype = "role";
        break;
      case "group_ban":
        session.type = "guild-member";
        session.subtype = "ban";
        break;
      case "group_decrease":
        session.type = session.userId === session.selfId ? "guild-deleted" : "guild-member-deleted";
        session.subtype = session.userId === session.operatorId ? "active" : "passive";
        break;
      case "group_increase":
        session.type = session.userId === session.selfId ? "guild-added" : "guild-member-added";
        session.subtype = session.userId === session.operatorId ? "active" : "passive";
        break;
      case "group_card":
        session.type = "guild-member";
        session.subtype = "nickname";
        break;
      case "notify":
        session.type = "notice";
        session.subtype = (0, import_satori2.hyphenate)(data.sub_type);
        if (session.subtype === "poke") {
          session.channelId || (session.channelId = `private:${session.userId}`);
        } else if (session.subtype === "honor") {
          session.subsubtype = (0, import_satori2.hyphenate)(data.honor_type);
        }
        break;
      case "message_reactions_updated":
        session.type = "onebot";
        session.subtype = "message-reactions-updated";
        break;
      case "channel_created":
        session.type = "onebot";
        session.subtype = "channel-created";
        break;
      case "channel_updated":
        session.type = "onebot";
        session.subtype = "channel-updated";
        break;
      case "channel_destroyed":
        session.type = "onebot";
        session.subtype = "channel-destroyed";
        break;
      default:
        return;
    }
  } else
    return;
  return session;
}
__name(adaptSession, "adaptSession");

// satori/adapters/onebot/src/http.ts
var import_crypto = require("crypto");
var logger3 = new import_satori3.Logger("onebot");
var HttpServer = class extends import_satori3.Adapter.Server {
  async fork(ctx, bot) {
    const config = bot.config;
    const { endpoint, token } = config;
    if (!endpoint)
      return;
    const http = ctx.http.extend(config).extend({
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Token ${token}`
      }
    });
    bot.internal._request = async (action, params) => {
      return http.post("/" + action, params);
    };
    return bot.initialize();
  }
  async start(bot) {
    const { secret, path = "/onebot" } = bot.config;
    bot.ctx.router.post(path, (ctx) => {
      if (secret) {
        const signature = ctx.headers["x-signature"];
        if (!signature)
          return ctx.status = 401;
        const sig = (0, import_crypto.createHmac)("sha1", secret).update(ctx.request.rawBody).digest("hex");
        if (signature !== `sha1=${sig}`)
          return ctx.status = 403;
      }
      const selfId = ctx.headers["x-self-id"].toString();
      const bot2 = this.bots.find((bot3) => bot3.selfId === selfId);
      if (!bot2)
        return ctx.status = 403;
      logger3.debug("receive %o", ctx.request.body);
      dispatchSession(bot2, ctx.request.body);
    });
  }
  async stop() {
    logger3.debug("http server closing");
  }
};
__name(HttpServer, "HttpServer");
((HttpServer2) => {
  HttpServer2.Config = import_satori3.Schema.intersect([
    import_satori3.Schema.object({
      protocol: import_satori3.Schema.const("http"),
      path: import_satori3.Schema.string().description("服务器监听的路径。").default("/onebot"),
      secret: import_satori3.Schema.string().description("接收事件推送时用于验证的字段，应该与 OneBot 的 secret 配置保持一致。").role("secret")
    }).description("连接设置"),
    import_satori3.Quester.createConfig(true)
  ]);
})(HttpServer || (HttpServer = {}));

// satori/adapters/onebot/src/ws.ts
var import_satori4 = require("@satorijs/satori");
var logger4 = new import_satori4.Logger("onebot");
var WsClient = class extends import_satori4.Adapter.WsClient {
  constructor() {
    super(...arguments);
    this.accept = accept;
  }
  prepare(bot) {
    const { token, endpoint } = bot.config;
    const http = this.ctx.http.extend(bot.config);
    if (token)
      http.config.headers.Authorization = `Bearer ${token}`;
    return http.ws(endpoint);
  }
};
__name(WsClient, "WsClient");
((WsClient2) => {
  WsClient2.Config = import_satori4.Schema.intersect([
    import_satori4.Schema.object({
      protocol: import_satori4.Schema.const("ws"),
      responseTimeout: import_satori4.Schema.natural().role("time").default(import_satori4.Time.minute).description("等待响应的时间 (单位为毫秒)。")
    }).description("连接设置"),
    import_satori4.Quester.createConfig(true),
    import_satori4.Adapter.WsClient.Config
  ]);
})(WsClient || (WsClient = {}));
var WsServer = class extends import_satori4.Adapter.Server {
  constructor(ctx, bot) {
    super();
    const { path = "/onebot" } = bot.config;
    this.wsServer = ctx.router.ws(path, (socket, { headers }) => {
      logger4.debug("connected with", headers);
      if (headers["x-client-role"] !== "Universal") {
        return socket.close(1008, "invalid x-client-role");
      }
      const selfId = headers["x-self-id"].toString();
      const bot2 = this.bots.find((bot3) => bot3.selfId === selfId);
      if (!bot2)
        return socket.close(1008, "invalid x-self-id");
      bot2.socket = socket;
      accept(bot2);
    });
    ctx.on("dispose", () => {
      logger4.debug("ws server closing");
      this.wsServer.close();
    });
  }
  async stop(bot) {
    var _a;
    (_a = bot.socket) == null ? void 0 : _a.close();
    bot.socket = null;
  }
};
__name(WsServer, "WsServer");
((WsServer2) => {
  WsServer2.Config = import_satori4.Schema.object({
    protocol: import_satori4.Schema.const("ws-reverse"),
    path: import_satori4.Schema.string().description("服务器监听的路径。").default("/onebot"),
    responseTimeout: import_satori4.Schema.natural().role("time").default(import_satori4.Time.minute).description("等待响应的时间 (单位为毫秒)。")
  }).description("连接设置");
})(WsServer || (WsServer = {}));
var counter = 0;
var listeners = {};
function accept(bot) {
  bot.socket.on("message", (data) => {
    let parsed;
    try {
      parsed = JSON.parse(data.toString());
    } catch (error) {
      return logger4.warn("cannot parse message", data);
    }
    if ("post_type" in parsed) {
      logger4.debug("receive %o", parsed);
      dispatchSession(bot, parsed);
    } else if (parsed.echo in listeners) {
      listeners[parsed.echo](parsed);
      delete listeners[parsed.echo];
    }
  });
  bot.socket.on("close", () => {
    delete bot.internal._request;
  });
  bot.internal._request = (action, params) => {
    const data = { action, params, echo: ++counter };
    data.echo = ++counter;
    return new Promise((resolve, reject) => {
      listeners[data.echo] = resolve;
      setTimeout(() => {
        delete listeners[data.echo];
        reject(new TimeoutError(params, action));
      }, bot.config.responseTimeout);
      bot.socket.send(JSON.stringify(data), (error) => {
        if (error)
          reject(error);
      });
    });
  };
  bot.initialize();
}
__name(accept, "accept");

// satori/adapters/onebot/src/bot/base.ts
var import_satori6 = require("@satorijs/satori");

// satori/adapters/onebot/src/bot/modulator.ts
var import_satori5 = require("@satorijs/satori");
var State = class {
  constructor(type) {
    this.type = type;
    this.author = {};
    this.children = [];
  }
};
__name(State, "State");
var OneBotModulator = class extends import_satori5.Modulator {
  constructor() {
    super(...arguments);
    this.stack = [new State("message")];
    this.children = [];
  }
  async forward() {
    if (!this.stack[0].children.length)
      return;
    const session = this.bot.session(this.session);
    session.messageId = this.guildId ? "" + await this.bot.internal.sendGroupForwardMsg(this.guildId, this.stack[0].children) : "" + await this.bot.internal.sendPrivateForwardMsg(this.channelId.slice(8), this.stack[0].children);
    session.app.emit(session, "send", session);
    this.results.push(session);
  }
  async flush() {
    while (true) {
      const first = this.children[0];
      if ((first == null ? void 0 : first.type) !== "text")
        break;
      first.data.text = first.data.text.trimStart();
      if (first.data.text)
        break;
      this.children.shift();
    }
    while (true) {
      const last = this.children[this.children.length - 1];
      if ((last == null ? void 0 : last.type) !== "text")
        break;
      last.data.text = last.data.text.trimEnd();
      if (last.data.text)
        break;
      this.children.pop();
    }
    if (!this.children.length)
      return;
    if (this.stack[0].type === "forward") {
      this.stack[1].children.push({
        type: "node",
        data: {
          name: this.stack[0].author.name || this.bot.nickname || this.bot.username,
          uin: this.stack[0].author.id || this.bot.userId,
          content: this.children
        }
      });
      this.children = [];
      return;
    }
    const session = this.bot.session(this.session);
    session.messageId = this.bot.parent ? "" + await this.bot.internal.sendGuildChannelMsg(this.guildId, this.channelId, this.children) : this.guildId ? "" + await this.bot.internal.sendGroupMsg(this.guildId, this.children) : "" + await this.bot.internal.sendPrivateMsg(this.channelId.slice(8), this.children);
    session.app.emit(session, "send", session);
    this.results.push(session);
    this.children = [];
  }
  text(text) {
    this.children.push({ type: "text", data: { text } });
  }
  async visit(element) {
    let { type, attrs, children } = element;
    if (type === "text") {
      this.text(attrs.content);
    } else if (type === "p") {
      await this.render(children);
      this.text("\n");
    } else if (type === "at") {
      if (attrs.type === "all") {
        this.children.push({ type: "at", data: { qq: "all" } });
      } else {
        this.children.push({ type: "at", data: { qq: attrs.id } });
      }
    } else if (type === "sharp") {
      if (attrs.id)
        this.text(attrs.id);
    } else if (type === "a") {
      await this.render(children);
      if (attrs.href)
        this.text(` (${attrs.href}) `);
    } else if (["video", "audio", "image"].includes(type)) {
      if (type === "audio")
        type = "record";
      attrs = { ...attrs };
      attrs.file = attrs.url;
      delete attrs.url;
      const cap = /^data:([\w/-]+);base64,/.exec(attrs.file);
      if (cap)
        attrs.file = "base64://" + attrs.file.slice(cap[0].length);
      this.children.push({ type, data: attrs });
    } else if (type === "onebot:music") {
      this.children.push({ type: "music", data: attrs });
    } else if (type === "onebot:tts") {
      this.children.push({ type: "tts", data: attrs });
    } else if (type === "author") {
      Object.assign(this.stack[0].author, attrs);
    } else if (type === "figure") {
      await this.flush();
      this.stack.unshift(new State("forward"));
      await this.render(children, true);
      this.stack.shift();
      await this.forward();
    } else if (type === "quote") {
      await this.flush();
      this.children.push({ type: "reply", data: attrs });
    } else if (type === "message") {
      await this.flush();
      if (attrs.forward && !this.bot.parent) {
        this.stack.unshift(new State("forward"));
        await this.render(children, true);
        this.stack.shift();
        await this.forward();
      } else {
        if (attrs.userId)
          this.stack[0].author.id = attrs.userId;
        if (attrs.nickname)
          this.stack[0].author.name = attrs.nickname;
        await this.render(children);
        await this.flush();
      }
    } else {
      await this.render(children);
    }
  }
};
__name(OneBotModulator, "OneBotModulator");

// satori/adapters/onebot/src/bot/base.ts
var BaseBot = class extends import_satori6.Bot {
  sendMessage(channelId, fragment, guildId) {
    return new OneBotModulator(this, channelId, guildId).send(fragment);
  }
  sendPrivateMessage(userId, fragment) {
    return this.sendMessage("private:" + userId, fragment);
  }
  async getMessage(channelId, messageId) {
    const data = await this.internal.getMsg(messageId);
    return await adaptMessage(this, data);
  }
  async deleteMessage(channelId, messageId) {
    await this.internal.deleteMsg(messageId);
  }
  async getSelf() {
    const data = await this.internal.getLoginInfo();
    return adaptUser(data);
  }
  async getUser(userId) {
    const data = await this.internal.getStrangerInfo(userId);
    return adaptUser(data);
  }
  async getFriendList() {
    const data = await this.internal.getFriendList();
    return data.map(adaptUser);
  }
  async handleFriendRequest(messageId, approve, comment) {
    await this.internal.setFriendAddRequest(messageId, approve, comment);
  }
  async handleGuildRequest(messageId, approve, comment) {
    await this.internal.setGroupAddRequest(messageId, "invite", approve, comment);
  }
  async handleGuildMemberRequest(messageId, approve, comment) {
    await this.internal.setGroupAddRequest(messageId, "add", approve, comment);
  }
  async deleteFriend(userId) {
    await this.internal.deleteFriend(userId);
  }
  async getMessageList(channelId, before) {
    let list;
    if (before) {
      const msg = await this.internal.getMsg(before);
      if (msg == null ? void 0 : msg.message_seq) {
        list = (await this.internal.getGroupMsgHistory(Number(channelId), msg.message_seq)).messages;
      }
    } else {
      list = (await this.internal.getGroupMsgHistory(Number(channelId))).messages;
    }
    return await Promise.all(list.map((item) => adaptMessage(this, item)));
  }
};
__name(BaseBot, "BaseBot");

// satori/adapters/onebot/src/bot/qqguild.ts
var QQGuildBot = class extends BaseBot {
  constructor(ctx, config) {
    super(ctx, config);
    this.hidden = true;
    this.parent = config.parent;
    this.internal = config.parent.internal;
    this.selfId = config.profile.tiny_id;
    this.avatar = config.profile.avatar_url;
    this.username = config.profile.nickname;
    this.parent.guildBot = this;
  }
  get status() {
    return this.parent.status;
  }
  set status(status) {
    this.parent.status = status;
  }
  async start() {
    await this.ctx.parallel("bot-connect", this);
  }
  async stop() {
    if (!this.parent)
      return;
    this.parent = void 0;
    await this.ctx.parallel("bot-disconnect", this);
  }
  async getChannel(channelId, guildId) {
    const channels = await this.getChannelList(guildId);
    return channels.find((channel) => channel.channelId === channelId);
  }
  async getChannelList(guildId) {
    const data = await this.internal.getGuildChannelList(guildId, false);
    return (data || []).map(adaptChannel);
  }
  async getGuild(guildId) {
    const data = await this.internal.getGuildMetaByGuest(guildId);
    return adaptGuild(data);
  }
  async getGuildList() {
    const data = await this.internal.getGuildList();
    return data.map(adaptGuild);
  }
  async getGuildMember(guildId, userId) {
    const profile = await this.internal.getGuildMemberProfile(guildId, userId);
    return adaptQQGuildMemberProfile(profile);
  }
  async getGuildMemberList(guildId) {
    var _a;
    let nextToken;
    let list = [];
    while (true) {
      const data = await this.internal.getGuildMemberList(guildId, nextToken);
      if (!((_a = data.members) == null ? void 0 : _a.length))
        break;
      list = list.concat(data.members.map(adaptQQGuildMemberInfo));
      if (data.finished)
        break;
      nextToken = data.next_token;
    }
    return list;
  }
};
__name(QQGuildBot, "QQGuildBot");

// satori/adapters/onebot/src/bot/cqcode.ts
var import_satori7 = require("@satorijs/satori");
function CQCode(type, attrs) {
  if (type === "text")
    return attrs.content;
  let output = "[CQ:" + type;
  for (const key in attrs) {
    if (attrs[key])
      output += `,${key}=${import_satori7.segment.escape(attrs[key], true)}`;
  }
  return output + "]";
}
__name(CQCode, "CQCode");
((CQCode2) => {
  function escape(source, inline = false) {
    const result = String(source).replace(/&/g, "&amp;").replace(/\[/g, "&#91;").replace(/\]/g, "&#93;");
    return inline ? result.replace(/,/g, "&#44;").replace(/(\ud83c[\udf00-\udfff])|(\ud83d[\udc00-\ude4f\ude80-\udeff])|[\u2600-\u2B55]/g, " ") : result;
  }
  CQCode2.escape = escape;
  __name(escape, "escape");
  function unescape(source) {
    return String(source).replace(/&#91;/g, "[").replace(/&#93;/g, "]").replace(/&#44;/g, ",").replace(/&amp;/g, "&");
  }
  CQCode2.unescape = unescape;
  __name(unescape, "unescape");
  const pattern = /\[CQ:(\w+)((,\w+=[^,\]]*)*)\]/;
  function from(source) {
    const capture = pattern.exec(source);
    if (!capture)
      return null;
    const [, type, attrs] = capture;
    const data = {};
    attrs && attrs.slice(1).split(",").forEach((str) => {
      const index = str.indexOf("=");
      data[str.slice(0, index)] = unescape(str.slice(index + 1));
    });
    return { type, data, capture };
  }
  CQCode2.from = from;
  __name(from, "from");
  function parse(source) {
    if (typeof source !== "string") {
      return source.map(({ type, data }) => (0, import_satori7.segment)(type, data));
    }
    const elements = [];
    let result;
    while (result = from(source)) {
      const { type, data, capture } = result;
      if (capture.index) {
        elements.push((0, import_satori7.segment)("text", { content: unescape(source.slice(0, capture.index)) }));
      }
      elements.push((0, import_satori7.segment)(type, data));
      source = source.slice(capture.index + capture[0].length);
    }
    if (source)
      elements.push((0, import_satori7.segment)("text", { content: unescape(source) }));
    return elements;
  }
  CQCode2.parse = parse;
  __name(parse, "parse");
})(CQCode || (CQCode = {}));

// satori/adapters/onebot/src/bot/index.ts
var OneBotBot = class extends BaseBot {
  constructor(ctx, config) {
    super(ctx, config);
    this.selfId = config.selfId;
    this.internal = new Internal();
    this.avatar = `http://q.qlogo.cn/headimg_dl?dst_uin=${config.selfId}&spec=640`;
    if (config.protocol === "http") {
      ctx.plugin(HttpServer, this);
    } else if (config.protocol === "ws") {
      ctx.plugin(WsClient, this);
    } else if (config.protocol === "ws-reverse") {
      ctx.plugin(WsServer, this);
    }
  }
  async stop() {
    if (this.guildBot) {
      delete this.ctx.bots[this.guildBot.sid];
    }
    await super.stop();
  }
  async initialize() {
    await Promise.all([
      this.getSelf().then((data) => Object.assign(this, data)),
      this.setupGuildService().catch(import_satori8.noop)
    ]).then(() => this.online(), (error) => this.offline(error));
  }
  async setupGuildService() {
    const profile = await this.internal.getGuildServiceProfile();
    if (!(profile == null ? void 0 : profile.tiny_id) || profile.tiny_id === "0")
      return;
    this.ctx.plugin(QQGuildBot, {
      ...this.config.qqguild,
      profile,
      parent: this
    });
  }
  async getChannel(channelId) {
    const data = await this.internal.getGroupInfo(channelId);
    return adaptChannel(data);
  }
  async getGuild(guildId) {
    const data = await this.internal.getGroupInfo(guildId);
    return adaptGuild(data);
  }
  async getGuildList() {
    const data = await this.internal.getGroupList();
    return data.map(adaptGuild);
  }
  async getGuildMember(guildId, userId) {
    const data = await this.internal.getGroupMemberInfo(guildId, userId);
    return adaptGuildMember(data);
  }
  async getGuildMemberList(guildId) {
    const data = await this.internal.getGroupMemberList(guildId);
    return data.map(adaptGuildMember);
  }
  async kickGuildMember(guildId, userId, permanent) {
    return this.internal.setGroupKick(guildId, userId, permanent);
  }
  async muteGuildMember(guildId, userId, duration) {
    return this.internal.setGroupBan(guildId, userId, duration / 1e3);
  }
  async muteChannel(channelId, guildId, enable) {
    return this.internal.setGroupWholeBan(channelId, enable);
  }
};
__name(OneBotBot, "OneBotBot");
OneBotBot.prototype.platform = "onebot";
((OneBotBot2) => {
  OneBotBot2.QQGuildConfig = import_satori8.Schema.object({
    platform: import_satori8.Schema.string().default("qqguild").description("QQ 频道的平台名称")
  });
  OneBotBot2.BaseConfig = import_satori8.Schema.object({
    selfId: import_satori8.Schema.string().description("机器人的账号。").required(),
    token: import_satori8.Schema.string().role("secret").description("发送信息时用于验证的字段，应与 OneBot 配置文件中的 `access_token` 保持一致。"),
    protocol: import_satori8.Schema.union(["http", "ws", "ws-reverse"]).description("选择要使用的协议。").default("ws-reverse"),
    qqguild: OneBotBot2.QQGuildConfig.hidden()
  });
  OneBotBot2.Config = import_satori8.Schema.intersect([
    OneBotBot2.BaseConfig,
    import_satori8.Schema.union([
      HttpServer.Config,
      WsClient.Config,
      WsServer.Config
    ])
  ]);
})(OneBotBot || (OneBotBot = {}));

// satori/adapters/onebot/src/index.ts
var src_default = OneBotBot;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BaseBot,
  CQCode,
  HttpServer,
  OneBot,
  OneBotBot,
  QQGuildBot,
  WsClient,
  WsServer,
  accept
});
//# sourceMappingURL=index.js.map
