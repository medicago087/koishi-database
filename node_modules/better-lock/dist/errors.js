"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.BetterLockJobAbortedError = exports.BetterLockQueueOverflowError = exports.BetterLockExecutionTimeoutError = exports.BetterLockWaitTimeoutError = exports.BetterLockInvalidArgumentError = exports.BetterLockInternalError = exports.BetterLockError = void 0;
var internals_1 = require("./internals");
var BetterLockError = /** @class */ (function (_super) {
    __extends(BetterLockError, _super);
    function BetterLockError(lockName, message, incomingStack) {
        var _newTarget = this.constructor;
        if (incomingStack === void 0) { incomingStack = null; }
        var _this = this;
        // Fix typescript custom Error prototype chain
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        // https://github.com/reduardo7/ts-base-error/blob/master/src/index.ts
        var trueProto = _newTarget.prototype;
        if (lockName) {
            _this = _super.call(this, "[" + lockName + "] " + message) || this;
        }
        else {
            _this = _super.call(this, message) || this;
        }
        Object.setPrototypeOf(_this, trueProto);
        _this.lock_name = lockName;
        _this.name = _this.constructor.name;
        if (incomingStack) {
            var withoutFirstLine = incomingStack.split('\n').slice(1).join('\n');
            _this.stack =
                _this.stack +
                    '\n    --------------------------------------------------------------------------------\n' +
                    withoutFirstLine;
        }
        return _this;
    }
    return BetterLockError;
}(Error));
exports.BetterLockError = BetterLockError;
var BetterLockInternalError = /** @class */ (function (_super) {
    __extends(BetterLockInternalError, _super);
    function BetterLockInternalError(lockName, message) {
        var _this = this;
        var lastChar = message[message.length - 1];
        if (lastChar !== '.' && lastChar !== '!' && lastChar !== '?') {
            message += '.';
        }
        _this = _super.call(this, lockName, message + ' This is probably a bug inside "better-lock" library') || this;
        return _this;
    }
    return BetterLockInternalError;
}(BetterLockError));
exports.BetterLockInternalError = BetterLockInternalError;
var BetterLockInvalidArgumentError = /** @class */ (function (_super) {
    __extends(BetterLockInvalidArgumentError, _super);
    function BetterLockInvalidArgumentError(lockName, argument, expected, actual) {
        var _this = _super.call(this, lockName, "Argument \"" + argument + "\" must be " + expected + " (got: \"" + actual + "\")") || this;
        _this.argument = argument;
        _this.argument = argument;
        return _this;
    }
    return BetterLockInvalidArgumentError;
}(BetterLockError));
exports.BetterLockInvalidArgumentError = BetterLockInvalidArgumentError;
var BetterLockWaitTimeoutError = /** @class */ (function (_super) {
    __extends(BetterLockWaitTimeoutError, _super);
    function BetterLockWaitTimeoutError(lockName, job) {
        var _this = this;
        var message = job + " has timed out after " + (new Date().valueOf() - job.enqueued_at.valueOf()) + "ms in wait queue";
        _this = _super.call(this, lockName, message, job.incoming_stack) || this;
        _this.job_id = job.id;
        _this.keys = job.keys;
        _this.enqueued_at = job.enqueued_at;
        return _this;
    }
    return BetterLockWaitTimeoutError;
}(BetterLockError));
exports.BetterLockWaitTimeoutError = BetterLockWaitTimeoutError;
var BetterLockExecutionTimeoutError = /** @class */ (function (_super) {
    __extends(BetterLockExecutionTimeoutError, _super);
    function BetterLockExecutionTimeoutError(lockName, job) {
        var _this = this;
        var message = job + " has timed out after " + (new Date().valueOf() - job.executed_at.valueOf()) + "ms of execution";
        _this = _super.call(this, lockName, message, job.incoming_stack) || this;
        _this.job_id = job.id;
        _this.keys = job.keys;
        _this.executed_at = job.executed_at;
        return _this;
    }
    return BetterLockExecutionTimeoutError;
}(BetterLockError));
exports.BetterLockExecutionTimeoutError = BetterLockExecutionTimeoutError;
var BetterLockQueueOverflowError = /** @class */ (function (_super) {
    __extends(BetterLockQueueOverflowError, _super);
    function BetterLockQueueOverflowError(lockName, key, count, job) {
        var _this = this;
        var keyDesignation = key === internals_1.KeyQueue.DEFAULT_QUEUE_KEY ? '' : " for key \"" + key + "\"";
        var message = "Too many jobs (" + count + ") are waiting" + keyDesignation + ". The most recent job (" + job + ") was kicked out";
        _this = _super.call(this, lockName, message, job.incoming_stack) || this;
        _this.job_id = job.id;
        _this.keys = job.keys;
        _this.job_count = count;
        _this.kicked_out_job_id = job.id;
        return _this;
    }
    return BetterLockQueueOverflowError;
}(BetterLockError));
exports.BetterLockQueueOverflowError = BetterLockQueueOverflowError;
var BetterLockJobAbortedError = /** @class */ (function (_super) {
    __extends(BetterLockJobAbortedError, _super);
    function BetterLockJobAbortedError(lockName, job) {
        var _this = _super.call(this, lockName, job + " has been aborted by the user", job.incoming_stack) || this;
        _this.job_id = job.id;
        _this.keys = job.keys;
        return _this;
    }
    return BetterLockJobAbortedError;
}(BetterLockError));
exports.BetterLockJobAbortedError = BetterLockJobAbortedError;
//# sourceMappingURL=errors.js.map