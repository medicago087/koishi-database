"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assign = exports.callbackWithPromise = exports.makeLog = exports.noop = exports.isNumber = exports.isObject = exports.isFunction = exports.isString = void 0;
function isString(val) {
    return typeof val === 'string';
}
exports.isString = isString;
function isFunction(val) {
    return typeof val === 'function';
}
exports.isFunction = isFunction;
function isObject(val) {
    return typeof val === 'object' && val !== null && !Array.isArray(val);
}
exports.isObject = isObject;
function isNumber(val, includeInfinity, includeNaN) {
    if (includeInfinity === void 0) { includeInfinity = false; }
    if (includeNaN === void 0) { includeNaN = false; }
    if (typeof val !== 'number') {
        return false;
    }
    if (!includeInfinity && (val === Number.POSITIVE_INFINITY || val === Number.NEGATIVE_INFINITY)) {
        return false;
    }
    if (!includeNaN && isNaN(val)) {
        return false;
    }
    return true;
}
exports.isNumber = isNumber;
function noop() {
    // Nothing
}
exports.noop = noop;
function makeLog(name, doLog) {
    if (!doLog) {
        return noop;
    }
    if (doLog === true) {
        doLog = console.log.bind(console);
    }
    if (name) {
        name = '[' + name + '] ';
    }
    return function log(msg) {
        if (name) {
            doLog(name + msg);
        }
        else {
            doLog(msg);
        }
    };
}
exports.makeLog = makeLog;
/**
 * Create a wrapped promise + callback construct
 */
function callbackWithPromise() {
    var callback;
    var promise = new Promise(function (resolve, reject) {
        callback = function (err, result) {
            if (err) {
                reject(err);
            }
            else {
                resolve(result);
            }
        };
    });
    callback.promise = promise;
    return callback;
}
exports.callbackWithPromise = callbackWithPromise;
/**
 * Assign properties from sources to target, skipping over undefined-s
 * @param target Target object which will be mutated
 * @param sources One or more source objects which will provide properties
 */
function assign(target, sources) {
    for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {
        var source = sources_1[_i];
        if (!isObject(source)) {
            // We must have an object to assign
            continue;
        }
        for (var key in source) {
            if (!source.hasOwnProperty(key)) {
                continue;
            }
            var sourceValue = source[key];
            if (sourceValue === undefined) {
                // Do not overwrite undefineds
                continue;
            }
            var targetValue = target[key];
            if (isObject(sourceValue) && isObject(targetValue)) {
                // Merge deep.
                var cloneRoot = targetValue.constructor ? new targetValue.constructor() : {};
                target[key] = assign(cloneRoot, [targetValue, sourceValue]);
                continue;
            }
            // In all other cases, copy by reference
            target[key] = sourceValue;
        }
    }
    return target;
}
exports.assign = assign;
//# sourceMappingURL=tools.js.map