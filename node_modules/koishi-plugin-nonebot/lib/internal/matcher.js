"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandMatcher = exports.MessageMatcher = exports.EventMatcher = exports.BaseMatcher = exports.NoneBotException = void 0;
const koishi_1 = require("koishi");
const utils_1 = require("./utils");
const logger = new koishi_1.Logger('nonebot');
class NoneBotException extends Error {
    constructor(message) {
        super('[NBE] ' + message);
    }
    static check(e) {
        if (!(e instanceof Error))
            return;
        if (e.name !== 'PythonError')
            return;
        if (!e.message.includes('JsException:'))
            return;
        if (!e.message.includes('[NBE] '))
            return;
        return true;
    }
}
exports.NoneBotException = NoneBotException;
const fallbackMap = {
    'MessageEvent': 'Event',
    'GroupMessageEvent': 'Event',
    'PrivateMessageEvent': 'Event',
    'T_State': 'State',
    'ArgPlainText': 'ArgStr',
};
class BaseMatcher {
    constructor(ctx) {
        this.ctx = ctx;
        this.state = new Map();
        this.callbacks = [];
        this.getters = {
            Bot: () => {
                const { Bot } = this.ctx.nonebot.python.pyimport('nonebot.adapters.onebot.v11');
                return Bot(this.session.bot, (data) => {
                    return (0, utils_1.unwrap)(data);
                });
            },
            Event: () => {
                const module = this.ctx.nonebot.python.pyimport('nonebot.adapters.onebot.v11');
                const constructor = this.session.type === 'message'
                    ? this.session.guildId ? module.GroupMessageEvent : module.PrivateMessageEvent
                    : module.Event;
                return constructor(this.session);
            },
            State: () => this.state,
            Matcher: () => this,
            ArgStr: ([name]) => this.state.get(name),
            CommandArg: () => {
                const { create_message } = this.ctx.nonebot.python.pyimport('nonebot.adapters.onebot.v11');
                return create_message(koishi_1.h.parse(this.message));
            },
        };
    }
    getParams(fn) {
        const helpers = this.ctx.nonebot.python.pyimport('nonebot.helpers');
        const params = helpers.get_params(fn).toJs();
        return params.map((param) => ({
            kind: param.kind,
            name: param.name,
            args: param.args.toJs(),
            kwargs: param.kwargs.toJs(),
        }));
    }
    factory(action) {
        const decorate = (fn) => {
            if (!fn.toJs) {
                const callback = this.callbacks.pop();
                this.callbacks.push(() => action(callback));
                return decorate;
            }
            const params = this.getParams(fn);
            const callback = fn.toJs();
            this.callbacks.push(() => action(() => {
                const args = params.map((param) => {
                    var _a, _b;
                    const key = fallbackMap[param.name] || param.name;
                    return (_b = (_a = this.getters)[key]) === null || _b === void 0 ? void 0 : _b.call(_a, param.args, param.kwargs);
                });
                return callback(...args);
            }));
            return decorate;
        };
        return decorate;
    }
    set_arg(key, value) {
        const raw = (0, utils_1.unwrap)(value);
        this.state.set(key, Array.isArray(raw) ? raw.join('') : raw);
    }
    handle() {
        return this.factory(callback => callback());
    }
    async send(...args) {
        const message = koishi_1.h.normalize((0, utils_1.kwarg)('message', args));
        if ((0, utils_1.kwarg)('at_sender', args, 1)) {
            message.unshift(koishi_1.h.at(this.session.userId));
        }
        await this.session.send(message);
    }
    async reject(...args) {
        await this.session.send((0, utils_1.kwarg)('prompt', args));
        throw new NoneBotException('reject');
    }
    async finish(...args) {
        await this.session.send((0, utils_1.kwarg)('message', args));
        throw new NoneBotException('finish');
    }
    async execute(...args) {
        try {
            for (const callback of this.callbacks) {
                await callback();
            }
        }
        catch (e) {
            if (!NoneBotException.check(e))
                logger.warn(e);
        }
    }
}
exports.BaseMatcher = BaseMatcher;
class EventMatcher extends BaseMatcher {
    constructor(ctx, event) {
        super(ctx);
        this.ctx = ctx;
        this.ctx.on(event, async (session) => {
            this.session = session;
            this.state = new Map();
            await this.execute();
        });
    }
}
exports.EventMatcher = EventMatcher;
class MessageMatcher extends BaseMatcher {
    constructor(ctx, predicate) {
        super(ctx);
        this.ctx = ctx;
        this.ctx.middleware(async (session, next) => {
            let result = false;
            try {
                result = predicate((0, utils_1.extractText)(session.elements));
            }
            catch (err) {
                logger.warn(err);
            }
            if (!result)
                return next();
            this.session = session;
            this.state = new Map();
            await this.execute();
        });
    }
}
exports.MessageMatcher = MessageMatcher;
class CommandMatcher extends BaseMatcher {
    constructor(ctx, name) {
        super(ctx);
        this.ctx = ctx;
        this.name = name;
        this.args = Object.create(null);
        this.ctx.command(this.name).action(async ({ session }, ...args) => {
            this.session = session;
            this.state = new Map();
            this.message = args.join(' ');
            await this.execute();
        });
    }
    got(name, { prompt } = {}) {
        return this.factory(async (callback) => {
            if (!this.state.get(name)) {
                if (prompt)
                    await this.session.send(prompt);
                this.state.set(name, await this.session.prompt());
            }
            return callback();
        });
    }
}
exports.CommandMatcher = CommandMatcher;
