import 'reflect-metadata';
import { ArrayValueMap, GenericMap, Key, MergeKey, StringDict } from './def';
export declare type AllDecorators = MethodDecorator & ClassDecorator & PropertyDecorator;
export declare class MetadataSetter<M extends StringDict, AM extends StringDict> {
    private getMetadataInDecorator;
    private setMetadataInDecorator;
    transform<K extends MergeKey<M, AM>, IK extends Key<AM>, GM extends Record<MergeKey<M, AM>, any> = GenericMap<M, AM>>(metadataKey: K, metadataValueFun: (oldValue: GM[K]) => GM[K], keysIndexMeta?: IK): AllDecorators;
    set<K extends MergeKey<M, AM>, IK extends Key<AM>>(metadataKey: K, metadataValue: GenericMap<M, AM>[K], keysIndexMeta?: IK): AllDecorators;
    append<K extends Key<AM>, IK extends Key<AM>>(metadataKey: K, metadataValue: AM[K], keysIndexMeta?: IK): AllDecorators;
    appendUnique<K extends Key<AM>, IK extends Key<AM>>(metadataKey: K, metadataValue: AM[K], keysIndexMeta?: IK): AllDecorators;
    concat<K extends Key<AM>, IK extends Key<AM>>(metadataKey: K, metadataValue: ArrayValueMap<AM>[K], keysIndexMeta?: IK): AllDecorators;
    param<K extends Key<AM>, IK extends Key<AM>>(metadataKey: K, metadataValue: AM[K], keysIndexMeta?: IK): ParameterDecorator;
}
