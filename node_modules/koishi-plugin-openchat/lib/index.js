"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.apply = exports.Config = exports.name = void 0;
const koishi_1 = require("koishi");
exports.name = 'openchat';
const logger = new koishi_1.Logger(exports.name);
exports.Config = koishi_1.Schema.object({
    prefix: koishi_1.Schema.union([
        koishi_1.Schema.array(String),
        koishi_1.Schema.transform(String, (prefix) => [prefix]),
    ]).description('使用特定前缀触发对话。').default(['?', '？']),
    watingMsg: koishi_1.Schema.boolean().description('等待响应前是否提示。').default(false),
    limit: koishi_1.Schema.number().description('风险模型阈值。100 关闭、60 宽松、20 严格。')
        .default(60).max(100).min(0)
});
function apply(ctx, config) {
    ctx.i18n.define('zh', require('./locales/zh'));
    ctx.middleware((session, next) => {
        const { parsed, content } = session;
        if (parsed?.appel)
            return session.execute(`${exports.name} ${parsed.content}`);
        for (const prefix of config.prefix) {
            if (!prefix || !content.startsWith(prefix) || (content === prefix))
                continue;
            return session.execute(`${exports.name} ${content.slice(prefix.length)}`);
        }
        return next();
    });
    const inputModeration = async (limit, input) => {
        const moderation = (await ctx.http.post(`https://chat.elchapo.cn:65502/v2/text-moderation`, { prompt: input })
            .catch(err => logger.error(err)));
        if (!moderation)
            return 'pass';
        for (const [key, value] of Object.entries(moderation.category_scores)) {
            if (value > limit / 100)
                return key;
        }
        return 'pass';
    };
    const getRes = async (input) => {
        let res;
        for (let count = 0; count < 3; count++) {
            try {
                res = await ctx.http.axios('https://chat.elchapo.cn:65502/v2/chat', {
                    method: "POST",
                    headers: {
                        'Content-Type': 'application/json',
                        'api': '42'
                    },
                    data: {
                        prompt: input
                    }
                });
            }
            catch (err) {
                logger.info(err);
            }
            if (res)
                return res.data['message'];
        }
        throw new Error();
    };
    const cmd = ctx.command('openchat <提问内容:text>')
        .action(async ({ session }, input) => {
        if (!input?.trim())
            return session.execute(`help ${exports.name}`);
        if (config.watingMsg)
            session.send(session.text('.wating'));
        const checkReslt = await inputModeration(config.limit, input);
        logger.debug(checkReslt);
        if (checkReslt === 'pass') {
            try {
                await session.send((0, koishi_1.h)('quote', { id: session.messageId }) +
                    await getRes(input));
            }
            catch {
                return session.text('.network-error');
            }
        }
        else {
            return session.text('.prohibited', [session.text(`.${checkReslt}`)]);
        }
    });
}
exports.apply = apply;
