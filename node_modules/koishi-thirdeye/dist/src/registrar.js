"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StarterPlugin = exports.koishiRegistrar = exports.KoishiRegistrar = void 0;
const cordis_decorators_1 = require("cordis-decorators");
const koishi_1 = require("koishi");
const rxjs_session_1 = require("./utility/rxjs-session");
const select_context_1 = require("./utility/select-context");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
class KoishiRegistrar extends cordis_decorators_1.Registrar {
    decorateCommandTransformer(transformer) {
        return (...args) => this.metadata.append('KoishiCommandTransformer', new cordis_decorators_1.RegisterMeta(transformer, args));
    }
    decorateCommandPut(put, pre) {
        return (...args) => (obj, key, i) => {
            const meta = new cordis_decorators_1.RegisterMeta(put, args, {
                pre: pre && new cordis_decorators_1.RegisterMeta(pre, args),
            });
            if (typeof i === 'number') {
                this.metadata.param('KoishiCommandPut', meta)(obj, key, i);
            }
            else {
                this.metadata.set('KoishiCommandPutObject', meta, 'KoishiCommandPutObjectKeys')(obj, key, i);
            }
        };
    }
    methodDecorators() {
        return {
            ...super.methodDecorators(),
            RouterMethod: this.decorateMethod('route', ({ ctx }, fun, method, path) => {
                const _path = path.startsWith('/') ? path : `/${path}`;
                return ctx.router[method](_path, (koaCtx, next) => fun(koaCtx, next));
            }),
            Ws: this.decorateMethod('ws', ({ ctx }, action, path) => ctx.router.ws(path.startsWith('/') ? path : `/${path}`, action)),
            UseMiddleware: this.decorateMethod('middleware', ({ ctx }, fun, prepend) => ctx.middleware((s, next) => (0, rxjs_session_1.sessionRxToPromise)(s, fun(s, next)), prepend)),
            UseBeforeEvent: this.decorateMethod('before', ({ ctx }, fun, event, append) => ctx.before(event, fun, append)),
            UseCommand: this.decorateMethod('command', (info, fun, ...args) => {
                const { ctx, view, obj, key } = info;
                const def = args.shift();
                const desc = typeof args[0] === 'string' ? args.shift() : '';
                const config = args[0];
                const transformers = this.reflector.getProperty('KoishiCommandTransformer', obj, key);
                let command = ctx.command(def, desc, config);
                for (const transformer of transformers) {
                    command = transformer.run(view, ctx, command) || command;
                }
                if (config?.empty) {
                    return command;
                }
                // eslint-disable-next-line @typescript-eslint/ban-types
                const paramTypes = Reflect.getMetadata('design:paramtypes', obj, key);
                const putOptions = this.reflector.getArray('KoishiCommandPut', obj, key);
                for (let i = 0; i < putOptions.length; i++) {
                    const prePutOption = putOptions[i]?.info?.pre;
                    if (!prePutOption) {
                        continue;
                    }
                    const nativeType = paramTypes[i];
                    prePutOption.run(view, { ctx, command, nativeType, view });
                }
                command.action(async (argv, ...args) => {
                    const params = putOptions.map((option, i) => option?.run(view, {
                        ctx,
                        command,
                        nativeType: paramTypes[i],
                        argv,
                        args,
                        view,
                    }));
                    return (0, rxjs_session_1.sessionRxToPromise)(argv.session, fun(...params));
                });
                return command;
            }),
            UsePreset: this.decorateMethod('preset', ({ ctx }, fun, name) => {
                ctx.i18n.preset(name, fun);
                ctx.on('dispose', () => {
                    delete ctx.i18n._presets[name];
                });
            }),
            UseInterval: this.decorateMethod('interval', ({ ctx }, fun, interval) => ctx.setInterval(fun, interval)),
            UseComponent: this.decorateMethod('component', ({ ctx }, fun, name, options = {}) => ctx.component(name, fun, options)),
        };
    }
    selectorDecorators() {
        return {
            OnAnywhere: this.decorateTransformer((ctx) => ctx.any()),
            OnNowhere: this.decorateTransformer((ctx) => ctx.never()),
            OnUser: this.decorateTransformer((ctx, ...values) => ctx.user(...values)),
            OnSelf: this.decorateTransformer((ctx, ...values) => ctx.self(...values)),
            OnGuild: this.decorateTransformer((ctx, ...values) => ctx.guild(...values)),
            OnChannel: this.decorateTransformer((ctx, ...values) => ctx.channel(...values)),
            OnPlatform: this.decorateTransformer((ctx, ...values) => ctx.platform(...values)),
            OnPrivate: this.decorateTransformer((ctx, ...values) => ctx.private(...values)),
            OnSelection: this.decorateTransformer((ctx, selection) => (0, select_context_1.selectContext)(ctx, selection)),
        };
    }
}
exports.KoishiRegistrar = KoishiRegistrar;
exports.koishiRegistrar = new KoishiRegistrar(koishi_1.Context);
exports.StarterPlugin = exports.koishiRegistrar.starterPluginFactory();
//# sourceMappingURL=registrar.js.map