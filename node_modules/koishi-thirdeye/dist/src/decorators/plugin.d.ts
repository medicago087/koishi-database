import { ModelClassType } from 'minato-decorators';
import { Flatten, Keys, Tables } from 'koishi';
export * from 'satori-decorators/dist/src/decorators/plugin';
export declare const DefinePlugin: <T>(options?: import("cordis-decorators").PluginRegistrar.PluginRegistrationOptions<import("koishi").Context, T>) => <C extends import("cordis-decorators").PluginRegistrar.PluginClass<import("koishi").Context, T, any>>(plugin: C) => C & import("cordis-decorators").PluginRegistrar.PluginRegistrationOptions<import("koishi").Context, T>;
export declare const UseModel: (...args: ModelClassType<any>[]) => ClassDecorator;
export declare const MixinModel: <K extends Keys<Tables, any>>(tableName: K, classDict: { [F in Keys<Tables[K], any>]?: ModelClassType<import("cosmokit").Intersect<{ [K_1 in keyof Tables[K][F] & string as `${K_1}`]: { [K_2 in `${K_1}`]?: Tables[K][F][K_1]; } | (Tables[K][F][K_1] extends infer T ? T extends Tables[K][F][K_1] ? T extends Tables[K][F] | import("koishi").Atomic ? never : T extends any[] ? never : string extends keyof T ? never : { [K_3 in keyof T & string as `${K_1}.${K_3}`]: { [K_4 in `${K_1}.${K_3}`]?: T[K_3]; } | (T[K_3] extends infer T_1 ? T_1 extends T[K_3] ? T_1 extends Tables[K][F] | import("koishi").Atomic | T ? never : T_1 extends any[] ? never : string extends keyof T_1 ? never : { [K_5 in keyof T_1 & string as `${K_1}.${K_3}.${K_5}`]: { [K_6 in `${K_1}.${K_3}.${K_5}`]?: T_1[K_5]; } | (T_1[K_5] extends infer T_2 ? T_2 extends T_1[K_5] ? T_2 extends Tables[K][F] | import("koishi").Atomic | T | T_1 ? never : T_2 extends any[] ? never : string extends keyof T_2 ? never : { [K_7 in keyof T_2 & string as `${K_1}.${K_3}.${K_5}.${K_7}`]: { [K_8 in `${K_1}.${K_3}.${K_5}.${K_7}`]?: T_2[K_7]; } | (T_2[K_7] extends infer T_3 ? T_3 extends T_2[K_7] ? T_3 extends Tables[K][F] | import("koishi").Atomic | T | T_1 | T_2 ? never : T_3 extends any[] ? never : string extends keyof T_3 ? never : { [K_9 in keyof T_3 & string as `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}`]: { [K_10 in `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}`]?: T_3[K_9]; } | (T_3[K_9] extends infer T_4 ? T_4 extends T_3[K_9] ? T_4 extends Tables[K][F] | import("koishi").Atomic | T | T_1 | T_2 | T_3 ? never : T_4 extends any[] ? never : string extends keyof T_4 ? never : { [K_11 in keyof T_4 & string as `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}`]: { [K_12 in `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}`]?: T_4[K_11]; } | (T_4[K_11] extends infer T_5 ? T_5 extends T_4[K_11] ? T_5 extends Tables[K][F] | import("koishi").Atomic | T | T_1 | T_2 | T_3 | T_4 ? never : T_5 extends any[] ? never : string extends keyof T_5 ? never : { [K_13 in keyof T_5 & string as `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}`]: { [K_14 in `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}`]?: T_5[K_13]; } | (T_5[K_13] extends infer T_6 ? T_6 extends T_5[K_13] ? T_6 extends Tables[K][F] | import("koishi").Atomic | T | T_1 | T_2 | T_3 | T_4 | T_5 ? never : T_6 extends any[] ? never : string extends keyof T_6 ? never : { [K_15 in keyof T_6 & string as `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${K_15}`]: { [K_16 in `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${K_15}`]?: T_6[K_15]; } | (T_6[K_15] extends infer T_7 ? T_7 extends T_6[K_15] ? T_7 extends Tables[K][F] | import("koishi").Atomic | T | T_1 | T_2 | T_3 | T_4 | T_5 | T_6 ? never : T_7 extends any[] ? never : string extends keyof T_7 ? never : { [K_17 in keyof T_7 & string as `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${K_15}.${K_17}`]: { [K_18 in `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${K_15}.${K_17}`]?: T_7[K_17]; } | (T_7[K_17] extends infer T_8 ? T_8 extends T_7[K_17] ? T_8 extends Tables[K][F] | import("koishi").Atomic | T | T_1 | T_2 | T_3 | T_4 | T_5 | T_6 | T_7 ? never : T_8 extends any[] ? never : string extends keyof T_8 ? never : { [K_19 in keyof T_8 & string as `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${K_15}.${K_17}.${K_19}`]: { [K_20 in `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${K_15}.${K_17}.${K_19}`]?: T_8[K_19]; } | (T_8[K_19] extends infer T_9 ? T_9 extends T_8[K_19] ? T_9 extends Tables[K][F] | import("koishi").Atomic | T | T_1 | T_2 | T_3 | T_4 | T_5 | T_6 | T_7 | T_8 ? never : T_9 extends any[] ? never : string extends keyof T_9 ? never : { [K_21 in keyof T_9 & string as `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${K_15}.${K_17}.${K_19}.${K_21}`]: { [K_22 in `${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${K_15}.${K_17}.${K_19}.${K_21}`]?: T_9[K_21]; } | (T_9[K_21] extends infer T_10 ? T_10 extends T_9[K_21] ? T_10 extends Tables[K][F] | import("koishi").Atomic | T | T_1 | T_2 | T_3 | T_4 | T_5 | T_6 | T_7 | T_8 | T_9 ? never : T_10 extends any[] ? never : string extends keyof T_10 ? never : any[`${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${K_15}.${K_17}.${K_19}.${K_21}.${keyof T_10 & string}`] : never : never); }[`${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${K_15}.${K_17}.${K_19}.${keyof T_9 & string}`] : never : never); }[`${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${K_15}.${K_17}.${keyof T_8 & string}`] : never : never); }[`${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${K_15}.${keyof T_7 & string}`] : never : never); }[`${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${K_13}.${keyof T_6 & string}`] : never : never); }[`${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${K_11}.${keyof T_5 & string}`] : never : never); }[`${K_1}.${K_3}.${K_5}.${K_7}.${K_9}.${keyof T_4 & string}`] : never : never); }[`${K_1}.${K_3}.${K_5}.${K_7}.${keyof T_3 & string}`] : never : never); }[`${K_1}.${K_3}.${K_5}.${keyof T_2 & string}`] : never : never); }[`${K_1}.${K_3}.${keyof T_1 & string}`] : never : never); }[`${K_1}.${keyof T & string}`] : never : never); }[`${keyof Tables[K][F] & string}`]>>; }) => ClassDecorator;
export declare const InjectLogger: (name?: string) => import("typed-reflector").AllDecorators;
