"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReplySession = void 0;
const koishi_1 = require("koishi");
const decorators_1 = require("./decorators");
const registrar_1 = require("./registrar");
class ReplySession extends koishi_1.Session {
    constructor() {
        super(...arguments);
        this.replyMessages = [];
        this.midPromise = new Promise((resolve) => {
            this.midResolver = resolve;
        });
    }
    async process() {
        if (!this.app.lifecycle.isActive)
            return;
        const events = [this.type];
        if (this.subtype) {
            events.unshift(events[0] + '/' + this.subtype);
            if (this.subsubtype) {
                events.unshift(events[0] + '/' + this.subsubtype);
            }
        }
        this.emitPromise = Promise.all(events.map((event) => this.app.root.parallel(this, event, this)));
        return this.waitForPattern();
    }
    async waitForPattern() {
        await Promise.race([
            this.emitPromise.then(() => this.midResolve(true)),
            this.midPromise,
        ]);
        return this.gatherReplyMessages();
    }
    getIdentifier() {
        return `${this.platform}:${this.selfId}:${this.channelId}:${this.userId}`;
    }
    midResolve(finish = false) {
        if (!this.midResolver) {
            return;
        }
        this.midResolver();
        if (finish) {
            delete this.midResolver;
        }
        else {
            this.midPromise = new Promise((resolve) => {
                this.midResolver = resolve;
            });
        }
    }
    async send(content, options = {}) {
        if (!content)
            return;
        options.session = this;
        const children = await this.transform(koishi_1.segment.normalize(content));
        this.replyMessages.push(children.length === 1 ? children[0] : (0, koishi_1.segment)('message', {}, children));
        const messageId = koishi_1.Random.id();
        const sentSession = this.bot.session({
            messageId,
            userId: this.userId,
            timestamp: this.timestamp || Date.now(),
        });
        sentSession.app.emit(sentSession, 'send', sentSession);
        return [messageId];
    }
    gatherReplyMessages() {
        const result = this.replyMessages.filter((m) => !!m);
        this.replyMessages = [];
        return result;
    }
    prompt(...args) {
        if (!this.app.__prompt_resolver__) {
            this.app.root.plugin(PromptResolver);
        }
        const resolver = this.app.__prompt_resolver__;
        const callback = typeof args[0] === 'function'
            ? args.shift()
            : (session) => session.content;
        const options = typeof args[0] === 'number' ? { timeout: args[0] } : args[0] ?? {};
        const timeout = options.timeout ?? this.app.root.options.delay.prompt;
        const identifier = this.getIdentifier();
        const prom = new Promise((resolve) => {
            const prompt = {
                resolver: resolve,
                timeout: setTimeout(() => resolver.resolvePrompt(identifier, undefined), timeout),
                session: this,
                callback,
            };
            resolver.addPrompt(identifier, prompt);
        });
        this.midResolve();
        return prom;
    }
}
exports.ReplySession = ReplySession;
let PromptResolver = class PromptResolver extends (0, registrar_1.StarterPlugin)() {
    constructor() {
        super(...arguments);
        this.prompts = new Map();
    }
    addPrompt(identifier, prompt) {
        const oldPrompt = this.prompts.get(identifier);
        if (oldPrompt) {
            this.resolvePrompt(identifier, undefined).then();
        }
        this.prompts.set(identifier, prompt);
    }
    async handlePrompt(session, next) {
        if (!session.getIdentifier) {
            // not a reply session
            return next();
        }
        const identifier = session.getIdentifier();
        const prompt = await this.resolvePrompt(identifier, session);
        if (!prompt) {
            return next();
        }
        session.replyMessages.push(...(await prompt.session.waitForPattern()));
        return;
    }
    async resolvePrompt(identifier, session) {
        const prompt = this.prompts.get(identifier);
        if (prompt) {
            prompt.resolver(session ? await prompt.callback(session) : undefined);
            clearTimeout(prompt.timeout);
            this.prompts.delete(identifier);
            return prompt;
        }
        return;
    }
};
__decorate([
    (0, decorators_1.UseMiddleware)(true),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [ReplySession, Function]),
    __metadata("design:returntype", Promise)
], PromptResolver.prototype, "handlePrompt", null);
PromptResolver = __decorate([
    (0, decorators_1.Provide)('__prompt_resolver__', { immediate: true }),
    (0, decorators_1.DefinePlugin)()
], PromptResolver);
//# sourceMappingURL=reply-session.js.map