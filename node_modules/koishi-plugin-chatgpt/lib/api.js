"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const expiry_map_1 = __importDefault(require("expiry-map"));
const eventsource_parser_1 = require("eventsource-parser");
const koishi_1 = require("koishi");
const stream_1 = require("stream");
const uuid_1 = require("uuid");
const utils_1 = require("./utils");
const KEY_ACCESS_TOKEN = 'accessToken';
class ChatGPT {
    constructor(ctx, config) {
        this.config = config;
        // stores access tokens for up to 10 seconds before needing to refresh
        this._accessTokenCache = new expiry_map_1.default(10 * 1000);
        this.http = ctx.http.extend(config);
    }
    async getIsAuthenticated() {
        try {
            await this.refreshAccessToken();
            return true;
        }
        catch (err) {
            return false;
        }
    }
    async ensureAuth() {
        return await this.refreshAccessToken();
    }
    /**
     * Sends a message to ChatGPT, waits for the response to resolve, and returns
     * the response.
     *
     * @param message - The plaintext message to send.
     * @param opts.conversationId - Optional ID of the previous message in a conversation
     */
    async sendMessage(conversation) {
        const { conversationId, messageId = (0, uuid_1.v4)(), message } = conversation;
        const accessToken = await this.refreshAccessToken();
        const body = {
            action: 'next',
            conversation_id: conversationId,
            messages: [
                {
                    id: (0, uuid_1.v4)(),
                    role: 'user',
                    content: {
                        content_type: 'text',
                        parts: [message],
                    },
                },
            ],
            model: 'text-davinci-002-render',
            parent_message_id: messageId,
        };
        let data;
        try {
            const resp = await this.http.axios('/backend-api/conversation', {
                method: 'POST',
                responseType: 'stream',
                data: body,
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                    cookie: `cf_clearance=${this.config.cloudflareToken};__Secure-next-auth.session-token=${this.config.sessionToken}`,
                    referer: 'https://chat.openai.com/chat',
                    authority: 'chat.openai.com',
                },
            });
            data = resp.data;
        }
        catch (err) {
            if (koishi_1.Quester.isAxiosError(err)) {
                switch (err.response?.status) {
                    case 401:
                        throw new koishi_1.SessionError('commands.chatgpt.messages.unauthorized');
                    case 404:
                        throw new koishi_1.SessionError('commands.chatgpt.messages.conversation-not-found');
                    case 429:
                        throw new koishi_1.SessionError('commands.chatgpt.messages.too-many-requests');
                    case 500:
                    case 503:
                        throw new koishi_1.SessionError('commands.chatgpt.messages.service-unavailable', [err.response.status]);
                    default:
                        throw err;
                }
            }
        }
        let response = '';
        return await new Promise((resolve, reject) => {
            let messageId;
            let conversationId;
            const parser = (0, eventsource_parser_1.createParser)((event) => {
                if (event.type === 'event') {
                    const { data } = event;
                    if (data === '[DONE]') {
                        return resolve({ message: response, messageId, conversationId });
                    }
                    try {
                        const parsedData = JSON.parse(data);
                        const message = parsedData.message;
                        conversationId = parsedData.conversation_id;
                        if (message) {
                            messageId = message?.id;
                            let text = message?.content?.parts?.[0];
                            if (text) {
                                if (!this.config.markdown) {
                                    text = (0, utils_1.transform)(text);
                                }
                                response = text;
                            }
                        }
                    }
                    catch (err) {
                        reject(err);
                    }
                }
            });
            data.pipe(new stream_1.Writable({
                write(chunk, _encoding, cb) {
                    parser.feed(chunk.toString());
                    cb();
                },
            }));
        });
    }
    async refreshAccessToken() {
        const cachedAccessToken = this._accessTokenCache.get(KEY_ACCESS_TOKEN);
        if (cachedAccessToken) {
            return cachedAccessToken;
        }
        try {
            const res = await this.http.get('/api/auth/session', {
                headers: {
                    cookie: `cf_clearance=${this.config.cloudflareToken};__Secure-next-auth.session-token=${this.config.sessionToken}`,
                    referer: 'https://chat.openai.com/chat',
                    authority: 'chat.openai.com',
                },
            });
            const accessToken = res?.accessToken;
            if (!accessToken) {
                console.warn('no auth token', res);
                throw new Error('Unauthorized');
            }
            this._accessTokenCache.set(KEY_ACCESS_TOKEN, accessToken);
            return accessToken;
        }
        catch (err) {
            throw new Error(`ChatGPT failed to refresh auth token: ${err.toString()}`);
        }
    }
}
(function (ChatGPT) {
    ChatGPT.Config = koishi_1.Schema.object({
        sessionToken: koishi_1.Schema.string().role('secret').description('ChatGPT 会话令牌。').required(),
        cloudflareToken: koishi_1.Schema.string().role('secret').description('Cloudflare 令牌。').required(),
        endpoint: koishi_1.Schema.string().description('ChatGPT API 的地址。').default('https://chat.openai.com'),
        headers: koishi_1.Schema.dict(String).description('要附加的额外请求头。').default({
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36',
        }),
        proxyAgent: koishi_1.Schema.string().role('link').description('使用的代理服务器地址。'),
        markdown: koishi_1.Schema.boolean().hidden().default(false),
    }).description('登录设置');
})(ChatGPT || (ChatGPT = {}));
exports.default = ChatGPT;
