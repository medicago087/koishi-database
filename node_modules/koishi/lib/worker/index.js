var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target2, value) => __defProp(target2, "name", { value, configurable: true });
var __export = (target2, all) => {
  for (var name2 in all)
    __defProp(target2, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/packages/koishi/src/worker/index.ts
var worker_exports = {};
__export(worker_exports, {
  Watcher: () => watcher_default
});
module.exports = __toCommonJS(worker_exports);
var import_core4 = require("@koishijs/core");
var import_loader2 = __toESM(require("@koishijs/loader"));

// koishi/packages/koishi/src/worker/daemon.ts
var daemon_exports = {};
__export(daemon_exports, {
  Config: () => Config,
  apply: () => apply,
  name: () => name
});
var import_core = require("@koishijs/core");

// koishi/packages/koishi/src/locales/zh-CN.yml
var zh_CN_default = { commands: { exit: { description: "停止机器人运行", options: { restart: "重新启动" }, messages: { exiting: "正在关机……", restarting: "正在重启……", restarted: "已成功重启。" } } } };

// koishi/packages/koishi/src/locales/ja-JP.yml
var ja_JP_default = { commands: { exit: { description: "BOT をシャットダウンする。", options: { restart: "BOT を再起動する。" }, messages: { exiting: "シャットダウン中……", restarting: "再起動中……", restarted: "再起動完了。" } } } };

// koishi/packages/koishi/src/locales/fr-FR.yml
var fr_FR_default = { commands: { exit: { description: "Arrêter le robot", options: { restart: "Redémarrer" }, messages: { exiting: "Arrêt en cours …", restarting: "Redémarrage …", restarted: "Redémarré." } } } };

// koishi/packages/koishi/src/locales/zh-TW.yml
var zh_TW_default = { commands: { exit: { description: "關閉機器人", options: { restart: "重新啟動" }, messages: { exiting: "正在關閉……", restarting: "正在重新啟動……", restarted: "已重新啟動。" } } } };

// koishi/packages/koishi/src/worker/daemon.ts
var Config = import_core.Schema.object({
  exitCommand: import_core.Schema.boolean().description("提供退出指令。").default(false),
  autoRestart: import_core.Schema.boolean().description("在运行时崩溃自动重启。").default(true),
  heartbeatInterval: import_core.Schema.number().description("心跳发送间隔。").default(0),
  heartbeatTimeout: import_core.Schema.number().description("心跳超时时间。").default(0)
}).description("守护设置");
import_core.Context.Config.list.push(import_core.Schema.object({
  daemon: Config
}));
var name = "daemon";
function apply(ctx, config2 = {}) {
  function handleSignal(signal) {
    if (config2.autoRestart) {
      process.send({ type: "exit" });
    }
    ctx.logger("app").info(`terminated by ${signal}`);
    ctx.parallel("exit", signal).finally(() => process.exit());
  }
  __name(handleSignal, "handleSignal");
  ctx.i18n.define("zh", zh_CN_default);
  ctx.i18n.define("ja", ja_JP_default);
  ctx.i18n.define("fr", fr_FR_default);
  ctx.i18n.define("zh-TW", zh_TW_default);
  ctx.intersect(() => config2.exitCommand).command("exit", { authority: 4 }).option("restart", "-r").action(async ({ options, session }) => {
    const { channelId, guildId, sid } = session;
    if (!options.restart) {
      await session.send(session.text(".exiting")).catch(import_core.noop);
      process.exit();
    }
    await session.send(session.text(".restarting")).catch(import_core.noop);
    ctx.envData.startMessage = { channelId, guildId, sid, message: session.text(".restarted") };
    ctx.loader.fullReload();
  });
  ctx.on("ready", () => {
    process.send({ type: "start", body: config2 });
    process.on("SIGINT", handleSignal);
    process.on("SIGTERM", handleSignal);
    config2.heartbeatInterval && setInterval(() => {
      process.send({ type: "heartbeat" });
    }, config2.heartbeatInterval);
    if (ctx.envData.startMessage) {
      const { channelId, guildId, sid, message } = ctx.envData.startMessage;
      const dispose = ctx.on("bot-status-updated", (bot) => {
        if (bot.sid !== sid || bot.status !== "online")
          return;
        bot.sendMessage(channelId, message, guildId);
        dispose();
      });
      ctx.envData.startMessage = null;
    }
  });
}
__name(apply, "apply");

// koishi/packages/koishi/src/worker/logger.ts
var import_core2 = require("@koishijs/core");
var Config2 = import_core2.Schema.object({
  levels: import_core2.Schema.any().description("默认的日志输出等级。"),
  showDiff: import_core2.Schema.boolean().description("标注相邻两次日志输出的时间差。"),
  showTime: import_core2.Schema.union([Boolean, String]).default(true).description("输出日志所使用的时间格式。")
}).description("日志设置").hidden();
(0, import_core2.defineProperty)(import_core2.Context.Config, "logger", Config2);
import_core2.Context.Config.list.push(import_core2.Schema.object({
  logger: Config2
}));
var prologue = [];
var target = {
  colors: 3,
  showTime: "yyyy-MM-dd hh:mm:ss",
  print: (text) => prologue.push(text)
};
function prepare(config2 = {}) {
  const { levels } = config2;
  if (typeof levels === "object") {
    import_core2.Logger.levels = levels;
  } else if (typeof levels === "number") {
    import_core2.Logger.levels.base = levels;
  }
  let showTime = config2.showTime;
  if (showTime === true)
    showTime = "yyyy-MM-dd hh:mm:ss";
  if (showTime)
    import_core2.Logger.targets[0].showTime = showTime;
  import_core2.Logger.targets[0].showDiff = config2.showDiff;
  if (process.env.KOISHI_LOG_LEVEL) {
    import_core2.Logger.levels.base = +process.env.KOISHI_LOG_LEVEL;
  }
  function ensureBaseLevel(config3, base) {
    var _a;
    (_a = config3.base) != null ? _a : config3.base = base;
    Object.values(config3).forEach((value) => {
      if (typeof value !== "object")
        return;
      ensureBaseLevel(value, config3.base);
    });
  }
  __name(ensureBaseLevel, "ensureBaseLevel");
  ensureBaseLevel(import_core2.Logger.levels, 2);
  if (process.env.KOISHI_DEBUG) {
    for (const name2 of process.env.KOISHI_DEBUG.split(",")) {
      new import_core2.Logger(name2).level = import_core2.Logger.DEBUG;
    }
  }
  import_core2.Logger.targets.push(target);
  new import_core2.Logger("app").info("%C", `Koishi/${import_core2.version}`);
  import_core2.Logger.timestamp = Date.now();
}
__name(prepare, "prepare");
function apply2(app) {
  app.prologue = prologue;
  app.on("ready", () => {
    (0, import_core2.remove)(import_core2.Logger.targets, target);
  });
}
__name(apply2, "apply");

// koishi/packages/koishi/src/worker/watcher.ts
var import_core3 = require("@koishijs/core");
var import_chokidar = require("chokidar");
var import_path = require("path");
var import_throttle_debounce = require("throttle-debounce");
var import_loader = require("@koishijs/loader");
function loadDependencies(filename, ignored) {
  const dependencies = /* @__PURE__ */ new Set();
  function traverse({ filename: filename2, children }) {
    if (ignored.has(filename2) || dependencies.has(filename2) || filename2.includes("/node_modules/"))
      return;
    dependencies.add(filename2);
    children.forEach(traverse);
  }
  __name(traverse, "traverse");
  traverse(require.cache[filename]);
  return dependencies;
}
__name(loadDependencies, "loadDependencies");
var logger = new import_core3.Logger("watch");
var Watcher = class {
  constructor(ctx, config2) {
    this.ctx = ctx;
    this.config = config2;
    this.stashed = /* @__PURE__ */ new Set();
    ctx.root.watcher = this;
    ctx.on("ready", () => this.start());
    ctx.on("dispose", () => this.stop());
  }
  start() {
    const { loader: loader2 } = this.ctx;
    const { root = "", ignored = [] } = this.config;
    this.root = (0, import_path.resolve)(loader2.baseDir, root);
    this.watcher = (0, import_chokidar.watch)(this.root, {
      ...this.config,
      ignored: ["**/node_modules/**", "**/.git/**", "**/logs/**", ...(0, import_core3.makeArray)(ignored)]
    });
    this.externals = loadDependencies(__filename, new Set(Object.values(loader2.cache)));
    const triggerLocalReload = (0, import_throttle_debounce.debounce)(this.config.debounce, () => this.triggerLocalReload());
    this.watcher.on("change", (path) => {
      const isEntry = path === loader2.filename || path === loader2.envfile;
      if (loader2.suspend && isEntry) {
        loader2.suspend = false;
        return;
      }
      logger.debug("change detected:", (0, import_path.relative)(this.root, path));
      if (isEntry) {
        if (require.cache[path]) {
          this.ctx.loader.fullReload();
        } else {
          const config2 = loader2.readConfig();
          this.ctx.root.state.update(config2);
        }
      } else {
        if (this.externals.has(path)) {
          this.ctx.loader.fullReload();
        } else if (require.cache[path]) {
          this.stashed.add(path);
          triggerLocalReload();
        }
      }
    });
  }
  stop() {
    return this.watcher.close();
  }
  analyzeChanges() {
    const pending = [];
    this.accepted = new Set(this.stashed);
    this.declined = new Set(this.externals);
    this.stashed.forEach((filename) => {
      const { children } = require.cache[filename];
      for (const { filename: filename2 } of children) {
        if (this.accepted.has(filename2) || this.declined.has(filename2) || filename2.includes("/node_modules/"))
          continue;
        pending.push(filename2);
      }
    });
    while (pending.length) {
      let index = 0, hasUpdate = false;
      while (index < pending.length) {
        const filename = pending[index];
        const { children } = require.cache[filename];
        let isDeclined = true, isAccepted = false;
        for (const { filename: filename2 } of children) {
          if (this.declined.has(filename2) || filename2.includes("/node_modules/"))
            continue;
          if (this.accepted.has(filename2)) {
            isAccepted = true;
            break;
          } else {
            isDeclined = false;
            if (!pending.includes(filename2)) {
              hasUpdate = true;
              pending.push(filename2);
            }
          }
        }
        if (isAccepted || isDeclined) {
          hasUpdate = true;
          pending.splice(index, 1);
          if (isAccepted) {
            this.accepted.add(filename);
          } else {
            this.declined.add(filename);
          }
        } else {
          index++;
        }
      }
      if (!hasUpdate)
        break;
    }
    for (const filename of pending) {
      this.declined.add(filename);
    }
  }
  triggerLocalReload() {
    this.analyzeChanges();
    const pending = /* @__PURE__ */ new Map();
    const reloads = /* @__PURE__ */ new Map();
    for (const filename in require.cache) {
      const module2 = require.cache[filename];
      const plugin = (0, import_loader.unwrapExports)(module2.exports);
      const runtime = this.ctx.registry.get(plugin);
      if (!runtime || this.declined.has(filename))
        continue;
      pending.set(filename, runtime);
      if (!plugin["sideEffect"])
        this.declined.add(filename);
    }
    for (const [filename, runtime] of pending) {
      this.declined.delete(filename);
      const dependencies = [...loadDependencies(filename, this.declined)];
      if (!runtime.plugin["sideEffect"])
        this.declined.add(filename);
      if (!dependencies.some((dep) => this.accepted.has(dep)))
        continue;
      dependencies.forEach((dep) => this.accepted.add(dep));
      let isMarked = false;
      const visited = /* @__PURE__ */ new Set();
      const queued = [runtime];
      while (queued.length) {
        const runtime2 = queued.shift();
        if (visited.has(runtime2))
          continue;
        visited.add(runtime2);
        if (reloads.has(runtime2)) {
          isMarked = true;
          break;
        }
        for (const state of runtime2.children) {
          queued.push(state.runtime);
        }
      }
      if (!isMarked)
        reloads.set(runtime, filename);
    }
    const backup = {};
    for (const filename of this.accepted) {
      backup[filename] = require.cache[filename];
      delete require.cache[filename];
    }
    function rollback() {
      for (const filename in backup) {
        require.cache[filename] = backup[filename];
      }
    }
    __name(rollback, "rollback");
    const attempts = {};
    try {
      for (const [, filename] of reloads) {
        attempts[filename] = (0, import_loader.unwrapExports)(require(filename));
      }
    } catch (err) {
      logger.warn(err);
      return rollback();
    }
    try {
      for (const [runtime, filename] of reloads) {
        const path = (0, import_path.relative)(this.root, filename);
        const states = runtime.children.slice();
        try {
          this.ctx.registry.delete(runtime.plugin);
        } catch (err) {
          logger.warn("failed to dispose plugin at %c\n" + (0, import_core3.coerce)(err), path);
        }
        try {
          const plugin = attempts[filename];
          for (const state of states) {
            state.parent.plugin(plugin, state.config);
          }
          logger.info("reload plugin at %c", path);
        } catch (err) {
          logger.warn("failed to reload plugin at %c\n" + (0, import_core3.coerce)(err), path);
          throw err;
        }
      }
    } catch {
      rollback();
      for (const [runtime, filename] of reloads) {
        try {
          this.ctx.registry.delete(attempts[filename]);
          runtime.parent.plugin(runtime.plugin, runtime.config);
        } catch (err) {
          logger.warn(err);
        }
      }
      return;
    }
    this.stashed = /* @__PURE__ */ new Set();
  }
};
__name(Watcher, "Watcher");
((Watcher2) => {
  Watcher2.Config = import_core3.Schema.object({
    root: import_core3.Schema.string().description("要监听的根目录，相对于当前工作路径。"),
    debounce: import_core3.Schema.natural().role("ms").default(100).description("延迟触发更新的等待时间。"),
    ignored: import_core3.Schema.union([
      import_core3.Schema.array(String),
      import_core3.Schema.transform(String, (value) => [value])
    ]).description("要忽略的文件或目录。")
  }).description("热重载设置");
  import_core3.Context.Config.list.push(import_core3.Schema.object({
    watch: Watcher2.Config
  }));
})(Watcher || (Watcher = {}));
var watcher_default = Watcher;

// koishi/packages/koishi/src/worker/index.ts
var import_satori = require("@satorijs/satori");
Object.assign(import_core4.Context.Config.Advanced.dict, {
  timezoneOffset: import_core4.Schema.number().description("时区偏移量 (分钟)。").default(new Date().getTimezoneOffset()),
  stackTraceLimit: import_core4.Schema.natural().description("报错的调用堆栈深度。").default(10),
  plugins: import_core4.Schema.object({}).hidden()
});
function handleException(error) {
  new import_core4.Logger("app").error(error);
  process.exit(1);
}
__name(handleException, "handleException");
process.on("uncaughtException", handleException);
process.on("unhandledRejection", (error) => {
  new import_core4.Logger("app").warn(error);
});
var loader = new import_loader2.default(process.env.KOISHI_CONFIG_FILE);
var config = loader.readConfig();
prepare(config.logger);
if (config.timezoneOffset !== void 0) {
  import_core4.Time.setTimezoneOffset(config.timezoneOffset);
}
if (config.stackTraceLimit !== void 0) {
  Error.stackTraceLimit = config.stackTraceLimit;
}
var addons;
((addons2) => {
  addons2.name = "CLI";
  function apply3(ctx, config2) {
    var _a;
    apply2(ctx.root);
    ctx.plugin(daemon_exports, config2.daemon);
    if (process.env.KOISHI_WATCH_ROOT !== void 0) {
      ((_a = config2.watch) != null ? _a : config2.watch = {}).root = process.env.KOISHI_WATCH_ROOT;
      ctx.plugin(watcher_default, config2.watch);
    }
  }
  addons2.apply = apply3;
  __name(apply3, "apply");
})(addons || (addons = {}));
async function start() {
  const app = await loader.createApp();
  app.plugin(addons, app.config);
  await app.start();
}
__name(start, "start");
start().catch(handleException);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Watcher
});
//# sourceMappingURL=index.js.map
