"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelRegistrar = void 0;
const meta_1 = require("./meta/meta");
require("./model-workaround");
class TableRegistrar {
    constructor(cls, prefix = '') {
        this.cls = cls;
        this.prefix = prefix;
    }
    getTableName() {
        return meta_1.reflector.get('ModelTableName', this.cls);
    }
    getFields() {
        const keys = meta_1.reflector.getArray('ModelFieldKeys', this.cls);
        const result = {};
        for (const key of keys) {
            const field = meta_1.reflector.get('ModelField', this.cls, key);
            if (field) {
                result[this.prefix + key] = field;
            }
        }
        return result;
    }
    getExtensions() {
        const keys = meta_1.reflector.getArray('ModelFieldKeys', this.cls);
        const result = {};
        const primaryKeys = [];
        const uniqueMap = new Map();
        for (const key of keys) {
            // primary keys
            const primary = meta_1.reflector.get('ModelPrimaryKey', this.cls, key);
            if (primary) {
                primaryKeys.push(this.prefix + key);
                if (primary.autoIncrement) {
                    result.autoInc = true;
                }
            }
            // foreign keys
            const foreign = meta_1.reflector.get('ModelForeignKey', this.cls, key);
            if (foreign) {
                if (!result.foreign) {
                    result.foreign = {};
                }
                result.foreign[this.prefix + key] = foreign;
            }
            // unique
            const uniqueEntries = meta_1.reflector.getArray('ModelUnique', this.cls, key);
            for (const unique of uniqueEntries) {
                if (!uniqueMap.has(unique)) {
                    uniqueMap.set(unique, []);
                }
                uniqueMap.get(unique).push(this.prefix + key);
            }
        }
        if (primaryKeys.length) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            result.primary = primaryKeys;
        }
        const uniqueDefs = Array.from(uniqueMap.values());
        if (uniqueDefs.length) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            result.unique = uniqueDefs;
        }
        return result;
    }
    mergeFields(fieldDefs) {
        let result = {};
        for (const fieldDef of fieldDefs) {
            result = { ...result, ...fieldDef };
        }
        return result;
    }
    mergeExtensions(extDefs) {
        const result = {
            autoInc: extDefs.some((ext) => ext.autoInc),
        };
        for (const extDef of extDefs) {
            if (extDef.primary) {
                if (!result.primary) {
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-ignore
                    result.primary = [];
                }
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                result.primary = result.primary.concat(extDef.primary);
            }
            if (extDef.unique) {
                if (!result.unique) {
                    result.unique = [];
                }
                result.unique = result.unique.concat(extDef.unique);
            }
            if (extDef.foreign) {
                result.foreign = { ...(result.foreign || {}), ...extDef.foreign };
            }
        }
        return result;
    }
    getChildDict() {
        const keys = meta_1.reflector.getArray('ChildModelKeys', this.cls);
        const result = {};
        for (const key of keys) {
            const child = meta_1.reflector.get('ChildModel', this.cls, key);
            if (child) {
                result[key] = child;
            }
        }
        return result;
    }
    getInternal() {
        let internal = { [this.prefix]: this.cls.prototype };
        const childDict = this.getChildDict();
        for (const key in childDict) {
            const child = childDict[key];
            const prefix = this.prefix + key + '.';
            const childReg = new TableRegistrar(child, prefix);
            internal = { ...internal, ...childReg.getInternal() };
        }
        return internal;
    }
    getChildModelResults() {
        const children = this.getChildDict();
        const results = [];
        for (const key of Object.keys(children)) {
            const child = children[key];
            if (child) {
                const childRegistrar = new TableRegistrar(child, this.prefix + key + '.');
                results.push(childRegistrar.getModelResult());
            }
        }
        return {
            fields: results.map((r) => r[0]),
            extensions: results.map((r) => r[1]),
        };
    }
    getModelResult() {
        const fields = this.getFields();
        const extensions = this.getExtensions();
        const childResults = this.getChildModelResults();
        return [
            this.mergeFields([fields, ...childResults.fields]),
            this.mergeExtensions([extensions, ...childResults.extensions]),
        ];
    }
}
class ModelRegistrar {
    constructor(model) {
        this.model = model;
    }
    assignInternal(field, internal) {
        if (!field.internal) {
            field.internal = { '': {} };
        }
        Object.assign(field.internal, internal);
    }
    registerModel(cls) {
        const registrar = new TableRegistrar(cls);
        const tableName = registrar.getTableName();
        if (!tableName) {
            throw new Error(`Model of ${cls.name} is not defined`);
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this.model.extend(tableName, ...registrar.getModelResult());
        this.assignInternal(this.model.tables[tableName], registrar.getInternal());
    }
    mixinModel(tableName, classDict) {
        for (const _key in classDict) {
            const key = _key;
            const cls = classDict[key];
            const registrar = new TableRegistrar(cls, key + '.');
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this.model.extend(tableName, ...registrar.getModelResult());
            this.assignInternal(this.model.tables[tableName], registrar.getInternal());
        }
    }
}
exports.ModelRegistrar = ModelRegistrar;
//# sourceMappingURL=register.js.map