var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// koishi/packages/loader/src/browser.ts
import { Context } from "koishi";
import { Loader, unwrapExports } from "shared.mjs";
var BrowserLoader = class extends Loader {
  constructor(baseDir) {
    super();
    this.baseDir = baseDir;
    this.config = { plugins: {} };
  }
  extname;
  meta = /* @__PURE__ */ Object.create(null);
  _initTask;
  async prepare() {
    const [search, market] = await Promise.all([
      fetch(this.baseDir + "/index.json").then((res) => res.json()),
      fetch(this.baseDir + "/market.json").then((res) => res.json())
    ]);
    for (const object of search.objects) {
      if (!object.portable)
        continue;
      const { name } = object.package;
      const key = name.replace(/(koishi-|^@koishijs\/)plugin-/, "");
      const item = market.objects.find((item2) => item2.name === name);
      this.cache[key] = `${this.baseDir}/modules/${name}@${item.version}/index.js`;
      this.meta[key] = item.versions[item.version];
    }
  }
  readConfig() {
    return new Context.Config();
  }
  writeConfig() {
  }
  async resolvePlugin(name) {
    await (this._initTask ||= this.prepare());
    try {
      return unwrapExports(await import(this.cache[name]));
    } catch (err) {
      console.error(err);
    }
  }
  async getPluginMeta(name) {
    await (this._initTask ||= this.prepare());
    return this.meta[name];
  }
  fullReload() {
    console.info("trigger full reload");
  }
};
__name(BrowserLoader, "BrowserLoader");
export {
  BrowserLoader as default
};
//# sourceMappingURL=browser.js.map
