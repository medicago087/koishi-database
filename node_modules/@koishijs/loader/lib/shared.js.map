{
  "version": 3,
  "sources": ["../src/shared.ts", "../src/utils.ts"],
  "sourcesContent": ["import { Context, deepEqual, Dict, Logger, Plugin, resolveConfig } from 'koishi'\nimport { patch, stripModifier } from './utils'\n\nexport * from './utils'\n\ndeclare module 'koishi' {\n  interface Context {\n    loader: Loader\n    delimiter: symbol\n  }\n\n  interface Events {\n    'config'(): void\n  }\n\n  namespace Context {\n    interface Config {\n      name?: string\n      plugins?: Dict\n    }\n  }\n}\n\ndeclare module 'cordis' {\n  // Theoretically, these properties will only appear on `Fork`.\n  // We define them directly on `State` for typing convenience.\n  interface EffectScope<C> {\n    [Loader.kRecord]?: Dict<ForkScope<C>>\n    alias?: string\n  }\n}\n\nconst kUpdate = Symbol('update')\n\nContext.service('loader')\n\nconst logger = new Logger('app')\n\nconst group: Plugin.Object = {\n  name: 'group',\n  reusable: true,\n  apply(ctx, plugins) {\n    ctx.state[Loader.kRecord] ||= Object.create(null)\n\n    for (const name in plugins || {}) {\n      if (name.startsWith('~') || name.startsWith('$')) continue\n      ctx.lifecycle.queue(ctx.loader.reloadPlugin(ctx, name, plugins[name]))\n    }\n\n    ctx.accept((neo) => {\n      // update config reference\n      const old = ctx.state.config\n\n      // update group modifier\n      if (!deepEqual(old.$filter || {}, neo.$filter || {})) {\n        patch.filter(ctx.state.parent, neo.$filter)\n      }\n      if (!deepEqual(old.$isolate || [], neo.$isolate || [])) {\n        patch.isolate(ctx.state.parent, neo.$isolate)\n      }\n\n      // update inner plugins\n      for (const key in { ...old, ...neo }) {\n        if (key.startsWith('~') || key.startsWith('$')) continue\n        const fork = ctx.state[Loader.kRecord][key]\n        if (!fork) {\n          ctx.loader.reloadPlugin(ctx, key, neo[key])\n        } else if (!(key in neo)) {\n          ctx.loader.unloadPlugin(ctx, key)\n        } else {\n          ctx.loader.reloadPlugin(ctx, key, neo[key] || {})\n        }\n      }\n    }, { passive: true })\n  },\n}\n\nexport abstract class Loader {\n  static readonly kRecord = Symbol.for('koishi.loader.record')\n  static readonly exitCode = 51\n\n  public app: Context\n  public baseDir: string\n  public config: Context.Config\n  public entry: Context\n  public suspend = false\n  public filename: string\n  public writable = true\n  public envfile: string\n  public cache: Dict<string> = Object.create(null)\n\n  abstract readConfig(): Context.Config\n  abstract writeConfig(): void\n  abstract resolvePlugin(name: string): Promise<any>\n  abstract fullReload(): void\n\n  interpolate(source: any) {\n    return source\n  }\n\n  private async forkPlugin(name: string, config: any, parent: Context) {\n    const plugin = await this.resolvePlugin(name)\n    if (!plugin) return\n\n    resolveConfig(plugin, config)\n    return parent.plugin(plugin, this.interpolate(config))\n  }\n\n  async reloadPlugin(parent: Context, key: string, config: any) {\n    let fork = parent.state[Loader.kRecord][key]\n    if (fork) {\n      patch(fork.parent, config)\n      fork[kUpdate] = true\n      fork.update(config)\n    } else {\n      logger.info(`apply plugin %c`, key)\n      const name = key.split(':', 1)[0]\n      if (name === 'group') {\n        const ctx = parent.isolate([])\n        ctx.delimiter = Symbol('unique')\n        ctx[ctx.delimiter] = true\n        patch(ctx, config)\n        fork = ctx.plugin(group, config)\n      } else {\n        config = stripModifier(config)\n        fork = await this.forkPlugin(name, config, parent)\n      }\n      if (!fork) return\n      fork.alias = key.slice(name.length + 1)\n      parent.state[Loader.kRecord][key] = fork\n    }\n    return fork\n  }\n\n  unloadPlugin(ctx: Context, key: string) {\n    const fork = ctx.state[Loader.kRecord][key]\n    if (fork) {\n      fork.dispose()\n      delete ctx.state[Loader.kRecord][key]\n      logger.info(`unload plugin %c`, key)\n    }\n  }\n\n  async createApp() {\n    const app = this.app = new Context(this.config)\n    app.loader = this\n    app.baseDir = this.baseDir\n    app.state[Loader.kRecord] = Object.create(null)\n    const fork = await this.reloadPlugin(app, 'group:entry', this.config.plugins)\n    this.entry = fork.ctx\n\n    app.accept(['plugins'], (config) => {\n      fork[kUpdate] = true\n      fork.update(config.plugins)\n    }, { passive: true })\n\n    app.on('dispose', () => {\n      this.fullReload()\n    })\n\n    app.on('internal/update', (fork) => {\n      const record = fork.parent.state[Loader.kRecord]\n      if (!record) return\n      for (const name in record) {\n        if (record[name] !== fork) continue\n        logger.info(`reload plugin %c`, name)\n      }\n    })\n\n    app.on('internal/before-update', (fork, config) => {\n      if (fork[kUpdate]) return delete fork[kUpdate]\n      const record = fork.parent.state[Loader.kRecord]\n      if (!record) return\n      for (const name in record) {\n        if (record[name] !== fork) continue\n        fork.parent.state.config[name] = config\n      }\n    })\n\n    return app\n  }\n}\n", "import { Context, Dict, makeArray, MaybeArray } from 'koishi'\n\nexport function unwrapExports(module: any) {\n  return module?.default || module\n}\n\nexport interface Modifier {\n  $filter?: Selection\n  $isolate?: string[]\n}\n\nconst selectors = ['user', 'guild', 'channel', 'self', 'private', 'platform'] as const\n\nexport type SelectorType = typeof selectors[number]\nexport type SelectorValue = boolean | MaybeArray<string | number>\nexport type BaseSelection = { [K in SelectorType]?: SelectorValue }\n\ninterface Selection extends BaseSelection {\n  and?: Selection[]\n  or?: Selection[]\n  not?: Selection\n}\n\nexport function select(root: Context, options: Selection) {\n  let ctx = root\n\n  // basic selectors\n  for (const type of selectors) {\n    const value = options[type]\n    if (value === true) {\n      ctx = ctx[type]()\n    } else if (value === false) {\n      ctx = ctx.exclude(ctx[type]())\n    } else if (value !== undefined) {\n      // we turn everything into string\n      ctx = ctx[type](...makeArray(value).map(item => '' + item))\n    }\n  }\n\n  // intersect\n  if (options.and) {\n    for (const selection of options.and) {\n      ctx = ctx.intersect(select(root, selection))\n    }\n  }\n\n  // union\n  if (options.or) {\n    let ctx2: Context = ctx.never()\n    for (const selection of options.or) {\n      ctx2 = ctx2.union(select(root, selection))\n    }\n    ctx = ctx.intersect(ctx2)\n  }\n\n  // exclude\n  if (options.not) {\n    ctx = ctx.exclude(select(root, options.not))\n  }\n\n  return ctx\n}\n\nexport function patch(ctx: Context, config: Modifier) {\n  config ||= {}\n  patch.filter(ctx, config.$filter)\n  patch.isolate(ctx, config.$isolate)\n}\n\nexport namespace patch {\n  export function filter(ctx: Context, filter: Selection) {\n    const parent = Object.getPrototypeOf(ctx)\n    if (filter) {\n      ctx.filter = parent.intersect(select(ctx.any(), filter)).filter\n    } else {\n      delete ctx.filter\n    }\n  }\n\n  export function isolate(ctx: Context, isolate: string[]) {\n    const updated: Dict<boolean> = {}\n    const { delimiter } = ctx\n\n    // remove isolation\n    for (const name of Object.keys(ctx.mapping)) {\n      if (isolate?.includes(name)) continue\n      const oldKey = ctx.mapping[name]\n      const value = ctx.root[oldKey]\n      delete ctx.mapping[name]\n      const neoKey = ctx.mapping[name] || name\n      if (value === ctx.root[neoKey]) continue\n      const source = value?.[Context.source]\n      updated[name] = source?.[delimiter]\n      if (updated[name]) {\n        // free right hand side service\n        source[name] = value\n        ctx.root[oldKey] = null\n      }\n    }\n\n    // add isolation\n    for (const name of isolate || []) {\n      if (ctx.mapping[name]) continue\n      const oldKey = ctx.mapping[name] || name\n      const value = ctx.root[oldKey]\n      ctx.mapping[name] = Symbol(name)\n      const neoKey = ctx.mapping[name]\n      if (value === ctx.root[neoKey]) continue\n      const source = value?.[Context.source]\n      updated[name] = source?.[delimiter]\n      if (updated[name]) {\n        // lock right hand side service\n        source[name] = value\n        ctx.root[oldKey] = null\n      }\n    }\n\n    // FIXME\n    const parent = Object.getPrototypeOf(ctx)\n    for (const name in updated) {\n      const self: Context = Object.create(ctx)\n      const source = updated[name] ? parent : ctx\n      self[Context.filter] = (target: Context) => {\n        return source.mapping[name] === target.mapping[name] && updated[name] !== target[delimiter]\n      }\n      ctx.emit(self, 'internal/before-service', name, null)\n      ctx.emit(self, 'internal/service', name, null)\n    }\n  }\n}\n\nexport function stripModifier(config: any) {\n  const result = {}\n  for (const [key, value] of Object.entries(config || {})) {\n    if (key.startsWith('$')) continue\n    result[key] = value\n  }\n  return result\n}\n"],
  "mappings": "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",
  "names": ["import_koishi", "module", "patch", "filter", "isolate", "fork"]
}
