var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// koishi/packages/loader/src/browser.ts
import { makeArray } from "@koishijs/core";
import { Loader, unwrapExports } from "./shared.mjs";
export * from "./shared.mjs";
function resolveName(name) {
  if (name[0] === "@") {
    const [left, right] = name.split("/");
    return [`${left}/koishi-plugin-${right}`];
  } else {
    return [`@koishijs/plugin-${name}`, `koishi-plugin-${name}`];
  }
}
__name(resolveName, "resolveName");
var BrowserLoader = class extends Loader {
  envData = {};
  config = { plugins: {} };
  _initTask;
  constructor() {
    super();
  }
  async prepare() {
    if (!process.env.KOISHI_REGISTRY)
      return;
    const market = await fetch(process.env.KOISHI_REGISTRY + "/market.json").then((res) => res.json());
    for (const object of market.objects) {
      this.cache[object.shortname] = `${process.env.KOISHI_REGISTRY}/modules/${object.name}/index.js`;
    }
  }
  readConfig() {
    return null;
  }
  writeConfig() {
    this.app.emit("config");
  }
  async resolve(name) {
    await (this._initTask ||= this.prepare());
    return this.cache[name];
  }
  async resolvePlugin(name) {
    await (this._initTask ||= this.prepare());
    const urls = process.env.KOISHI_REGISTRY ? makeArray(this.cache[name]) : resolveName(name).map((name2) => `/modules/${name2}/index.js`);
    for (const url of urls) {
      try {
        return unwrapExports(await import(
          /* @vite-ignore */
          url
        ));
      } catch (err) {
      }
    }
    console.error(`cannot resolve plugin ${name}`);
  }
  fullReload() {
    console.info("trigger full reload");
  }
};
__name(BrowserLoader, "BrowserLoader");
export {
  BrowserLoader as default
};
//# sourceMappingURL=browser.mjs.map
