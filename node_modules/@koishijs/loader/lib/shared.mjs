var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// koishi/packages/loader/src/shared.ts
import { Context as Context2, interpolate, isNullable, Logger, resolveConfig, valueMap } from "@koishijs/core";

// koishi/packages/loader/src/utils.ts
import { makeArray } from "@koishijs/core";
function unwrapExports(module) {
  return module?.default || module;
}
__name(unwrapExports, "unwrapExports");
var Modifier;
((Modifier2) => {
  function pick(config, positive = false) {
    const result = {};
    for (const [key, value] of Object.entries(config || {})) {
      if (key.startsWith("$") !== positive)
        continue;
      result[key] = value;
    }
    return result;
  }
  Modifier2.pick = pick;
  __name(pick, "pick");
})(Modifier || (Modifier = {}));
var selectors = ["user", "guild", "channel", "self", "private", "platform"];
function select(root, options) {
  let ctx = root;
  for (const type of selectors) {
    const value = options[type];
    if (value === true) {
      ctx = ctx[type]();
    } else if (value === false) {
      ctx = ctx.exclude(ctx[type]());
    } else if (value !== void 0) {
      ctx = ctx[type](...makeArray(value).map((item) => "" + item));
    }
  }
  if (options.and) {
    for (const selection of options.and) {
      ctx = ctx.intersect(select(root, selection));
    }
  }
  if (options.or) {
    let ctx2 = ctx.never();
    for (const selection of options.or) {
      ctx2 = ctx2.union(select(root, selection));
    }
    ctx = ctx.intersect(ctx2);
  }
  if (options.not) {
    ctx = ctx.exclude(select(root, options.not));
  }
  return ctx;
}
__name(select, "select");
function patch(ctx, config) {
  config ??= {};
  const parent = Object.getPrototypeOf(ctx);
  if (config.$filter) {
    ctx.filter = parent.intersect(select(ctx.root, config.$filter)).filter;
  } else {
    delete ctx.filter;
  }
}
__name(patch, "patch");

// koishi/packages/loader/src/shared.ts
var kUpdate = Symbol("update");
Context2.service("loader");
var logger = new Logger("app");
var group = {
  name: "group",
  reusable: true,
  apply(ctx, plugins) {
    ctx.state[Loader.kRecord] ||= /* @__PURE__ */ Object.create(null);
    for (const name in plugins || {}) {
      if (name.startsWith("~") || name.startsWith("$"))
        continue;
      ctx.lifecycle.queue(ctx.loader.reloadPlugin(ctx, name, plugins[name]));
    }
    ctx.accept((neo) => {
      const old = ctx.state.config;
      for (const key in { ...old, ...neo }) {
        if (key.startsWith("~") || key.startsWith("$"))
          continue;
        const fork = ctx.state[Loader.kRecord][key];
        if (!fork) {
          ctx.loader.reloadPlugin(ctx, key, neo[key]);
        } else if (!(key in neo)) {
          ctx.loader.unloadPlugin(ctx, key);
        } else {
          ctx.loader.reloadPlugin(ctx, key, neo[key] || {});
        }
      }
    }, { passive: true });
  }
};
var _Loader = class {
  envData;
  ctxData = {};
  app;
  baseDir;
  config;
  entry;
  suspend = false;
  filename;
  writable = true;
  envfile;
  cache = /* @__PURE__ */ Object.create(null);
  interpolate(source) {
    if (!this.writable)
      return source;
    if (typeof source === "string") {
      return interpolate(source, this.ctxData, /\$\{\{(.+?)\}\}/g);
    } else if (!source || typeof source !== "object") {
      return source;
    } else if (Array.isArray(source)) {
      return source.map((item) => this.interpolate(item));
    } else {
      return valueMap(source, (item) => this.interpolate(item));
    }
  }
  async forkPlugin(name, config, parent) {
    const plugin = await this.resolvePlugin(name);
    if (!plugin)
      return;
    resolveConfig(plugin, config);
    return parent.plugin(plugin, this.interpolate(config));
  }
  isTruthyLike(expr) {
    if (isNullable(expr))
      return true;
    return !!this.interpolate(`\${{ ${expr} }}`);
  }
  async reloadPlugin(parent, key, config) {
    let fork = parent.state[_Loader.kRecord][key];
    if (fork) {
      if (!this.isTruthyLike(config?.$if)) {
        this.unloadPlugin(parent, key);
        return;
      }
      patch(fork.parent, config);
      fork[kUpdate] = true;
      if (fork.runtime.plugin !== group) {
        config = Modifier.pick(config, false);
      }
      fork.update(config);
    } else {
      if (!this.isTruthyLike(config?.$if))
        return;
      logger.info(`apply plugin %c`, key);
      const name = key.split(":", 1)[0];
      const ctx = parent.extend();
      patch(ctx, config);
      if (name === "group") {
        fork = ctx.plugin(group, config);
      } else {
        config = Modifier.pick(config, false);
        fork = await this.forkPlugin(name, config, ctx);
      }
      if (!fork)
        return;
      fork.alias = key.slice(name.length + 1);
      parent.state[_Loader.kRecord][key] = fork;
    }
    return fork;
  }
  unloadPlugin(ctx, key) {
    const fork = ctx.state[_Loader.kRecord][key];
    if (fork) {
      fork.dispose();
      delete ctx.state[_Loader.kRecord][key];
      logger.info(`unload plugin %c`, key);
    }
  }
  async createApp() {
    const app = this.app = new Context2(this.interpolate(this.config));
    app.loader = this;
    app.baseDir = this.baseDir;
    app.envData = this.envData;
    app.state[_Loader.kRecord] = /* @__PURE__ */ Object.create(null);
    const fork = await this.reloadPlugin(app, "group:entry", this.config.plugins);
    this.entry = fork.ctx;
    app.accept(["plugins"], (config) => {
      this.reloadPlugin(app, "group:entry", config.plugins);
    }, { passive: true });
    app.on("dispose", () => {
      this.fullReload();
    });
    app.on("internal/update", (fork2) => {
      const record = fork2.parent.state[_Loader.kRecord];
      if (!record)
        return;
      for (const name in record) {
        if (record[name] !== fork2)
          continue;
        logger.info(`reload plugin %c`, name);
      }
    });
    app.on("internal/before-update", (fork2, config) => {
      if (fork2[kUpdate])
        return delete fork2[kUpdate];
      const record = fork2.parent.state[_Loader.kRecord];
      if (!record)
        return;
      for (const name in record) {
        if (record[name] !== fork2)
          continue;
        const simplify = fork2.runtime.schema?.simplify;
        fork2.parent.state.config[name] = {
          ...Modifier.pick(fork2.parent.state.config[name], true),
          ...simplify ? simplify(config) : config
        };
      }
    });
    return app;
  }
};
var Loader = _Loader;
__name(Loader, "Loader");
__publicField(Loader, "kRecord", Symbol.for("koishi.loader.record"));
__publicField(Loader, "exitCode", 51);
export {
  Loader,
  Modifier,
  patch,
  select,
  unwrapExports
};
//# sourceMappingURL=shared.mjs.map
