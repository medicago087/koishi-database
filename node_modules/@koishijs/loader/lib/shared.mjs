var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// koishi/packages/loader/src/shared.ts
import { Context as Context2, deepEqual, Logger, resolveConfig } from "koishi";

// koishi/packages/loader/src/utils.ts
import { Context, makeArray } from "koishi";
function unwrapExports(module) {
  return module?.default || module;
}
__name(unwrapExports, "unwrapExports");
var selectors = ["user", "guild", "channel", "self", "private", "platform"];
function select(root, options) {
  let ctx = root;
  for (const type of selectors) {
    const value = options[type];
    if (value === true) {
      ctx = ctx[type]();
    } else if (value === false) {
      ctx = ctx.exclude(ctx[type]());
    } else if (value !== void 0) {
      ctx = ctx[type](...makeArray(value).map((item) => "" + item));
    }
  }
  if (options.and) {
    for (const selection of options.and) {
      ctx = ctx.intersect(select(root, selection));
    }
  }
  if (options.or) {
    let ctx2 = ctx.never();
    for (const selection of options.or) {
      ctx2 = ctx2.union(select(root, selection));
    }
    ctx = ctx.intersect(ctx2);
  }
  if (options.not) {
    ctx = ctx.exclude(select(root, options.not));
  }
  return ctx;
}
__name(select, "select");
function patch(ctx, config) {
  config ||= {};
  patch.filter(ctx, config.$filter);
  patch.isolate(ctx, config.$isolate);
}
__name(patch, "patch");
((patch2) => {
  function filter(ctx, filter2) {
    const parent = Object.getPrototypeOf(ctx);
    if (filter2) {
      ctx.filter = parent.intersect(select(ctx.any(), filter2)).filter;
    } else {
      delete ctx.filter;
    }
  }
  patch2.filter = filter;
  __name(filter, "filter");
  function isolate(ctx, isolate2) {
    const updated = {};
    const { delimiter } = ctx;
    for (const name of Object.keys(ctx.mapping)) {
      if (isolate2?.includes(name))
        continue;
      const oldKey = ctx.mapping[name];
      const value = ctx.root[oldKey];
      delete ctx.mapping[name];
      const neoKey = ctx.mapping[name] || name;
      if (value === ctx.root[neoKey])
        continue;
      const source = value?.[Context.source];
      updated[name] = source?.[delimiter];
      if (updated[name]) {
        source[name] = value;
        ctx.root[oldKey] = null;
      }
    }
    for (const name of isolate2 || []) {
      if (ctx.mapping[name])
        continue;
      const oldKey = ctx.mapping[name] || name;
      const value = ctx.root[oldKey];
      ctx.mapping[name] = Symbol(name);
      const neoKey = ctx.mapping[name];
      if (value === ctx.root[neoKey])
        continue;
      const source = value?.[Context.source];
      updated[name] = source?.[delimiter];
      if (updated[name]) {
        source[name] = value;
        ctx.root[oldKey] = null;
      }
    }
    const parent = Object.getPrototypeOf(ctx);
    for (const name in updated) {
      const self = Object.create(ctx);
      const source = updated[name] ? parent : ctx;
      self[Context.filter] = (target) => {
        return source.mapping[name] === target.mapping[name] && updated[name] !== target[delimiter];
      };
      ctx.emit(self, "internal/before-service", name, null);
      ctx.emit(self, "internal/service", name, null);
    }
  }
  patch2.isolate = isolate;
  __name(isolate, "isolate");
})(patch || (patch = {}));
function stripModifier(config) {
  const result = {};
  for (const [key, value] of Object.entries(config || {})) {
    if (key.startsWith("$"))
      continue;
    result[key] = value;
  }
  return result;
}
__name(stripModifier, "stripModifier");

// koishi/packages/loader/src/shared.ts
var kUpdate = Symbol("update");
Context2.service("loader");
var logger = new Logger("app");
var group = {
  name: "group",
  reusable: true,
  apply(ctx, plugins) {
    ctx.state[Loader.kRecord] ||= /* @__PURE__ */ Object.create(null);
    for (const name in plugins || {}) {
      if (name.startsWith("~") || name.startsWith("$"))
        continue;
      ctx.lifecycle.queue(ctx.loader.reloadPlugin(ctx, name, plugins[name]));
    }
    ctx.accept((neo) => {
      const old = ctx.state.config;
      if (!deepEqual(old.$filter || {}, neo.$filter || {})) {
        patch.filter(ctx.state.parent, neo.$filter);
      }
      if (!deepEqual(old.$isolate || [], neo.$isolate || [])) {
        patch.isolate(ctx.state.parent, neo.$isolate);
      }
      for (const key in { ...old, ...neo }) {
        if (key.startsWith("~") || key.startsWith("$"))
          continue;
        const fork = ctx.state[Loader.kRecord][key];
        if (!fork) {
          ctx.loader.reloadPlugin(ctx, key, neo[key]);
        } else if (!(key in neo)) {
          ctx.loader.unloadPlugin(ctx, key);
        } else {
          ctx.loader.reloadPlugin(ctx, key, neo[key] || {});
        }
      }
    }, { passive: true });
  }
};
var _Loader = class {
  app;
  baseDir;
  config;
  entry;
  suspend = false;
  filename;
  writable = true;
  envfile;
  cache = /* @__PURE__ */ Object.create(null);
  interpolate(source) {
    return source;
  }
  async forkPlugin(name, config, parent) {
    const plugin = await this.resolvePlugin(name);
    if (!plugin)
      return;
    resolveConfig(plugin, config);
    return parent.plugin(plugin, this.interpolate(config));
  }
  async reloadPlugin(parent, key, config) {
    let fork = parent.state[_Loader.kRecord][key];
    if (fork) {
      patch(fork.parent, config);
      fork[kUpdate] = true;
      fork.update(config);
    } else {
      logger.info(`apply plugin %c`, key);
      const name = key.split(":", 1)[0];
      if (name === "group") {
        const ctx = parent.isolate([]);
        ctx.delimiter = Symbol("unique");
        ctx[ctx.delimiter] = true;
        patch(ctx, config);
        fork = ctx.plugin(group, config);
      } else {
        config = stripModifier(config);
        fork = await this.forkPlugin(name, config, parent);
      }
      if (!fork)
        return;
      fork.alias = key.slice(name.length + 1);
      parent.state[_Loader.kRecord][key] = fork;
    }
    return fork;
  }
  unloadPlugin(ctx, key) {
    const fork = ctx.state[_Loader.kRecord][key];
    if (fork) {
      fork.dispose();
      delete ctx.state[_Loader.kRecord][key];
      logger.info(`unload plugin %c`, key);
    }
  }
  async createApp() {
    const app = this.app = new Context2(this.config);
    app.loader = this;
    app.baseDir = this.baseDir;
    app.state[_Loader.kRecord] = /* @__PURE__ */ Object.create(null);
    const fork = await this.reloadPlugin(app, "group:entry", this.config.plugins);
    this.entry = fork.ctx;
    app.accept(["plugins"], (config) => {
      fork[kUpdate] = true;
      fork.update(config.plugins);
    }, { passive: true });
    app.on("dispose", () => {
      this.fullReload();
    });
    app.on("internal/update", (fork2) => {
      const record = fork2.parent.state[_Loader.kRecord];
      if (!record)
        return;
      for (const name in record) {
        if (record[name] !== fork2)
          continue;
        logger.info(`reload plugin %c`, name);
      }
    });
    app.on("internal/before-update", (fork2, config) => {
      if (fork2[kUpdate])
        return delete fork2[kUpdate];
      const record = fork2.parent.state[_Loader.kRecord];
      if (!record)
        return;
      for (const name in record) {
        if (record[name] !== fork2)
          continue;
        const simplify = fork2.runtime.schema?.simplify;
        fork2.parent.state.config[name] = simplify ? simplify(config) : config;
      }
    });
    return app;
  }
};
var Loader = _Loader;
__name(Loader, "Loader");
__publicField(Loader, "kRecord", Symbol.for("koishi.loader.record"));
__publicField(Loader, "exitCode", 51);
export {
  Loader,
  patch,
  select,
  stripModifier,
  unwrapExports
};
//# sourceMappingURL=shared.mjs.map
