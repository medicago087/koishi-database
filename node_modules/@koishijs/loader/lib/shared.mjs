var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// koishi/packages/loader/src/shared.ts
import { Context, interpolate, isNullable, Logger, resolveConfig, valueMap } from "@koishijs/core";
function unwrapExports(module) {
  return module?.default || module;
}
__name(unwrapExports, "unwrapExports");
function separate(source, isGroup = false) {
  const config = {}, meta = {};
  for (const [key, value] of Object.entries(source || {})) {
    if (key.startsWith("$")) {
      meta[key] = value;
    } else {
      config[key] = value;
    }
  }
  return [isGroup ? source : config, meta];
}
__name(separate, "separate");
var kUpdate = Symbol("update");
Context.service("loader");
var logger = new Logger("app");
var group = {
  name: "group",
  reusable: true,
  apply(ctx, plugins) {
    ctx.state[Loader.kRecord] ||= /* @__PURE__ */ Object.create(null);
    for (const name in plugins || {}) {
      if (name.startsWith("~") || name.startsWith("$"))
        continue;
      ctx.lifecycle.queue(ctx.loader.reloadPlugin(ctx, name, plugins[name]));
    }
    ctx.accept((neo) => {
      const old = ctx.state.config;
      for (const key in { ...old, ...neo }) {
        if (key.startsWith("~") || key.startsWith("$"))
          continue;
        const fork = ctx.state[Loader.kRecord][key];
        if (!fork) {
          ctx.loader.reloadPlugin(ctx, key, neo[key]);
        } else if (!(key in neo)) {
          ctx.loader.unloadPlugin(ctx, key);
        } else {
          ctx.loader.reloadPlugin(ctx, key, neo[key] || {});
        }
      }
    }, { passive: true });
  }
};
var _Loader = class {
  envData;
  ctxData = {};
  app;
  baseDir;
  config;
  entry;
  suspend = false;
  filename;
  writable = true;
  envfile;
  cache = /* @__PURE__ */ Object.create(null);
  interpolate(source) {
    if (!this.writable)
      return source;
    if (typeof source === "string") {
      return interpolate(source, this.ctxData, /\$\{\{(.+?)\}\}/g);
    } else if (!source || typeof source !== "object") {
      return source;
    } else if (Array.isArray(source)) {
      return source.map((item) => this.interpolate(item));
    } else {
      return valueMap(source, (item) => this.interpolate(item));
    }
  }
  async forkPlugin(name, config, parent) {
    const plugin = await this.resolvePlugin(name);
    if (!plugin)
      return;
    resolveConfig(plugin, config);
    return parent.plugin(plugin, this.interpolate(config));
  }
  isTruthyLike(expr) {
    if (isNullable(expr))
      return true;
    return !!this.interpolate(`\${{ ${expr} }}`);
  }
  async reloadPlugin(parent, key, source) {
    let fork = parent.state[_Loader.kRecord][key];
    const name = key.split(":", 1)[0];
    const [config, meta] = separate(source, name === "group");
    if (fork) {
      if (!this.isTruthyLike(meta.$if)) {
        this.unloadPlugin(parent, key);
        return;
      }
      fork[kUpdate] = true;
      fork.update(config);
    } else {
      if (!this.isTruthyLike(meta.$if))
        return;
      logger.info(`apply plugin %c`, key);
      const ctx = parent.extend();
      if (name === "group") {
        fork = ctx.plugin(group, config);
      } else {
        fork = await this.forkPlugin(name, config, ctx);
      }
      if (!fork)
        return;
      fork.alias = key.slice(name.length + 1);
      parent.state[_Loader.kRecord][key] = fork;
    }
    fork.parent.filter = (session) => {
      return parent.filter(session) && (!meta.$filter || session.resolve(meta.$filter));
    };
    return fork;
  }
  unloadPlugin(ctx, key) {
    const fork = ctx.state[_Loader.kRecord][key];
    if (fork) {
      fork.dispose();
      delete ctx.state[_Loader.kRecord][key];
      logger.info(`unload plugin %c`, key);
    }
  }
  async createApp() {
    const app = this.app = new Context(this.interpolate(this.config));
    app.loader = this;
    app.baseDir = this.baseDir;
    app.envData = this.envData;
    app.state[_Loader.kRecord] = /* @__PURE__ */ Object.create(null);
    const fork = await this.reloadPlugin(app, "group:entry", this.config.plugins);
    this.entry = fork.ctx;
    app.accept(["plugins"], (config) => {
      this.reloadPlugin(app, "group:entry", config.plugins);
    }, { passive: true });
    app.on("dispose", () => {
      this.fullReload();
    });
    app.on("internal/update", (fork2) => {
      const record = fork2.parent.state[_Loader.kRecord];
      if (!record)
        return;
      for (const name in record) {
        if (record[name] !== fork2)
          continue;
        logger.info(`reload plugin %c`, name);
      }
    });
    app.on("internal/before-update", (fork2, config) => {
      if (fork2[kUpdate])
        return delete fork2[kUpdate];
      const record = fork2.parent.state[_Loader.kRecord];
      if (!record)
        return;
      for (const name in record) {
        if (record[name] !== fork2)
          continue;
        const simplify = fork2.runtime.schema?.simplify;
        fork2.parent.state.config[name] = {
          ...separate(fork2.parent.state.config[name])[1],
          ...simplify ? simplify(config) : config
        };
      }
    });
    return app;
  }
};
var Loader = _Loader;
__name(Loader, "Loader");
__publicField(Loader, "kRecord", Symbol.for("koishi.loader.record"));
__publicField(Loader, "exitCode", 51);
export {
  Loader,
  unwrapExports
};
//# sourceMappingURL=shared.mjs.map
