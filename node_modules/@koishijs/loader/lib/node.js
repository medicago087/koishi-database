var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/packages/loader/src/node.ts
var node_exports = {};
__export(node_exports, {
  default: () => NodeLoader
});
module.exports = __toCommonJS(node_exports);
var import_fs = require("fs");
var import_path = require("path");
var import_koishi = require("koishi");
var import_shared = require("./shared");
var dotenv = __toESM(require("dotenv"));
var yaml = __toESM(require("js-yaml"));
var import_ns_require = __toESM(require("ns-require"));
__reExport(node_exports, require("./shared"), module.exports);
var logger = new import_koishi.Logger("app");
var context = {
  env: process.env
};
var writableExts = [".json", ".yml", ".yaml"];
var supportedExts = [".js", ".json", ".ts", ".coffee", ".yaml", ".yml"];
var NodeLoader = class extends import_shared.Loader {
  constructor(filename) {
    super();
    this.baseDir = process.cwd();
    if (filename) {
      filename = (0, import_path.resolve)(this.baseDir, filename);
      const stats = (0, import_fs.statSync)(filename);
      if (stats.isFile()) {
        this.filename = filename;
        this.baseDir = (0, import_path.dirname)(filename);
        this.extname = (0, import_path.extname)(filename);
        if (!supportedExts.includes(this.extname)) {
          throw new Error("extension not supported");
        }
      } else {
        this.baseDir = filename;
        this.findConfig();
      }
    } else {
      this.findConfig();
    }
    this.writable = this.checkWritable();
    this.envfile = (0, import_path.resolve)(this.baseDir, ".env");
    this.scope = (0, import_ns_require.default)({
      namespace: "koishi",
      prefix: "plugin",
      official: "koishijs",
      dirname: this.baseDir
    });
  }
  checkWritable() {
    if (!writableExts.includes(this.extname))
      return false;
    try {
      (0, import_fs.accessSync)(this.filename, import_fs.constants.W_OK);
      return true;
    } catch {
      return false;
    }
  }
  findConfig() {
    const files = (0, import_fs.readdirSync)(this.baseDir);
    for (const basename of ["koishi.config", "koishi"]) {
      for (const extname2 of supportedExts) {
        if (files.includes(basename + extname2)) {
          this.extname = extname2;
          this.filename = this.baseDir + "/" + basename + extname2;
          return;
        }
      }
    }
    throw new Error("config file not found");
  }
  interpolate(source) {
    if (typeof source === "string") {
      return (0, import_koishi.interpolate)(source, context, /\$\{\{(.+?)\}\}/g);
    } else if (!source || typeof source !== "object") {
      return source;
    } else if (Array.isArray(source)) {
      return source.map((item) => this.interpolate(item));
    } else {
      return (0, import_koishi.valueMap)(source, (item) => this.interpolate(item));
    }
  }
  readConfig() {
    dotenv.config({ path: this.envfile });
    if ([".yaml", ".yml"].includes(this.extname)) {
      this.config = yaml.load((0, import_fs.readFileSync)(this.filename, "utf8"));
    } else if ([".json"].includes(this.extname)) {
      this.config = JSON.parse((0, import_fs.readFileSync)(this.filename, "utf8"));
    } else {
      const module2 = require(this.filename);
      this.config = module2.default || module2;
    }
    let resolved = new import_koishi.Context.Config(this.config);
    if (this.writable) {
      resolved = new import_koishi.Context.Config(this.interpolate(this.config));
    }
    return resolved;
  }
  writeConfig() {
    this.app.emit("config");
    this.suspend = true;
    if (!this.writable)
      throw new Error("cannot overwrite readonly config");
    if (this.extname === ".json") {
      (0, import_fs.writeFileSync)(this.filename, JSON.stringify(this.config, null, 2));
    } else {
      (0, import_fs.writeFileSync)(this.filename, yaml.dump(this.config));
    }
  }
  async resolvePlugin(name) {
    var _a;
    try {
      (_a = this.cache)[name] || (_a[name] = this.scope.resolve(name));
    } catch (err) {
      logger.error(err.message);
      return;
    }
    return (0, import_shared.unwrapExports)(require(this.cache[name]));
  }
  fullReload() {
    logger.info("trigger full reload");
    process.exit(import_shared.Loader.exitCode);
  }
};
__name(NodeLoader, "NodeLoader");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=node.js.map
