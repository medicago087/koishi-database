var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/packages/loader/src/shared.ts
var shared_exports = {};
__export(shared_exports, {
  Loader: () => Loader,
  Modifier: () => Modifier,
  patch: () => patch,
  select: () => select,
  unwrapExports: () => unwrapExports
});
module.exports = __toCommonJS(shared_exports);
var import_core2 = require("@koishijs/core");

// koishi/packages/loader/src/utils.ts
var import_core = require("@koishijs/core");
function unwrapExports(module2) {
  return (module2 == null ? void 0 : module2.default) || module2;
}
__name(unwrapExports, "unwrapExports");
var Modifier;
((Modifier2) => {
  function pick(config, positive = false) {
    const result = {};
    for (const [key, value] of Object.entries(config || {})) {
      if (key.startsWith("$") !== positive)
        continue;
      result[key] = value;
    }
    return result;
  }
  Modifier2.pick = pick;
  __name(pick, "pick");
})(Modifier || (Modifier = {}));
var selectors = ["user", "guild", "channel", "self", "private", "platform"];
function select(root, options) {
  let ctx = root;
  for (const type of selectors) {
    const value = options[type];
    if (value === true) {
      ctx = ctx[type]();
    } else if (value === false) {
      ctx = ctx.exclude(ctx[type]());
    } else if (value !== void 0) {
      ctx = ctx[type](...(0, import_core.makeArray)(value).map((item) => "" + item));
    }
  }
  if (options.and) {
    for (const selection of options.and) {
      ctx = ctx.intersect(select(root, selection));
    }
  }
  if (options.or) {
    let ctx2 = ctx.never();
    for (const selection of options.or) {
      ctx2 = ctx2.union(select(root, selection));
    }
    ctx = ctx.intersect(ctx2);
  }
  if (options.not) {
    ctx = ctx.exclude(select(root, options.not));
  }
  return ctx;
}
__name(select, "select");
function patch(ctx, config) {
  config != null ? config : config = {};
  const parent = Object.getPrototypeOf(ctx);
  if (config.$filter) {
    ctx.filter = parent.intersect(select(ctx.root, config.$filter)).filter;
  } else {
    delete ctx.filter;
  }
}
__name(patch, "patch");

// koishi/packages/loader/src/shared.ts
var kUpdate = Symbol("update");
import_core2.Context.service("loader");
var logger = new import_core2.Logger("app");
var group = {
  name: "group",
  reusable: true,
  apply(ctx, plugins) {
    var _a, _b;
    (_a = ctx.state)[_b = Loader.kRecord] || (_a[_b] = /* @__PURE__ */ Object.create(null));
    for (const name in plugins || {}) {
      if (name.startsWith("~") || name.startsWith("$"))
        continue;
      ctx.lifecycle.queue(ctx.loader.reloadPlugin(ctx, name, plugins[name]));
    }
    ctx.accept((neo) => {
      const old = ctx.state.config;
      for (const key in { ...old, ...neo }) {
        if (key.startsWith("~") || key.startsWith("$"))
          continue;
        const fork = ctx.state[Loader.kRecord][key];
        if (!fork) {
          ctx.loader.reloadPlugin(ctx, key, neo[key]);
        } else if (!(key in neo)) {
          ctx.loader.unloadPlugin(ctx, key);
        } else {
          ctx.loader.reloadPlugin(ctx, key, neo[key] || {});
        }
      }
    }, { passive: true });
  }
};
var _Loader = class {
  constructor() {
    this.ctxData = {};
    this.suspend = false;
    this.writable = true;
    this.cache = /* @__PURE__ */ Object.create(null);
  }
  interpolate(source) {
    if (!this.writable)
      return source;
    if (typeof source === "string") {
      return (0, import_core2.interpolate)(source, this.ctxData, /\$\{\{(.+?)\}\}/g);
    } else if (!source || typeof source !== "object") {
      return source;
    } else if (Array.isArray(source)) {
      return source.map((item) => this.interpolate(item));
    } else {
      return (0, import_core2.valueMap)(source, (item) => this.interpolate(item));
    }
  }
  async forkPlugin(name, config, parent) {
    const plugin = await this.resolvePlugin(name);
    if (!plugin)
      return;
    (0, import_core2.resolveConfig)(plugin, config);
    return parent.plugin(plugin, this.interpolate(config));
  }
  isTruthyLike(expr) {
    if ((0, import_core2.isNullable)(expr))
      return true;
    return !!this.interpolate(`\${{ ${expr} }}`);
  }
  async reloadPlugin(parent, key, config) {
    let fork = parent.state[_Loader.kRecord][key];
    if (fork) {
      if (!this.isTruthyLike(config == null ? void 0 : config.$if)) {
        this.unloadPlugin(parent, key);
        return;
      }
      patch(fork.parent, config);
      fork[kUpdate] = true;
      if (fork.runtime.plugin !== group) {
        config = Modifier.pick(config, false);
      }
      fork.update(config);
    } else {
      if (!this.isTruthyLike(config == null ? void 0 : config.$if))
        return;
      logger.info(`apply plugin %c`, key);
      const name = key.split(":", 1)[0];
      const ctx = parent.extend();
      patch(ctx, config);
      if (name === "group") {
        fork = ctx.plugin(group, config);
      } else {
        config = Modifier.pick(config, false);
        fork = await this.forkPlugin(name, config, ctx);
      }
      if (!fork)
        return;
      fork.alias = key.slice(name.length + 1);
      parent.state[_Loader.kRecord][key] = fork;
    }
    return fork;
  }
  unloadPlugin(ctx, key) {
    const fork = ctx.state[_Loader.kRecord][key];
    if (fork) {
      fork.dispose();
      delete ctx.state[_Loader.kRecord][key];
      logger.info(`unload plugin %c`, key);
    }
  }
  async createApp() {
    const app = this.app = new import_core2.Context(this.interpolate(this.config));
    app.loader = this;
    app.baseDir = this.baseDir;
    app.envData = this.envData;
    app.state[_Loader.kRecord] = /* @__PURE__ */ Object.create(null);
    const fork = await this.reloadPlugin(app, "group:entry", this.config.plugins);
    this.entry = fork.ctx;
    app.accept(["plugins"], (config) => {
      this.reloadPlugin(app, "group:entry", config.plugins);
    }, { passive: true });
    app.on("dispose", () => {
      this.fullReload();
    });
    app.on("internal/update", (fork2) => {
      const record = fork2.parent.state[_Loader.kRecord];
      if (!record)
        return;
      for (const name in record) {
        if (record[name] !== fork2)
          continue;
        logger.info(`reload plugin %c`, name);
      }
    });
    app.on("internal/before-update", (fork2, config) => {
      var _a;
      if (fork2[kUpdate])
        return delete fork2[kUpdate];
      const record = fork2.parent.state[_Loader.kRecord];
      if (!record)
        return;
      for (const name in record) {
        if (record[name] !== fork2)
          continue;
        const simplify = (_a = fork2.runtime.schema) == null ? void 0 : _a.simplify;
        fork2.parent.state.config[name] = {
          ...Modifier.pick(fork2.parent.state.config[name], true),
          ...simplify ? simplify(config) : config
        };
      }
    });
    return app;
  }
};
var Loader = _Loader;
__name(Loader, "Loader");
Loader.kRecord = Symbol.for("koishi.loader.record");
Loader.exitCode = 51;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Loader,
  Modifier,
  patch,
  select,
  unwrapExports
});
//# sourceMappingURL=shared.js.map
