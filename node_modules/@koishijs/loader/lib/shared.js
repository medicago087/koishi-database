var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/packages/loader/src/shared.ts
var shared_exports = {};
__export(shared_exports, {
  Loader: () => Loader,
  patch: () => patch,
  select: () => select,
  stripModifier: () => stripModifier,
  unwrapExports: () => unwrapExports
});
module.exports = __toCommonJS(shared_exports);
var import_koishi2 = require("koishi");

// koishi/packages/loader/src/utils.ts
var import_koishi = require("koishi");
function unwrapExports(module2) {
  return (module2 == null ? void 0 : module2.default) || module2;
}
__name(unwrapExports, "unwrapExports");
var selectors = ["user", "guild", "channel", "self", "private", "platform"];
function select(root, options) {
  let ctx = root;
  for (const type of selectors) {
    const value = options[type];
    if (value === true) {
      ctx = ctx[type]();
    } else if (value === false) {
      ctx = ctx.exclude(ctx[type]());
    } else if (value !== void 0) {
      ctx = ctx[type](...(0, import_koishi.makeArray)(value).map((item) => "" + item));
    }
  }
  if (options.and) {
    for (const selection of options.and) {
      ctx = ctx.intersect(select(root, selection));
    }
  }
  if (options.or) {
    let ctx2 = ctx.never();
    for (const selection of options.or) {
      ctx2 = ctx2.union(select(root, selection));
    }
    ctx = ctx.intersect(ctx2);
  }
  if (options.not) {
    ctx = ctx.exclude(select(root, options.not));
  }
  return ctx;
}
__name(select, "select");
function patch(ctx, config) {
  config || (config = {});
  patch.filter(ctx, config.$filter);
  patch.isolate(ctx, config.$isolate);
}
__name(patch, "patch");
((patch2) => {
  function filter(ctx, filter2) {
    const parent = Object.getPrototypeOf(ctx);
    if (filter2) {
      ctx.filter = parent.intersect(select(ctx.any(), filter2)).filter;
    } else {
      delete ctx.filter;
    }
  }
  patch2.filter = filter;
  __name(filter, "filter");
  function isolate(ctx, isolate2) {
    const updated = {};
    const { delimiter } = ctx;
    for (const name of Object.keys(ctx.mapping)) {
      if (isolate2 == null ? void 0 : isolate2.includes(name))
        continue;
      const oldKey = ctx.mapping[name];
      const value = ctx.root[oldKey];
      delete ctx.mapping[name];
      const neoKey = ctx.mapping[name] || name;
      if (value === ctx.root[neoKey])
        continue;
      const source = value == null ? void 0 : value[import_koishi.Context.source];
      updated[name] = source == null ? void 0 : source[delimiter];
      if (updated[name]) {
        source[name] = value;
        ctx.root[oldKey] = null;
      }
    }
    for (const name of isolate2 || []) {
      if (ctx.mapping[name])
        continue;
      const oldKey = ctx.mapping[name] || name;
      const value = ctx.root[oldKey];
      ctx.mapping[name] = Symbol(name);
      const neoKey = ctx.mapping[name];
      if (value === ctx.root[neoKey])
        continue;
      const source = value == null ? void 0 : value[import_koishi.Context.source];
      updated[name] = source == null ? void 0 : source[delimiter];
      if (updated[name]) {
        source[name] = value;
        ctx.root[oldKey] = null;
      }
    }
    const parent = Object.getPrototypeOf(ctx);
    for (const name in updated) {
      const self = Object.create(ctx);
      const source = updated[name] ? parent : ctx;
      self[import_koishi.Context.filter] = (target) => {
        return source.mapping[name] === target.mapping[name] && updated[name] !== target[delimiter];
      };
      ctx.emit(self, "internal/before-service", name, null);
      ctx.emit(self, "internal/service", name, null);
    }
  }
  patch2.isolate = isolate;
  __name(isolate, "isolate");
})(patch || (patch = {}));
function stripModifier(config) {
  const result = {};
  for (const [key, value] of Object.entries(config || {})) {
    if (key.startsWith("$"))
      continue;
    result[key] = value;
  }
  return result;
}
__name(stripModifier, "stripModifier");

// koishi/packages/loader/src/shared.ts
var kUpdate = Symbol("update");
import_koishi2.Context.service("loader");
var logger = new import_koishi2.Logger("app");
var group = {
  name: "group",
  reusable: true,
  apply(ctx, plugins) {
    var _a, _b;
    (_a = ctx.state)[_b = Loader.kRecord] || (_a[_b] = /* @__PURE__ */ Object.create(null));
    for (const name in plugins || {}) {
      if (name.startsWith("~") || name.startsWith("$"))
        continue;
      ctx.lifecycle.queue(ctx.loader.reloadPlugin(ctx, name, plugins[name]));
    }
    ctx.accept((neo) => {
      const old = ctx.state.config;
      if (!(0, import_koishi2.deepEqual)(old.$filter || {}, neo.$filter || {})) {
        patch.filter(ctx.state.parent, neo.$filter);
      }
      if (!(0, import_koishi2.deepEqual)(old.$isolate || [], neo.$isolate || [])) {
        patch.isolate(ctx.state.parent, neo.$isolate);
      }
      for (const key in { ...old, ...neo }) {
        if (key.startsWith("~") || key.startsWith("$"))
          continue;
        const fork = ctx.state[Loader.kRecord][key];
        if (!fork) {
          ctx.loader.reloadPlugin(ctx, key, neo[key]);
        } else if (!(key in neo)) {
          ctx.loader.unloadPlugin(ctx, key);
        } else {
          ctx.loader.reloadPlugin(ctx, key, neo[key] || {});
        }
      }
    }, { passive: true });
  }
};
var _Loader = class {
  constructor() {
    this.suspend = false;
    this.writable = true;
    this.cache = /* @__PURE__ */ Object.create(null);
  }
  interpolate(source) {
    return source;
  }
  async forkPlugin(name, config, parent) {
    const plugin = await this.resolvePlugin(name);
    if (!plugin)
      return;
    (0, import_koishi2.resolveConfig)(plugin, config);
    return parent.plugin(plugin, this.interpolate(config));
  }
  async reloadPlugin(parent, key, config) {
    let fork = parent.state[_Loader.kRecord][key];
    if (fork) {
      patch(fork.parent, config);
      fork[kUpdate] = true;
      fork.update(config);
    } else {
      logger.info(`apply plugin %c`, key);
      const name = key.split(":", 1)[0];
      if (name === "group") {
        const ctx = parent.isolate([]);
        ctx.delimiter = Symbol("unique");
        ctx[ctx.delimiter] = true;
        patch(ctx, config);
        fork = ctx.plugin(group, config);
      } else {
        config = stripModifier(config);
        fork = await this.forkPlugin(name, config, parent);
      }
      if (!fork)
        return;
      fork.alias = key.slice(name.length + 1);
      parent.state[_Loader.kRecord][key] = fork;
    }
    return fork;
  }
  unloadPlugin(ctx, key) {
    const fork = ctx.state[_Loader.kRecord][key];
    if (fork) {
      fork.dispose();
      delete ctx.state[_Loader.kRecord][key];
      logger.info(`unload plugin %c`, key);
    }
  }
  async createApp() {
    const app = this.app = new import_koishi2.Context(this.config);
    app.loader = this;
    app.baseDir = this.baseDir;
    app.state[_Loader.kRecord] = /* @__PURE__ */ Object.create(null);
    const fork = await this.reloadPlugin(app, "group:entry", this.config.plugins);
    this.entry = fork.ctx;
    app.accept(["plugins"], (config) => {
      fork[kUpdate] = true;
      fork.update(config.plugins);
    }, { passive: true });
    app.on("dispose", () => {
      this.fullReload();
    });
    app.on("internal/update", (fork2) => {
      const record = fork2.parent.state[_Loader.kRecord];
      if (!record)
        return;
      for (const name in record) {
        if (record[name] !== fork2)
          continue;
        logger.info(`reload plugin %c`, name);
      }
    });
    app.on("internal/before-update", (fork2, config) => {
      if (fork2[kUpdate])
        return delete fork2[kUpdate];
      const record = fork2.parent.state[_Loader.kRecord];
      if (!record)
        return;
      for (const name in record) {
        if (record[name] !== fork2)
          continue;
        fork2.parent.state.config[name] = config;
      }
    });
    return app;
  }
};
var Loader = _Loader;
__name(Loader, "Loader");
Loader.kRecord = Symbol.for("koishi.loader.record");
Loader.exitCode = 51;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Loader,
  patch,
  select,
  stripModifier,
  unwrapExports
});
//# sourceMappingURL=shared.js.map
