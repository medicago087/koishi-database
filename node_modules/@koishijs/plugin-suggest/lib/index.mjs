var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// koishi/plugins/a11y/suggest/src/locales/zh.yml
var require_zh = __commonJS({
  "koishi/plugins/a11y/suggest/src/locales/zh.yml"(exports, module) {
    module.exports = { suggest: { hint: "您要找的是不是{0}？", "command-prefix": "", "command-suffix": "发送句号以使用推测的指令。" } };
  }
});

// koishi/plugins/a11y/suggest/src/locales/en.yml
var require_en = __commonJS({
  "koishi/plugins/a11y/suggest/src/locales/en.yml"(exports, module) {
    module.exports = { suggest: { hint: "Do you mean {0}?", "command-prefix": "", "command-suffix": "Send a period to apply the suggestion." } };
  }
});

// koishi/plugins/a11y/suggest/src/locales/ja.yml
var require_ja = __commonJS({
  "koishi/plugins/a11y/suggest/src/locales/ja.yml"(exports, module) {
    module.exports = { suggest: { hint: "「{0}」を実行したいですか？", "command-prefix": "", "command-suffix": "句点を送信してコマンドを実行します。" } };
  }
});

// koishi/plugins/a11y/suggest/src/locales/fr.yml
var require_fr = __commonJS({
  "koishi/plugins/a11y/suggest/src/locales/fr.yml"(exports, module) {
    module.exports = { suggest: { hint: "Voulez-vous dire {0} ?", "command-prefix": "", "command-suffix": "Tapez un point pour appliquer la suggestion." } };
  }
});

// koishi/plugins/a11y/suggest/src/locales/zh-tw.yml
var require_zh_tw = __commonJS({
  "koishi/plugins/a11y/suggest/src/locales/zh-tw.yml"(exports, module) {
    module.exports = { suggest: { hint: "你想輸入的是{0}嗎？", "command-prefix": "", "command-suffix": "發送句號可使用推測的指令。" } };
  }
});

// koishi/plugins/a11y/suggest/src/index.ts
import { distance } from "fastest-levenshtein";
import { Context, Next, Schema, Session } from "koishi";
Context.service("$suggest");
Session.prototype.suggest = /* @__PURE__ */ __name(function suggest(options) {
  const {
    target,
    items,
    prefix = "",
    suffix,
    apply,
    next = Next.compose,
    minSimilarity = this.app.$suggest.config.minSimilarity
  } = options;
  const sendNext = /* @__PURE__ */ __name(async (callback) => {
    const result = await next(callback);
    if (result)
      await this.send(result);
  }, "sendNext");
  let suggestions, minDistance = Infinity;
  for (const name of items) {
    const dist = distance(name, target);
    if (name.length <= 2 || dist > name.length * minSimilarity)
      continue;
    if (dist === minDistance) {
      suggestions.push(name);
    } else if (dist < minDistance) {
      suggestions = [name];
      minDistance = dist;
    }
  }
  if (!suggestions)
    return sendNext(async () => prefix);
  const scope = this.scope;
  return sendNext(async () => {
    const message = prefix + this.text("suggest.hint", [suggestions.map((text) => {
      return this.text("general.quote", [text]);
    }).join(this.text("general.or"))]);
    if (suggestions.length > 1)
      return message;
    const dispose = this.middleware((session, next2) => {
      dispose();
      const message2 = session.content.trim();
      if (message2 && message2 !== "." && message2 !== "。")
        return next2();
      return session.withScope(scope, () => {
        return apply.call(session, suggestions[0], next2);
      });
    });
    return message + suffix;
  });
}, "suggest");
var SuggestionService = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    ctx.$suggest = this;
    ctx.i18n.define("zh", require_zh());
    ctx.i18n.define("en", require_en());
    ctx.i18n.define("ja", require_ja());
    ctx.i18n.define("fr", require_fr());
    ctx.i18n.define("zh-tw", require_zh_tw());
    ctx.middleware((session, next) => {
      const { argv, quote, subtype, parsed: { content, prefix, appel } } = session;
      if (argv.command || subtype !== "private" && !prefix && !appel)
        return next();
      const target = content.split(/\s/, 1)[0].toLowerCase();
      if (!target)
        return next();
      return session.suggest({
        target,
        next,
        items: this.getCommandNames(session),
        prefix: session.text("suggest.command-prefix"),
        suffix: session.text("suggest.command-suffix"),
        async apply(suggestion, next2) {
          const newMessage = suggestion + content.slice(target.length) + (quote ? " " + quote.content : "");
          return this.execute(newMessage, next2);
        }
      });
    });
  }
  getCommandNames(session) {
    return this.ctx.$commander._commandList.filter((cmd) => cmd.match(session) && !cmd.config.hidden).flatMap((cmd) => cmd._aliases);
  }
};
__name(SuggestionService, "SuggestionService");
((SuggestionService2) => {
  SuggestionService2.Config = Schema.object({
    minSimilarity: Schema.percent().default(0.4).description("用于模糊匹配的相似系数，应该是一个 0 到 1 之间的数值。数值越高，模糊匹配越严格。设置为 1 可以完全禁用模糊匹配。")
  });
})(SuggestionService || (SuggestionService = {}));
var src_default = SuggestionService;
export {
  src_default as default
};
//# sourceMappingURL=index.mjs.map
