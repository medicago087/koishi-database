var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/status/src/index.ts
var src_exports = {};
__export(src_exports, {
  Config: () => Config,
  MetaProvider: () => meta_default,
  ProfileProvider: () => profile_default,
  RECENT_LENGTH: () => RECENT_LENGTH,
  StatisticsProvider: () => stats_default,
  apply: () => apply,
  average: () => average,
  name: () => name,
  using: () => using
});
module.exports = __toCommonJS(src_exports);
var import_koishi4 = require("koishi");
var import_path = require("path");

// packages/status/src/meta.ts
var import_koishi = require("koishi");
var import_plugin_console = require("@koishijs/plugin-console");
var MetaProvider = class extends import_plugin_console.DataService {
  constructor(ctx, config) {
    super(ctx, "meta");
    this.config = config;
    this.timestamp = 0;
    this.callbacks = [];
    this.extend(async () => {
      var _a;
      return (_a = ctx.assets) == null ? void 0 : _a.stats();
    });
    this.extend(async () => {
      var _a;
      const activeUsers = await ((_a = ctx.database) == null ? void 0 : _a.eval("user", (row) => import_koishi.$.count(row.id), {
        lastCall: { $gt: new Date(new Date().getTime() - import_koishi.Time.day) }
      }));
      return { activeUsers };
    });
    this.extend(async () => {
      var _a;
      const activeGuilds = await ((_a = ctx.database) == null ? void 0 : _a.eval("channel", (row) => import_koishi.$.count(row.id), {
        assignee: { $ne: null }
      }));
      return { activeGuilds };
    });
    ctx.model.extend("user", {
      lastCall: "timestamp"
    });
    ctx.any().before("command/execute", ({ session }) => {
      if (!ctx.database)
        return;
      session.user.lastCall = new Date();
    });
  }
  async get() {
    const now = Date.now();
    if (this.timestamp > now)
      return this.cached;
    this.timestamp = now + this.config.metaInterval;
    return this.cached = Promise.all(this.callbacks.map((cb) => cb().catch(import_koishi.noop))).then((data) => Object.assign({}, ...data));
  }
  extend(callback) {
    this.timestamp = 0;
    this.callbacks.push(callback);
  }
};
__name(MetaProvider, "MetaProvider");
((MetaProvider2) => {
  MetaProvider2.Config = import_koishi.Schema.object({
    metaInterval: import_koishi.Schema.natural().role("ms").description("元数据推送的时间间隔。").default(import_koishi.Time.hour)
  });
})(MetaProvider || (MetaProvider = {}));
var meta_default = MetaProvider;

// packages/status/src/profile.ts
var import_koishi2 = require("koishi");
var import_os = require("os");
var import_plugin_console2 = require("@koishijs/plugin-console");
var TickCounter = class {
  constructor(ctx) {
    this.data = new Array(60).fill(0);
    this.tick = () => {
      this.data.unshift(0);
      this.data.splice(-1, 1);
    };
    this.stop = ctx.setInterval(() => this.tick(), import_koishi2.Time.second);
  }
  add(value = 1) {
    this.data[0] += value;
  }
  get() {
    return this.data.reduce((prev, curr) => prev + curr, 0);
  }
  static initialize(bot, ctx) {
    bot._messageSent = new TickCounter(ctx);
    bot._messageReceived = new TickCounter(ctx);
  }
};
__name(TickCounter, "TickCounter");
var usage = getCpuUsage();
var appRate;
var usedRate;
async function memoryRate() {
  const total = (0, import_os.totalmem)();
  return [process.memoryUsage().rss / total, 1 - (0, import_os.freemem)() / total];
}
__name(memoryRate, "memoryRate");
function getCpuUsage() {
  let totalIdle = 0, totalTick = 0;
  const cpuInfo = (0, import_os.cpus)();
  const usage2 = process.cpuUsage().user;
  for (const cpu of cpuInfo) {
    for (const type in cpu.times) {
      totalTick += cpu.times[type];
    }
    totalIdle += cpu.times.idle;
  }
  return {
    app: usage2 / 1e3,
    used: totalTick - totalIdle,
    total: totalTick
  };
}
__name(getCpuUsage, "getCpuUsage");
function updateCpuUsage() {
  const newUsage = getCpuUsage();
  const totalDifference = newUsage.total - usage.total;
  appRate = (newUsage.app - usage.app) / totalDifference;
  usedRate = (newUsage.used - usage.used) / totalDifference;
  usage = newUsage;
}
__name(updateCpuUsage, "updateCpuUsage");
var ProfileProvider = class extends import_plugin_console2.DataService {
  constructor(ctx, config) {
    super(ctx, "profile");
    this.config = config;
    const { tickInterval } = config;
    ctx.on("ready", () => {
      ctx.setInterval(() => {
        updateCpuUsage();
        this.refresh();
      }, tickInterval);
    });
    ctx.any().before("send", (session) => {
      session.bot._messageSent.add(1);
    });
    ctx.any().on("message", (session) => {
      session.bot._messageReceived.add(1);
    });
    ctx.bots.forEach((bot) => TickCounter.initialize(bot, ctx));
    ctx.on("bot-added", (bot) => {
      TickCounter.initialize(bot, ctx);
      process.nextTick(() => this.refresh());
    });
    ctx.on("bot-removed", (bot) => {
      process.nextTick(() => this.refresh());
      bot._messageSent.stop();
      bot._messageReceived.stop();
    });
    ctx.on("bot-status-updated", () => {
      this.refresh();
    });
  }
  async get(forced = false) {
    var _a;
    if (this.cached && !forced)
      return this.cached;
    const memory = await memoryRate();
    const cpu = [appRate, usedRate];
    const bots = {};
    for (const bot of this.ctx.bots) {
      if (bot.hidden)
        continue;
      bots[bot.ctx.state.uid] = {
        ...(0, import_koishi2.pick)(bot, ["platform", "selfId", "avatar", "username", "status"]),
        error: (_a = bot.error) == null ? void 0 : _a.message,
        messageSent: bot._messageSent.get(),
        messageReceived: bot._messageReceived.get()
      };
    }
    return { memory, cpu, bots };
  }
};
__name(ProfileProvider, "ProfileProvider");
((ProfileProvider2) => {
  ProfileProvider2.Config = import_koishi2.Schema.object({
    tickInterval: import_koishi2.Schema.natural().role("ms").description("性能数据推送的时间间隔。").default(import_koishi2.Time.second * 5)
  });
})(ProfileProvider || (ProfileProvider = {}));
var profile_default = ProfileProvider;

// packages/status/src/stats.ts
var import_koishi3 = require("koishi");
var import_plugin_console3 = require("@koishijs/plugin-console");
var logger = new import_koishi3.Logger("stats");
var RECENT_LENGTH = 5;
function average(stats) {
  const result = {};
  stats.slice(0, RECENT_LENGTH).forEach((stat) => {
    for (const key in stat) {
      if (typeof stat[key] !== "number")
        continue;
      result[key] = (result[key] || 0) + stat[key];
    }
  });
  for (const key in result) {
    result[key] = +(result[key] / RECENT_LENGTH).toFixed(1);
  }
  return result;
}
__name(average, "average");
var send = import_koishi3.Session.prototype.send;
import_koishi3.Session.prototype.send = function(...args) {
  if (args[0] && this._sendType && this.app.console) {
    this.app.console.stats.hourly[this._sendType] += 1;
  }
  return send.apply(this, args);
};
var customTag = Symbol("custom-send");
import_koishi3.Session.prototype.send[customTag] = send;
var _StatisticsProvider = class extends import_plugin_console3.DataService {
  constructor(ctx, config = {}) {
    super(ctx, "stats");
    this.config = config;
    this.lastUpdate = new Date();
    this.updateHour = this.lastUpdate.getHours();
    this.callbacks = [];
    this.average = average;
    this.extendBasic = async (payload, data) => {
      payload.history = {};
      data.longterm.forEach((stat) => {
        payload.history[stat.time.toLocaleDateString("zh-CN")] = stat.message;
      });
      payload.commands = average(data.daily.map((data2) => data2.command));
      payload.botSend = average(data.daily.map((stat) => stat.botSend));
      payload.botReceive = average(data.daily.map((stat) => stat.botReceive));
      payload.hours = new Array(24).fill(0).map((_, index) => {
        return average(data.hourly.filter((s) => s.time.getHours() === index));
      });
    };
    this.extendGuilds = async (payload, data) => {
      var _a;
      const groupSet = /* @__PURE__ */ new Set();
      payload.guilds = [];
      const groupMap = Object.fromEntries(data.guilds.map((g) => [`${g.platform}:${g.id}`, g]));
      const messageMap = average(data.daily.map((data2) => data2.group));
      const updateList = [];
      async function getGuildInfo(bot) {
        const { platform } = bot;
        const guilds = await bot.getGuildList();
        for (const { guildId, guildName: name2 } of guilds) {
          const id = `${platform}:${guildId}`;
          if (!messageMap[id] || !groupMap[id] || groupSet.has(id))
            continue;
          groupSet.add(id);
          const { name: oldName, assignee } = groupMap[id];
          if (name2 !== oldName)
            updateList.push({ platform, id: guildId, name: name2 });
          payload.guilds.push({
            name: name2,
            platform,
            assignee,
            value: messageMap[id],
            last: data.daily[0].group[id] || 0
          });
        }
      }
      __name(getGuildInfo, "getGuildInfo");
      await Promise.all(this.ctx.bots.map(async (bot) => {
        if (bot.status !== "online")
          return;
        await getGuildInfo(bot).catch(logger.warn);
      }));
      for (const key in messageMap) {
        if (!groupSet.has(key) && groupMap[key]) {
          const { name: name2, assignee } = groupMap[key];
          const [platform] = key.split(":");
          payload.guilds.push({
            platform,
            name: name2 || key,
            value: messageMap[key],
            last: data.daily[0].group[key] || 0,
            assignee: ((_a = this.ctx.bots[`${platform}:${assignee}`]) == null ? void 0 : _a.selfId) || ""
          });
        }
      }
      await this.ctx.database.upsert("channel", updateList);
    };
    this.clear();
    ctx.model.extend("channel", {
      name: "string(50)",
      activity: "json"
    });
    ctx.model.extend("stats_daily", {
      time: "date",
      ...Object.fromEntries(_StatisticsProvider.dailyFields.map((key) => [key, "json"]))
    }, { primary: "time" });
    ctx.model.extend("stats_hourly", {
      time: "timestamp",
      ...Object.fromEntries(_StatisticsProvider.hourlyFields.map((key) => [key, { type: "integer", initial: 0 }]))
    }, { primary: "time" });
    ctx.model.extend("stats_longterm", {
      time: "date",
      ...Object.fromEntries(_StatisticsProvider.longtermFields.map((key) => [key, { type: "integer", initial: 0 }]))
    }, { primary: "time" });
    ctx.on("exit", () => this.upload(true));
    ctx.on("dispose", async () => {
      if (import_koishi3.Session.prototype.send[customTag]) {
        import_koishi3.Session.prototype.send = import_koishi3.Session.prototype.send[customTag];
      }
      await this.upload(true);
    });
    ctx.before("command/execute", ({ command, session }) => {
      var _a;
      if (((_a = command.parent) == null ? void 0 : _a.name) !== "test") {
        const [name2] = command.name.split(".", 1);
        this.addDaily("command", name2);
        this.upload();
      }
      session._sendType = "command";
    });
    const updateSendStats = /* @__PURE__ */ __name(async (session) => {
      var _a, _b;
      this.hourly.total += 1;
      this.hourly[session.subtype] += 1;
      this.longterm.message += 1;
      this.addDaily("botSend", session.sid);
      if (session.subtype === "group") {
        this.addDaily("group", session.gid);
        const record = (_a = this.guilds)[_b = session.platform] || (_a[_b] = {});
        record[session.guildId] = (record[session.guildId] || 0) + 1;
      }
      this.upload();
    }, "updateSendStats");
    ctx.on("message", (session) => {
      this.addDaily("botReceive", session.sid);
    });
    ctx.on("before-send", (session) => {
      updateSendStats(session);
    });
    this.extend(this.extendBasic);
    this.extend(this.extendGuilds);
  }
  clear() {
    this.daily = Object.fromEntries(_StatisticsProvider.dailyFields.map((i) => [i, {}]));
    this.hourly = Object.fromEntries(_StatisticsProvider.hourlyFields.map((i) => [i, 0]));
    this.longterm = Object.fromEntries(_StatisticsProvider.longtermFields.map((i) => [i, 0]));
    this.guilds = {};
  }
  addDaily(field, key) {
    var _a;
    const stat = (_a = this.daily)[field] || (_a[field] = {});
    stat[key] = (stat[key] || 0) + 1;
  }
  async _uploadDaily(date) {
    if (!Object.values(this.daily).some((data) => Object.keys(data).length))
      return;
    const time = new Date(date);
    time.setHours(0, 0, 0, 0);
    await this.ctx.database.upsert("stats_daily", (row) => [{
      time,
      ...Object.fromEntries(Object.entries(this.daily).flatMap(([type, record]) => {
        return Object.entries(record).map(([key, value]) => {
          return [`${type}.${key}`, import_koishi3.$.add(import_koishi3.$.ifNull(row[type][key], 0), value)];
        });
      }))
    }]);
  }
  async _uploadHourly(date) {
    if (!Object.values(this.hourly).some((value) => value))
      return;
    const time = new Date(date);
    time.setMinutes(0, 0, 0);
    await this.ctx.database.upsert("stats_hourly", (row) => [{
      time,
      ...(0, import_koishi3.valueMap)(this.hourly, (value, key) => import_koishi3.$.add(row[key], value))
    }]);
  }
  async _uploadLongterm(date) {
    if (!Object.values(this.longterm).some((value) => value))
      return;
    const time = new Date(date);
    time.setHours(0, 0, 0, 0);
    await this.ctx.database.upsert("stats_longterm", (row) => [{
      time,
      ...(0, import_koishi3.valueMap)(this.longterm, (value, key) => import_koishi3.$.add(row[key], value))
    }]);
  }
  async _uploadGuilds(date) {
    if (!Object.values(this.guilds).some((data) => Object.keys(data).length))
      return;
    const key = "activity." + import_koishi3.Time.getDateNumber(date);
    await this.ctx.database.upsert("channel", (row) => {
      return Object.entries(this.guilds).flatMap(([platform, record]) => {
        return Object.entries(record).map(([id, value]) => ({
          id,
          platform,
          [key]: import_koishi3.$.add(import_koishi3.$.ifNull(row[key], 0), value)
        }));
      });
    });
  }
  async upload(forced = false) {
    const date = new Date();
    const dateHour = date.getHours();
    if (forced || +date - +this.lastUpdate > this.config.statsInternal || dateHour !== this.updateHour) {
      this.lastUpdate = date;
      this.updateHour = dateHour;
      await Promise.all([
        this._uploadDaily(date),
        this._uploadHourly(date),
        this._uploadLongterm(date),
        this._uploadGuilds(date)
      ]);
      this.clear();
      logger.debug("stats updated");
    }
  }
  extend(callback) {
    this.callbacks.push(callback);
  }
  async download() {
    const time = { $lt: new Date() }, sort = { time: "desc" };
    const [daily, hourly, longterm, guilds] = await Promise.all([
      this.ctx.database.get("stats_daily", { time }, { sort, limit: RECENT_LENGTH }),
      this.ctx.database.get("stats_hourly", { time }, { sort, limit: 24 * RECENT_LENGTH }),
      this.ctx.database.get("stats_longterm", { time }, { sort }),
      this.ctx.database.get("channel", (row) => import_koishi3.$.eq(row.id, row.guildId), ["platform", "id", "name", "assignee"])
    ]);
    const data = { daily, hourly, longterm, guilds };
    const payload = {};
    await Promise.all(this.callbacks.map((cb) => cb(payload, data)));
    return payload;
  }
  async get() {
    const date = new Date();
    const dateNumber = import_koishi3.Time.getDateNumber(date, date.getTimezoneOffset());
    if (dateNumber !== this.cachedDate) {
      this.cachedData = this.download();
      this.cachedDate = dateNumber;
    }
    return this.cachedData;
  }
};
var StatisticsProvider = _StatisticsProvider;
__name(StatisticsProvider, "StatisticsProvider");
StatisticsProvider.using = ["database"];
((StatisticsProvider2) => {
  StatisticsProvider2.dailyFields = [
    "command",
    "dialogue",
    "botSend",
    "botReceive",
    "group"
  ];
  StatisticsProvider2.hourlyFields = [
    "total",
    "group",
    "private",
    "command",
    "dialogue"
  ];
  StatisticsProvider2.longtermFields = [
    "message"
  ];
  StatisticsProvider2.Config = import_koishi3.Schema.object({
    statsInternal: import_koishi3.Schema.natural().role("ms").description("统计数据推送的时间间隔。").default(import_koishi3.Time.minute * 10)
  });
})(StatisticsProvider || (StatisticsProvider = {}));
var stats_default = StatisticsProvider;

// packages/status/src/index.ts
var name = "status";
var using = ["console"];
var Config = import_koishi4.Schema.intersect([
  meta_default.Config,
  profile_default.Config,
  stats_default.Config
]);
function apply(ctx, config) {
  ctx.console.addEntry({
    dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
    prod: (0, import_path.resolve)(__dirname, "../dist")
  });
  ctx.plugin(meta_default, config);
  ctx.plugin(profile_default, config);
  ctx.plugin(stats_default, config);
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  MetaProvider,
  ProfileProvider,
  RECENT_LENGTH,
  StatisticsProvider,
  apply,
  average,
  name,
  using
});
//# sourceMappingURL=index.js.map
