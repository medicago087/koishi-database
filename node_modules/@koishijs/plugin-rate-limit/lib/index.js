var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/plugins/a11y/rate-limit/src/index.ts
var src_exports = {};
__export(src_exports, {
  Config: () => Config,
  apply: () => apply,
  checkTimer: () => checkTimer,
  checkUsage: () => checkUsage,
  getUsage: () => getUsage,
  getUsageName: () => getUsageName,
  name: () => name,
  using: () => using
});
module.exports = __toCommonJS(src_exports);
var import_koishi = require("koishi");
var import_helpers = require("@koishijs/helpers");

// koishi/plugins/a11y/rate-limit/src/locales/zh.yml
var zh_default = { internal: { "usage-exhausted": "调用次数已达上限。", "too-frequent": "调用过于频繁，请稍后再试。", "option-not-usage": " (不计入调用)", "command-max-usage": "已调用次数：{0}/{1}。", "command-min-interval": "距离下次调用还需：{0}/{1} 秒。" }, commands: { usage: { description: "调用次数信息", options: { set: "设置调用次数", clear: "清空调用次数" }, messages: { present: "今日 {0} 功能的调用次数为：{1}", list: "今日各功能的调用次数为：", none: "今日没有调用过消耗次数的功能。" } }, timer: { description: "定时器信息", options: { set: "设置定时器", clear: "清空定时器" }, messages: { present: "定时器 {0} 的生效时间为：剩余 <i18n:time value={1}/>", absent: "定时器 {0} 当前并未生效。", list: "各定时器的生效时间为：", item: "{0}：剩余 <i18n:time value={1}/>", none: "当前没有生效的定时器。" } } } };

// koishi/plugins/a11y/rate-limit/src/index.ts
var name = "rate-limit";
var using = ["database"];
var Config = import_koishi.Schema.object({});
function apply(ctx) {
  ctx.i18n.define("zh", zh_default);
  ctx.model.extend("user", {
    usage: "json",
    timers: "json"
  });
  ctx.before("command/attach-user", ({ command, options = {} }, fields) => {
    if (!command)
      return;
    const { maxUsage, minInterval, bypassAuthority } = command.config;
    let shouldFetchUsage = !!(maxUsage || minInterval);
    for (const { name: name2, notUsage } of Object.values(command._options)) {
      if (name2 === "help")
        continue;
      if (name2 in options && notUsage)
        shouldFetchUsage = false;
    }
    if (shouldFetchUsage) {
      if (maxUsage)
        fields.add("usage");
      if (minInterval)
        fields.add("timers");
    }
    if (bypassAuthority)
      fields.add("authority");
  });
  function bypassRateLimit(session, command) {
    if (!session.user)
      return true;
    const bypassAuthority = command.getConfig("bypassAuthority", session);
    if (session.user.authority >= bypassAuthority)
      return true;
  }
  __name(bypassRateLimit, "bypassRateLimit");
  ctx.before("command/execute", (argv) => {
    const { session, options, command } = argv;
    if (bypassRateLimit(session, command))
      return;
    function sendHint(path, ...param) {
      if (!command.config.showWarning)
        return "";
      return session.text([`.${path}`, `internal.${path}`], param);
    }
    __name(sendHint, "sendHint");
    let isUsage = true;
    for (const { name: name2, notUsage } of Object.values(command._options)) {
      if (name2 in options && notUsage)
        isUsage = false;
    }
    if (isUsage) {
      const name2 = getUsageName(command);
      const minInterval = command.getConfig("minInterval", session);
      const maxUsage = command.getConfig("maxUsage", session);
      if (maxUsage < Infinity && checkUsage(name2, session.user, maxUsage)) {
        return sendHint("usage-exhausted");
      }
      if (minInterval > 0 && checkTimer(name2, session.user, minInterval)) {
        return sendHint("too-frequent");
      }
    }
  });
  ctx.on("help/command", (output, command, session) => {
    var _a, _b;
    if (bypassRateLimit(session, command))
      return;
    const name2 = getUsageName(command);
    const maxUsage = (_a = command.getConfig("maxUsage", session)) != null ? _a : Infinity;
    const minInterval = (_b = command.getConfig("minInterval", session)) != null ? _b : 0;
    if (maxUsage < Infinity) {
      const count = getUsage(name2, session.user);
      output.push(session.text("internal.command-max-usage", [Math.min(count, maxUsage), maxUsage]));
    }
    if (minInterval > 0) {
      const due = session.user.timers[name2];
      const nextUsage = due ? (Math.max(0, due - Date.now()) / 1e3).toFixed() : 0;
      output.push(session.text("internal.command-min-interval", [nextUsage, minInterval / 1e3]));
    }
  });
  ctx.on("help/option", (output, option, command, session) => {
    if (bypassRateLimit(session, command))
      return output;
    const maxUsage = command.getConfig("maxUsage", session);
    if (option.notUsage && maxUsage !== Infinity) {
      output += session.text("internal.option-not-usage");
    }
    return output;
  });
  ctx.command("usage [key] [value:posint]", { authority: 1 }).userFields(["usage"]).option("set", "-s", { authority: 4 }).option("clear", "-c", { authority: 4 }).use(import_helpers.adminUser).action(({ session, options }, name2, count) => {
    const { user } = session;
    if (options.clear) {
      name2 ? delete user.usage[name2] : user.usage = {};
      return;
    }
    if (options.set) {
      if (!count)
        return session.text("internal.insufficient-arguments");
      user.usage[name2] = count;
      return;
    }
    if (name2)
      return session.text(".present", [name2, user.usage[name2] || 0]);
    const output = [];
    for (const name3 of Object.keys(user.usage).sort()) {
      if (name3.startsWith("_"))
        continue;
      output.push(`${name3}：${user.usage[name3]}`);
    }
    if (!output.length)
      return session.text(".none");
    output.unshift(session.text(".list"));
    return output.join("\n");
  });
  ctx.command("timer [key] [value:date]", { authority: 1 }).userFields(["timers"]).option("set", "-s", { authority: 4 }).option("clear", "-c", { authority: 4 }).use(import_helpers.adminUser).action(({ session, options }, name2, value) => {
    const { user } = session;
    if (options.clear) {
      name2 ? delete user.timers[name2] : user.timers = {};
      return;
    }
    if (options.set) {
      if (!value)
        return session.text("internal.insufficient-arguments");
      user.timers[name2] = +value;
      return;
    }
    const now = Date.now();
    if (name2) {
      const delta = user.timers[name2] - now;
      if (delta > 0)
        return session.text(".present", [name2, delta]);
      return session.text(".absent", [name2]);
    }
    const output = [];
    for (const name3 of Object.keys(user.timers).sort()) {
      if (name3.startsWith("_"))
        continue;
      output.push(session.text(".item", [name3, user.timers[name3] - now]));
    }
    if (!output.length)
      return session.text(".none");
    output.unshift(session.text(".list"));
    return output.join("\n");
  });
}
__name(apply, "apply");
function getUsageName(command) {
  return command.config.usageName || command.name;
}
__name(getUsageName, "getUsageName");
function getUsage(name2, user) {
  const _date = import_koishi.Time.getDateNumber();
  if (user.usage._date !== _date) {
    user.usage = { _date };
  }
  return user.usage[name2] || 0;
}
__name(getUsage, "getUsage");
function checkUsage(name2, user, maxUsage) {
  if (!user.usage)
    return;
  const count = getUsage(name2, user);
  if (count >= maxUsage)
    return true;
  if (maxUsage) {
    user.usage[name2] = count + 1;
  }
}
__name(checkUsage, "checkUsage");
function checkTimer(name2, { timers }, offset) {
  const now = Date.now();
  if (!(now <= timers._date)) {
    for (const key in timers) {
      if (now > timers[key])
        delete timers[key];
    }
    timers._date = now + import_koishi.Time.day;
  }
  if (now <= timers[name2])
    return true;
  if (offset !== void 0) {
    timers[name2] = now + offset;
  }
}
__name(checkTimer, "checkTimer");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  apply,
  checkTimer,
  checkUsage,
  getUsage,
  getUsageName,
  name,
  using
});
//# sourceMappingURL=index.js.map
