var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/external/console/packages/auth/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_koishi = require("koishi");
var import_plugin_console = require("@koishijs/plugin-console");
var import_crypto = require("crypto");
var import_path = require("path");
var import_uuid = require("uuid");
var authFields = ["name", "authority", "id", "expire", "token"];
function setAuthUser(handle, value, platforms) {
  if (value) {
    value = {
      ...(0, import_koishi.omit)(value, ["password", ...platforms]),
      accounts: Object.entries((0, import_koishi.pick)(value, platforms)).filter(([, value2]) => value2).map(([platform, id]) => ({ platform, id }))
    };
  }
  handle.user = value;
  handle.send({ type: "data", body: { key: "user", value } });
  handle.refresh();
}
__name(setAuthUser, "setAuthUser");
var AuthService = class extends import_plugin_console.DataService {
  constructor(ctx, config) {
    super(ctx, "user");
    this.config = config;
    ctx.model.extend("user", {
      password: "string(255)",
      token: "string(255)",
      expire: "unsigned(20)"
    });
    ctx.console.addEntry({
      dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
      prod: (0, import_path.resolve)(__dirname, "../dist")
    });
    this.initLogin();
  }
  async start() {
    const count = await this.ctx.database.select("user", {
      authority: { $gte: 4 }
    }).execute((_) => import_koishi.$.count(_.id));
    if (count)
      return;
    const password = (0, import_crypto.createHash)("sha256").update("123456").digest("hex");
    await this.ctx.database.create("user", { id: 0, name: "admin", authority: 5, password });
  }
  initLogin() {
    const { ctx, config } = this;
    const states = {};
    let platforms = getPlatforms();
    function getPlatforms() {
      return new Set(ctx.bots.filter((bot) => !bot.hidden).map((bot) => bot.platform));
    }
    __name(getPlatforms, "getPlatforms");
    ctx.on("bot-added", () => {
      platforms = getPlatforms();
    });
    ctx.on("bot-removed", () => {
      platforms = getPlatforms();
    });
    ctx.console.addListener("login/password", async function(name, password) {
      const user = await ctx.database.getUser("name", name, ["password", ...platforms, ...authFields]);
      if (!user || user.password !== password)
        throw new Error("用户名或密码错误。");
      if (!user.expire || user.expire < Date.now()) {
        user.token = (0, import_uuid.v4)();
        user.expire = Date.now() + config.authTokenExpire;
        await ctx.database.setUser("name", name, (0, import_koishi.pick)(user, ["token", "expire"]));
      }
      setAuthUser(this, user, platforms);
    });
    ctx.console.addListener("login/token", async function(id, token) {
      const [user] = await ctx.database.get("user", { id }, ["name", ...platforms, ...authFields]);
      if (!user)
        throw new Error("用户不存在。");
      if (user.token !== token || user.expire <= Date.now())
        throw new Error("令牌已失效。");
      setAuthUser(this, user, platforms);
    });
    ctx.console.addListener("login/platform", async function(platform, userId, id) {
      const user = await ctx.database.getUser(platform, userId, ["id", "name"]);
      if (!user)
        throw new Error("找不到此账户。");
      if (id === user.id)
        throw new Error("你已经绑定了此账户。");
      const key = `${platform}:${userId}`;
      const token = (0, import_uuid.v4)();
      const expire = Date.now() + config.loginTokenExpire;
      states[key] = [token, expire, this, id];
      const listener = /* @__PURE__ */ __name(() => {
        delete states[key];
        dispose();
        this.socket.removeEventListener("close", dispose);
      }, "listener");
      const dispose = ctx.setTimeout(() => {
        var _a;
        if (((_a = states[key]) == null ? void 0 : _a[1]) >= Date.now())
          listener();
      }, config.loginTokenExpire);
      this.socket.addEventListener("close", listener);
      return { id: user.id, name: user.name, token, expire };
    });
    ctx.middleware(async (session, next) => {
      const state = states[session.uid];
      if (!state || state[0] !== session.content.trim()) {
        return next();
      }
      if (!(0, import_koishi.isNullable)(state[3])) {
        const old = await session.observeUser();
        await ctx.database.remove("user", { [session.platform]: session.userId });
        await ctx.database.set("user", { id: state[3] }, {
          [session.platform]: session.userId,
          ...(0, import_koishi.omit)(old, ["id", "name", ...authFields, ...platforms])
        });
        const [user2] = await ctx.database.get("user", { id: state[3] }, ["name", ...platforms, ...authFields]);
        return setAuthUser(state[2], user2, platforms);
      }
      const user = await session.observeUser(["name", ...platforms, ...authFields]);
      if (!user.expire || user.expire < Date.now()) {
        user.token = (0, import_uuid.v4)();
        user.expire = Date.now() + config.authTokenExpire;
        await user.$update();
      }
      return setAuthUser(state[2], user, platforms);
    }, true);
    ctx.on("console/intercept", (handle, listener) => {
      if (!listener.authority)
        return false;
      if (!handle.user)
        return true;
      if (handle.user.expire <= Date.now())
        return true;
      return handle.user.authority < listener.authority;
    });
    ctx.console.addListener("user/logout", async function() {
      setAuthUser(this, null, platforms);
    });
    ctx.console.addListener("user/update", async function(data) {
      if (!this.user)
        throw new Error("请先登录。");
      await ctx.database.set("user", { id: this.user.id }, data);
      Object.assign(this.user, data);
      setAuthUser(this, this.user, platforms);
    });
  }
};
__name(AuthService, "AuthService");
AuthService.using = ["console", "database"];
((AuthService2) => {
  AuthService2.Config = import_koishi.Schema.object({
    authTokenExpire: import_koishi.Schema.natural().role("ms").default(import_koishi.Time.week).description("用户令牌有效期。"),
    loginTokenExpire: import_koishi.Schema.natural().role("ms").default(import_koishi.Time.minute * 10).description("登录令牌有效期。")
  });
})(AuthService || (AuthService = {}));
var src_default = AuthService;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map
