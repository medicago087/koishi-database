var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/external/console/packages/analytics/src/index.ts
var src_exports = {};
__export(src_exports, {
  Config: () => Config,
  MetaProvider: () => meta_default,
  RECENT_LENGTH: () => RECENT_LENGTH,
  StatisticsProvider: () => stats_default,
  apply: () => apply,
  average: () => average,
  name: () => name,
  using: () => using
});
module.exports = __toCommonJS(src_exports);
var import_koishi3 = require("koishi");
var import_path = require("path");

// koishi/external/console/packages/analytics/src/meta.ts
var import_koishi = require("koishi");
var import_plugin_console = require("@koishijs/plugin-console");
var MetaProvider = class extends import_plugin_console.DataService {
  constructor(ctx, config) {
    super(ctx, "meta");
    this.config = config;
    this.timestamp = 0;
    this.callbacks = [];
    this.extend(async () => {
      var _a;
      return (_a = ctx.assets) == null ? void 0 : _a.stats();
    });
    this.extend(async () => {
      var _a;
      const activeUsers = await ((_a = ctx.database) == null ? void 0 : _a.eval("user", (row) => import_koishi.$.count(row.id), {
        lastCall: { $gt: new Date(new Date().getTime() - import_koishi.Time.day) }
      }));
      return { activeUsers };
    });
    this.extend(async () => {
      var _a;
      const activeGuilds = await ((_a = ctx.database) == null ? void 0 : _a.eval("channel", (row) => import_koishi.$.count(row.id), {
        assignee: { $ne: null }
      }));
      return { activeGuilds };
    });
    ctx.model.extend("user", {
      lastCall: "timestamp"
    });
    ctx.any().before("command/execute", ({ session }) => {
      if (!ctx.database)
        return;
      session.user.lastCall = new Date();
    });
  }
  async get() {
    const now = Date.now();
    if (this.timestamp > now)
      return this.cached;
    this.timestamp = now + this.config.metaInterval;
    return this.cached = Promise.all(this.callbacks.map((cb) => cb().catch(import_koishi.noop))).then((data) => Object.assign({}, ...data));
  }
  extend(callback) {
    this.timestamp = 0;
    this.callbacks.push(callback);
  }
};
__name(MetaProvider, "MetaProvider");
((MetaProvider2) => {
  MetaProvider2.Config = import_koishi.Schema.object({
    metaInterval: import_koishi.Schema.natural().role("ms").description("元数据推送的时间间隔。").default(import_koishi.Time.hour)
  });
})(MetaProvider || (MetaProvider = {}));
var meta_default = MetaProvider;

// koishi/external/console/packages/analytics/src/stats.ts
var import_koishi2 = require("koishi");
var import_plugin_console2 = require("@koishijs/plugin-console");
var logger = new import_koishi2.Logger("stats");
var RECENT_LENGTH = 5;
function average(stats) {
  const result = {};
  stats.slice(0, RECENT_LENGTH).forEach((stat) => {
    for (const key in stat) {
      if (typeof stat[key] !== "number")
        continue;
      result[key] = (result[key] || 0) + stat[key];
    }
  });
  for (const key in result) {
    result[key] = +(result[key] / RECENT_LENGTH).toFixed(1);
  }
  return result;
}
__name(average, "average");
var send = import_koishi2.Session.prototype.send;
import_koishi2.Session.prototype.send = function(...args) {
  if (args[0] && this._sendType && this.app.console) {
    this.app.console.stats.hourly[this._sendType] += 1;
  }
  return send.apply(this, args);
};
var customTag = Symbol("custom-send");
import_koishi2.Session.prototype.send[customTag] = send;
var _StatisticsProvider = class extends import_plugin_console2.DataService {
  constructor(ctx, config = {}) {
    super(ctx, "stats");
    this.config = config;
    this.lastUpdate = new Date();
    this.updateHour = this.lastUpdate.getHours();
    this.callbacks = [];
    this.average = average;
    this.extendBasic = async (payload, data) => {
      payload.history = {};
      data.longterm.forEach((stat) => {
        payload.history[stat.time.toLocaleDateString("zh-CN")] = stat.message;
      });
      payload.commands = average(data.daily.map((data2) => data2.command));
      payload.botSend = average(data.daily.map((stat) => stat.botSend));
      payload.botReceive = average(data.daily.map((stat) => stat.botReceive));
      payload.hours = new Array(24).fill(0).map((_, index) => {
        return average(data.hourly.filter((s) => s.time.getHours() === index));
      });
    };
    this.extendGuilds = async (payload, data) => {
      var _a;
      const groupSet = /* @__PURE__ */ new Set();
      payload.guilds = [];
      const groupMap = Object.fromEntries(data.guilds.map((g) => [`${g.platform}:${g.id}`, g]));
      const messageMap = average(data.daily.map((data2) => data2.group));
      const updateList = [];
      async function getGuildInfo(bot) {
        const { platform } = bot;
        const guilds = await bot.getGuildList();
        for (const { guildId, guildName: name2 } of guilds) {
          const id = `${platform}:${guildId}`;
          if (!messageMap[id] || !groupMap[id] || groupSet.has(id))
            continue;
          groupSet.add(id);
          const { name: oldName, assignee } = groupMap[id];
          if (name2 !== oldName)
            updateList.push({ platform, id: guildId, name: name2 });
          payload.guilds.push({
            name: name2,
            platform,
            assignee,
            value: messageMap[id],
            last: data.daily[0].group[id] || 0
          });
        }
      }
      __name(getGuildInfo, "getGuildInfo");
      await Promise.all(this.ctx.bots.map(async (bot) => {
        if (bot.status !== "online")
          return;
        await getGuildInfo(bot).catch(logger.warn);
      }));
      for (const key in messageMap) {
        if (!groupSet.has(key) && groupMap[key]) {
          const { name: name2, assignee } = groupMap[key];
          const [platform] = key.split(":");
          payload.guilds.push({
            platform,
            name: name2 || key,
            value: messageMap[key],
            last: data.daily[0].group[key] || 0,
            assignee: ((_a = this.ctx.bots[`${platform}:${assignee}`]) == null ? void 0 : _a.selfId) || ""
          });
        }
      }
      await this.ctx.database.upsert("channel", updateList);
    };
    this.clear();
    ctx.model.extend("channel", {
      name: "string(50)",
      activity: "json"
    });
    ctx.model.extend("stats_daily", {
      time: "date",
      ...Object.fromEntries(_StatisticsProvider.dailyFields.map((key) => [key, "json"]))
    }, { primary: "time" });
    ctx.model.extend("stats_hourly", {
      time: "timestamp",
      ...Object.fromEntries(_StatisticsProvider.hourlyFields.map((key) => [key, { type: "integer", initial: 0 }]))
    }, { primary: "time" });
    ctx.model.extend("stats_longterm", {
      time: "date",
      ...Object.fromEntries(_StatisticsProvider.longtermFields.map((key) => [key, { type: "integer", initial: 0 }]))
    }, { primary: "time" });
    ctx.on("exit", () => this.upload(true));
    ctx.on("dispose", async () => {
      if (import_koishi2.Session.prototype.send[customTag]) {
        import_koishi2.Session.prototype.send = import_koishi2.Session.prototype.send[customTag];
      }
      await this.upload(true);
    });
    ctx.before("command/execute", ({ command, session }) => {
      var _a;
      if (((_a = command.parent) == null ? void 0 : _a.name) !== "test") {
        const [name2] = command.name.split(".", 1);
        this.addDaily("command", name2);
        this.upload();
      }
      session._sendType = "command";
    });
    const updateSendStats = /* @__PURE__ */ __name(async (session) => {
      var _a, _b;
      this.hourly.total += 1;
      this.hourly[session.subtype] += 1;
      this.longterm.message += 1;
      this.addDaily("botSend", session.sid);
      if (session.subtype === "group") {
        this.addDaily("group", session.gid);
        const record = (_a = this.guilds)[_b = session.platform] || (_a[_b] = {});
        record[session.guildId] = (record[session.guildId] || 0) + 1;
      }
      this.upload();
    }, "updateSendStats");
    ctx.on("message", (session) => {
      this.addDaily("botReceive", session.sid);
    });
    ctx.on("before-send", (session) => {
      updateSendStats(session);
    });
    this.extend(this.extendBasic);
    this.extend(this.extendGuilds);
  }
  clear() {
    this.daily = Object.fromEntries(_StatisticsProvider.dailyFields.map((i) => [i, {}]));
    this.hourly = Object.fromEntries(_StatisticsProvider.hourlyFields.map((i) => [i, 0]));
    this.longterm = Object.fromEntries(_StatisticsProvider.longtermFields.map((i) => [i, 0]));
    this.guilds = {};
  }
  addDaily(field, key) {
    var _a;
    const stat = (_a = this.daily)[field] || (_a[field] = {});
    stat[key] = (stat[key] || 0) + 1;
  }
  async _uploadDaily(date) {
    if (!Object.values(this.daily).some((data) => Object.keys(data).length))
      return;
    const time = new Date(date);
    time.setHours(0, 0, 0, 0);
    await this.ctx.database.upsert("stats_daily", (row) => [{
      time,
      ...Object.fromEntries(Object.entries(this.daily).flatMap(([type, record]) => {
        return Object.entries(record).map(([key, value]) => {
          return [`${type}.${key}`, import_koishi2.$.add(import_koishi2.$.ifNull(row[type][key], 0), value)];
        });
      }))
    }]);
  }
  async _uploadHourly(date) {
    if (!Object.values(this.hourly).some((value) => value))
      return;
    const time = new Date(date);
    time.setMinutes(0, 0, 0);
    await this.ctx.database.upsert("stats_hourly", (row) => [{
      time,
      ...(0, import_koishi2.valueMap)(this.hourly, (value, key) => import_koishi2.$.add(row[key], value))
    }]);
  }
  async _uploadLongterm(date) {
    if (!Object.values(this.longterm).some((value) => value))
      return;
    const time = new Date(date);
    time.setHours(0, 0, 0, 0);
    await this.ctx.database.upsert("stats_longterm", (row) => [{
      time,
      ...(0, import_koishi2.valueMap)(this.longterm, (value, key) => import_koishi2.$.add(row[key], value))
    }]);
  }
  async _uploadGuilds(date) {
    if (!Object.values(this.guilds).some((data) => Object.keys(data).length))
      return;
    const key = "activity." + import_koishi2.Time.getDateNumber(date);
    await this.ctx.database.upsert("channel", (row) => {
      return Object.entries(this.guilds).flatMap(([platform, record]) => {
        return Object.entries(record).map(([id, value]) => ({
          id,
          platform,
          [key]: import_koishi2.$.add(import_koishi2.$.ifNull(row[key], 0), value)
        }));
      });
    });
  }
  async upload(forced = false) {
    const date = new Date();
    const dateHour = date.getHours();
    if (forced || +date - +this.lastUpdate > this.config.statsInternal || dateHour !== this.updateHour) {
      this.lastUpdate = date;
      this.updateHour = dateHour;
      await Promise.all([
        this._uploadDaily(date),
        this._uploadHourly(date),
        this._uploadLongterm(date),
        this._uploadGuilds(date)
      ]);
      this.clear();
      logger.debug("stats updated");
    }
  }
  extend(callback) {
    this.callbacks.push(callback);
  }
  async download() {
    const time = { $lt: new Date() }, sort = { time: "desc" };
    const [daily, hourly, longterm, guilds] = await Promise.all([
      this.ctx.database.get("stats_daily", { time }, { sort, limit: RECENT_LENGTH }),
      this.ctx.database.get("stats_hourly", { time }, { sort, limit: 24 * RECENT_LENGTH }),
      this.ctx.database.get("stats_longterm", { time }, { sort }),
      this.ctx.database.get("channel", (row) => import_koishi2.$.eq(row.id, row.guildId), ["platform", "id", "name", "assignee"])
    ]);
    const data = { daily, hourly, longterm, guilds };
    const payload = {};
    await Promise.all(this.callbacks.map((cb) => cb(payload, data)));
    return payload;
  }
  async get() {
    const date = new Date();
    const dateNumber = import_koishi2.Time.getDateNumber(date, date.getTimezoneOffset());
    if (dateNumber !== this.cachedDate) {
      this.cachedData = this.download();
      this.cachedDate = dateNumber;
    }
    return this.cachedData;
  }
};
var StatisticsProvider = _StatisticsProvider;
__name(StatisticsProvider, "StatisticsProvider");
StatisticsProvider.using = ["database"];
((StatisticsProvider2) => {
  StatisticsProvider2.dailyFields = [
    "command",
    "dialogue",
    "botSend",
    "botReceive",
    "group"
  ];
  StatisticsProvider2.hourlyFields = [
    "total",
    "group",
    "private",
    "command",
    "dialogue"
  ];
  StatisticsProvider2.longtermFields = [
    "message"
  ];
  StatisticsProvider2.Config = import_koishi2.Schema.object({
    statsInternal: import_koishi2.Schema.natural().role("ms").description("统计数据推送的时间间隔。").default(import_koishi2.Time.minute * 10)
  });
})(StatisticsProvider || (StatisticsProvider = {}));
var stats_default = StatisticsProvider;

// koishi/external/console/packages/analytics/src/index.ts
var name = "status";
var using = ["console"];
var Config = import_koishi3.Schema.intersect([
  meta_default.Config,
  stats_default.Config
]);
function apply(ctx, config) {
  ctx.console.addEntry({
    dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
    prod: (0, import_path.resolve)(__dirname, "../dist")
  });
  ctx.plugin(meta_default, config);
  ctx.plugin(stats_default, config);
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  MetaProvider,
  RECENT_LENGTH,
  StatisticsProvider,
  apply,
  average,
  name,
  using
});
//# sourceMappingURL=index.js.map
