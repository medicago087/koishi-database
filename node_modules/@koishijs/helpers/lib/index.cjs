var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/packages/helpers/src/index.ts
var src_exports = {};
__export(src_exports, {
  adminChannel: () => adminChannel,
  adminUser: () => adminUser,
  handleError: () => handleError,
  parsePlatform: () => parsePlatform
});
module.exports = __toCommonJS(src_exports);
var import_koishi = require("koishi");

// koishi/packages/helpers/src/locales/zh-CN.yml
var zh_CN_default = { internal: { "error-encountered": "发生未知错误：{0}" }, admin: { "user-option": "指定目标用户", "user-not-found": "未找到指定的用户。", "user-unchanged": "用户数据未改动。", "user-updated": "用户数据已修改。", "channel-option": "指定目标频道", "channel-not-found": "未找到指定的频道。", "channel-unchanged": "频道数据未改动。", "channel-updated": "频道数据已修改。", "not-in-group": "当前不在群组上下文中，请使用 -c 参数指定目标频道。" } };

// koishi/packages/helpers/src/locales/en-US.yml
var en_US_default = { internal: { "error-encountered": "An unknown error has occurred: {0}" }, admin: { "user-not-found": "User not found.", "user-unchanged": "User data unchanged.", "user-updated": "User data updated.", "channel-not-found": "Channel not found.", "channel-unchanged": "Channel data unchanged.", "channel-updated": "Channel data updated.", "not-in-group": "Not in guild context, use -c to specify target channel." } };

// koishi/packages/helpers/src/locales/ja-JP.yml
var ja_JP_default = { internal: { "error-encountered": "不明なエラーが発生しました：{0}" }, admin: { "user-option": "特定のユーザーを指定する", "user-not-found": "指定されたユーザーが見つかりません。", "user-unchanged": "ユーザーデータは変更されていません。", "user-updated": "ユーザーデータが変更されました。", "channel-option": "特定のチャンネルを指定する", "channel-not-found": "指定されたチャンネルが見つかりません。", "channel-unchanged": "チャンネルデータは変更されていません。", "channel-updated": "チャンネルデータが変更されました。", "not-in-group": "ギルドコンテキストではありません。-c を使用して特定のチャンネルを指定します。" } };

// koishi/packages/helpers/src/locales/fr-FR.yml
var fr_FR_default = { internal: { "error-encountered": "Une erreur inconnue s'est produite : {0}" }, admin: { "user-not-found": "Utilisateur introuvable.", "user-unchanged": "Les données utilisateur n'ont pas été modifiées.", "user-updated": "Les données utilisateur ont été changées.", "channel-not-found": "Canel introuvable.", "channel-unchanged": "Les données du canel n'ont pas été modifiées.", "channel-updated": "Les données du canel ont été changées.", "not-in-group": "Vous n'êtes pas dans le contexte du groupe, tapez -c pour spécifier le canel cible." } };

// koishi/packages/helpers/src/locales/zh-TW.yml
var zh_TW_default = { internal: { "error-encountered": "出現未知錯誤：{0}" }, admin: { "user-not-found": "找不到指定的用戶。", "user-unchanged": "用戶資料未更新。", "user-updated": "用戶資料已更新。", "channel-option": "指定目標頻道", "channel-not-found": "找不到指定的頻道。", "channel-unchanged": "頻道資料未更新。", "channel-updated": "頻道資料已更新。", "not-in-group": "當前不在群組上下文中，請使用 -c 參數指定目標頻道。" } };

// koishi/packages/helpers/src/index.ts
function parsePlatform(target) {
  const index = target.indexOf(":");
  const platform = target.slice(0, index);
  const id = target.slice(index + 1);
  return [platform, id];
}
__name(parsePlatform, "parsePlatform");
var refs = /* @__PURE__ */ new WeakSet();
function loadI18n(app) {
  if (refs.has(app))
    return;
  refs.add(app);
  app.i18n.define("zh", zh_CN_default);
  app.i18n.define("en", en_US_default);
  app.i18n.define("ja", ja_JP_default);
  app.i18n.define("fr", fr_FR_default);
  app.i18n.define("zh-TW", zh_TW_default);
}
__name(loadI18n, "loadI18n");
function handleError(cmd, handler) {
  loadI18n(cmd.ctx.root);
  return cmd.action(async (argv, ...args) => {
    try {
      return await argv.next();
    } catch (error) {
      if (handler)
        return handler(error, argv);
      return argv.session.text("internal.error-encountered", error.message);
    }
  }, true);
}
__name(handleError, "handleError");
function adminUser(cmd) {
  let notFound = false;
  loadI18n(cmd.ctx.root);
  async function setTarget(argv) {
    const { options, session } = argv;
    const { user, app } = session;
    if (!options.user)
      return;
    const [platform, userId] = parsePlatform(options.user);
    if (session.user[platform] === userId)
      return;
    const fields = session.collect("user", argv);
    const data = await app.database.getUser(platform, userId, [...fields]);
    if (!data) {
      notFound = true;
      const temp = app.model.tables.user.create();
      temp[platform] = userId;
      session.user = (0, import_koishi.observe)(temp, async (diff) => {
        await app.database.createUser(platform, userId, diff);
      }, `user ${options.user}`);
    } else if (user.authority <= data.authority) {
      return session.text("internal.low-authority");
    } else {
      session.user = (0, import_koishi.observe)(data, async (diff) => {
        await app.database.setUser(platform, userId, diff);
      }, `user ${options.user}`);
    }
  }
  __name(setTarget, "setTarget");
  return cmd.option("user", "-u [user:user]", { authority: 3, descPath: "admin.user-option" }).userFields(["authority"]).userFields(({ session, options }, fields) => {
    const platform = options.user ? options.user.split(":")[0] : session.platform;
    fields.add(platform);
  }).action(async (argv, ...args) => {
    const { session, next } = argv;
    const user = session.user;
    const output = await setTarget(argv);
    if (output)
      return output;
    try {
      const diffKeys = Object.keys(session.user.$diff);
      const result = await next();
      if (notFound && !session.user.authority) {
        return session.text("admin.user-not-found");
      } else if (typeof result === "string") {
        return result;
      } else if (!(0, import_koishi.difference)(Object.keys(session.user.$diff), diffKeys).length) {
        return session.text("admin.user-unchanged");
      } else if (session.user !== user && session.user.authority >= user.authority) {
        return session.text("internal.low-authority");
      }
      await session.user.$update();
      return session.text("admin.user-updated");
    } finally {
      session.user = user;
    }
  }, true);
}
__name(adminUser, "adminUser");
function adminChannel(cmd) {
  let notFound = false;
  loadI18n(cmd.ctx.root);
  async function setTarget(argv) {
    const { options, session } = argv;
    const { app } = session;
    if (session.subtype === "private" && !options.channel) {
      return session.text("admin.not-in-group");
    }
    const { channel = session.cid } = options;
    if (channel === session.cid && !session.channel["$detached"])
      return;
    const [platform, channelId] = parsePlatform(channel);
    const fields = argv.session.collect("channel", argv);
    const data = await app.database.getChannel(platform, channelId, [...fields]);
    if (!data) {
      notFound = true;
      const temp = app.model.tables.channel.create();
      temp.platform = platform;
      temp.id = channelId;
      session.channel = (0, import_koishi.observe)(temp, async (diff) => {
        await app.database.createChannel(platform, channelId, diff);
      }, `channel ${channel}`);
    } else {
      session.channel = (0, import_koishi.observe)(data, async (diff) => {
        await app.database.setChannel(platform, channelId, diff);
      }, `channel ${channel}`);
    }
  }
  __name(setTarget, "setTarget");
  return cmd.channelFields(["assignee"]).option("channel", "-c [channel:channel]", { authority: 3, descPath: "admin.channel-option" }).action(async (argv, ...args) => {
    const { session, next } = argv;
    const channel = session.channel;
    const output = await setTarget(argv);
    if (output)
      return output;
    try {
      const diffKeys = Object.keys(session.channel.$diff);
      const result = await next();
      if (notFound && !session.channel.assignee) {
        return session.text("admin.channel-not-found");
      } else if (typeof result === "string") {
        return result;
      } else if (!(0, import_koishi.difference)(Object.keys(session.channel.$diff), diffKeys).length) {
        return session.text("admin.channel-unchanged");
      }
      await session.channel.$update();
      return session.text("admin.channel-updated");
    } finally {
      session.channel = channel;
    }
  }, true);
}
__name(adminChannel, "adminChannel");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  adminChannel,
  adminUser,
  handleError,
  parsePlatform
});
//# sourceMappingURL=index.cjs.map
