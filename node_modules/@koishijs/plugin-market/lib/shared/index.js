var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// external/console/packages/market/src/shared/index.ts
var shared_exports = {};
__export(shared_exports, {
  ConfigWriter: () => ConfigWriter,
  MarketProvider: () => MarketProvider,
  PackageProvider: () => PackageProvider,
  ServiceProvider: () => ServiceProvider,
  splitPath: () => splitPath
});
module.exports = __toCommonJS(shared_exports);

// external/console/packages/market/src/shared/market.ts
var import_koishi = require("koishi");
var import_plugin_console = require("@koishijs/plugin-console");
var logger = new import_koishi.Logger("market");
var MarketProvider = class extends import_plugin_console.DataService {
  constructor(ctx) {
    super(ctx, "market", { authority: 4 });
    ctx.console.addListener("market/refresh", () => this.start(), { authority: 4 });
  }
  start() {
    this._task = null;
  }
  async prepare() {
    return this._task || (this._task = this.collect().catch((error) => {
      logger.warn(error);
      this._error = error;
    }));
  }
};
__name(MarketProvider, "MarketProvider");

// external/console/packages/market/src/shared/packages.ts
var import_plugin_console2 = require("@koishijs/plugin-console");
var PackageProvider = class extends import_plugin_console2.DataService {
  constructor(ctx) {
    super(ctx, "packages", { authority: 4 });
    ctx.on("internal/runtime", (runtime) => {
      this.update(runtime);
    });
    ctx.on("internal/fork", (fork) => {
      this.update(fork);
    });
  }
  update(state) {
    this.refresh();
  }
  parseRuntime(runtime, result) {
    result.id = runtime.uid;
    result.forkable = runtime.isForkable;
  }
};
__name(PackageProvider, "PackageProvider");

// external/console/packages/market/src/shared/service.ts
var import_plugin_console3 = require("@koishijs/plugin-console");
var import_koishi2 = require("koishi");
var ServiceProvider = class extends import_plugin_console3.DataService {
  constructor(ctx) {
    super(ctx, "services");
    ctx.on("internal/service", () => this.refresh());
  }
  async get() {
    var _a, _b;
    const services = {};
    const descriptors = Object.getOwnPropertyDescriptors(import_koishi2.Context.prototype);
    for (const key in descriptors) {
      const desc = descriptors[key];
      if ("value" in desc)
        continue;
      const uid = (_b = (_a = this.ctx[key]) == null ? void 0 : _a[import_koishi2.Context.source]) == null ? void 0 : _b.state.uid;
      if (uid)
        services[key] = uid;
    }
    return services;
  }
};
__name(ServiceProvider, "ServiceProvider");

// external/console/packages/market/src/shared/writer.ts
var import_plugin_console4 = require("@koishijs/plugin-console");
var import_koishi3 = require("koishi");
var import_loader = require("@koishijs/loader");
function splitPath(path) {
  return path.split(/\/?(@[\w-]+\/[\w:-]+|[\w:-]+)\/?/).filter(Boolean);
}
__name(splitPath, "splitPath");
function insertKey(object, temp, rest) {
  for (const key of rest) {
    temp[key] = object[key];
    delete object[key];
  }
  Object.assign(object, temp);
}
__name(insertKey, "insertKey");
function rename(object, old, neo, value) {
  const keys = Object.keys(object);
  const index = keys.findIndex((key) => key === old || key === "~" + old);
  const rest = index < 0 ? [] : keys.slice(index + 1);
  const temp = { [neo]: value };
  delete object[old];
  delete object["~" + old];
  insertKey(object, temp, rest);
}
__name(rename, "rename");
function dropKey(plugins, name) {
  if (!(name in plugins)) {
    name = "~" + name;
  }
  const value = plugins[name];
  delete plugins[name];
  return { [name]: value };
}
__name(dropKey, "dropKey");
var ConfigWriter = class extends import_plugin_console4.DataService {
  constructor(ctx) {
    super(ctx, "config", { authority: 4 });
    this.loader = ctx.loader;
    this.plugins = ctx.loader.config.plugins;
    ctx.console.addListener("manager/app-reload", (config) => {
      this.reloadApp(config);
    }, { authority: 4 });
    for (const key of ["teleport", "reload", "unload", "remove", "group", "meta", "alias"]) {
      ctx.console.addListener(`manager/${key}`, this[key].bind(this), { authority: 4 });
    }
    ctx.on("config", () => this.refresh());
  }
  getGroup(plugins, ctx) {
    const result = { ...plugins };
    for (const key in plugins) {
      if (key.startsWith("$"))
        continue;
      const value = plugins[key];
      const name = key.split(":", 1)[0].replace(/^~/, "");
      if (name === "group") {
        const fork = ctx.state[import_loader.Loader.kRecord][key];
        result[key] = this.getGroup(value, fork.ctx);
      }
    }
    return result;
  }
  async get() {
    const result = { ...this.loader.config };
    result.plugins = this.getGroup(result.plugins, this.loader.entry);
    return result;
  }
  reloadApp(config) {
    this.loader.config = config;
    this.loader.config.plugins = this.plugins;
    this.loader.writeConfig();
    this.loader.fullReload();
  }
  resolve(path) {
    const segments = splitPath(path);
    if (path.endsWith("/"))
      segments.push("");
    let ctx = this.loader.entry;
    let name = segments.shift();
    while (segments.length) {
      ctx = ctx.state[import_loader.Loader.kRecord][name].ctx;
      name = segments.shift();
    }
    return [ctx.state, name];
  }
  alias(path, alias) {
    const [parent, oldKey] = this.resolve(path);
    let config;
    let newKey = oldKey.split(":", 1)[0] + (alias ? ":" : "") + alias;
    const record = parent[import_loader.Loader.kRecord];
    const fork = record[oldKey];
    if (fork) {
      delete record[oldKey];
      record[newKey] = fork;
      fork.alias = alias;
      fork.ctx.emit("internal/fork", fork);
      config = parent.config[oldKey];
    } else {
      newKey = "~" + newKey;
      config = parent.config["~" + oldKey];
    }
    rename(parent.config, oldKey, newKey, config);
    this.loader.writeConfig();
  }
  meta(path, config) {
    const [parent, name] = this.resolve(path);
    const target = path ? parent.config[name] : parent.config;
    for (const key of Object.keys(config)) {
      if (config[key] === null) {
        delete target[key];
      } else {
        target[key] = config[key];
      }
    }
    this.loader.writeConfig();
  }
  async reload(path, config, newKey) {
    const [parent, oldKey] = this.resolve(path);
    if (newKey) {
      this.loader.unloadPlugin(parent.ctx, oldKey);
    }
    await this.loader.reloadPlugin(parent.ctx, newKey || oldKey, config);
    rename(parent.config, oldKey, newKey || oldKey, config);
    this.loader.writeConfig();
    this.refresh();
  }
  unload(path, config = {}, newKey) {
    const [parent, oldKey] = this.resolve(path);
    this.loader.unloadPlugin(parent.ctx, oldKey);
    rename(parent.config, oldKey, "~" + (newKey || oldKey), config);
    this.loader.writeConfig();
    this.refresh();
  }
  remove(path) {
    const [parent, key] = this.resolve(path);
    this.loader.unloadPlugin(parent.ctx, key);
    delete parent.config[key];
    delete parent.config["~" + key];
    this.loader.writeConfig();
    this.refresh();
  }
  async group(path) {
    const [parent, oldKey] = this.resolve(path);
    const config = parent.config[oldKey] = {};
    await this.loader.reloadPlugin(parent.ctx, oldKey, config);
    this.loader.writeConfig();
    this.refresh();
  }
  teleport(source, target, index) {
    const [parentS, oldKey] = this.resolve(source);
    const [parentT] = this.resolve(target ? target + "/" : "");
    const fork = parentS[import_loader.Loader.kRecord][oldKey];
    if (fork && parentS !== parentT) {
      delete parentS[import_loader.Loader.kRecord][oldKey];
      parentT[import_loader.Loader.kRecord][oldKey] = fork;
      (0, import_koishi3.remove)(parentS.disposables, fork.dispose);
      parentT.disposables.push(fork.dispose);
      fork.parent = parentT.ctx;
      Object.setPrototypeOf(fork.ctx, parentT.ctx);
      fork.ctx.emit("internal/fork", fork);
      if (fork.runtime.using.some((name) => parentS[name] !== parentT[name])) {
        fork.restart();
      }
    }
    const temp = dropKey(parentS.config, oldKey);
    const rest = Object.keys(parentT.config).slice(index);
    insertKey(parentT.config, temp, rest);
    this.loader.writeConfig();
  }
};
__name(ConfigWriter, "ConfigWriter");
ConfigWriter.using = ["console.packages"];
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ConfigWriter,
  MarketProvider,
  PackageProvider,
  ServiceProvider,
  splitPath
});
//# sourceMappingURL=index.js.map
