var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// koishi/external/console/packages/market/src/browser/index.ts
import { Schema } from "koishi";

// koishi/external/console/packages/market/src/browser/installer.ts
import { DataService } from "@koishijs/plugin-console";
var Installer = class extends DataService {
  constructor(ctx) {
    super(ctx, "dependencies", { authority: 4 });
    this.ctx = ctx;
  }
  async get(force = false) {
    const market = await this.ctx.console.market.prepare();
    const objects = [...market.objects.filter((o) => o.portable), ...market.shared];
    return Object.fromEntries(objects.map((object) => [object.name, {
      request: object.version,
      resolved: object.version,
      versions: object.versions,
      latest: object.version
    }]));
  }
};
__name(Installer, "Installer");
__publicField(Installer, "using", ["console.market"]);
var installer_default = Installer;

// koishi/external/console/packages/market/src/browser/market.ts
import { MarketProvider as BaseMarketProvider } from "../shared/index.mjs";
var MarketProvider = class extends BaseMarketProvider {
  start() {
    super.start();
    this.refresh();
  }
  async collect() {
    const response = await fetch("https://registry.koishi.chat/market.json");
    return await response.json();
  }
  async get() {
    const market = await this.prepare();
    if (!market)
      return { data: {}, failed: 0, total: 0, progress: 0 };
    return {
      data: Object.fromEntries(market.objects.map((item) => [item.name, item])),
      failed: 0,
      total: market.objects.length,
      progress: market.objects.length
    };
  }
};
__name(MarketProvider, "MarketProvider");

// koishi/external/console/packages/market/src/browser/packages.ts
import { Context, pick } from "koishi";
import { PackageProvider as BasePackageProvider } from "../shared/index.mjs";
var PackageProvider = class extends BasePackageProvider {
  async getManifest(name2) {
    const market = await this.ctx.console.market.prepare();
    return market.objects.find((item) => {
      return name2 === item.name.replace(/(koishi-|^@koishijs\/)plugin-/, "");
    })?.manifest;
  }
  async get(forced = false) {
    const market = await this.ctx.console.market.prepare();
    const packages = await Promise.all(market.objects.map(async (data) => {
      const result = pick(data, [
        "name",
        "version",
        "description",
        "portable",
        "manifest"
      ]);
      result.shortname = data.name.replace(/(koishi-|^@koishijs\/)plugin-/, "");
      result.manifest = data.manifest;
      result.peerDependencies = { ...data.versions[data.version].peerDependencies };
      if (!result.portable)
        return;
      const exports = await this.ctx.loader.resolvePlugin(data.shortname);
      result.schema = exports?.Config || exports?.schema;
      const runtime = this.ctx.registry.get(exports);
      if (runtime)
        this.parseRuntime(runtime, result);
      return result;
    }));
    packages.unshift({
      name: "",
      shortname: "",
      schema: Context.Config
    });
    return Object.fromEntries(packages.filter((x) => x).map((data) => [data.name, data]));
  }
};
__name(PackageProvider, "PackageProvider");
__publicField(PackageProvider, "using", ["console.market"]);

// koishi/external/console/packages/market/src/browser/index.ts
import { ConfigWriter, ServiceProvider } from "../shared/index.mjs";
export * from "../shared/index.mjs";
var name = "manager";
var using = ["console"];
var Config = Schema.object({});
function apply(ctx, config) {
  ctx.plugin(installer_default);
  ctx.plugin(MarketProvider);
  ctx.plugin(PackageProvider);
  ctx.plugin(ConfigWriter);
  ctx.plugin(ServiceProvider);
  ctx.console.addEntry(process.env.KOISHI_BASE ? [
    process.env.KOISHI_BASE + "/dist/index.js",
    process.env.KOISHI_BASE + "/dist/style.css"
  ] : [
    import.meta.url.replace(/\/src\/[^/]+\/[^/]+$/, "/client/index.ts")
  ]);
}
__name(apply, "apply");
export {
  Config,
  installer_default as Installer,
  MarketProvider,
  PackageProvider,
  apply,
  name,
  using
};
//# sourceMappingURL=index.mjs.map
