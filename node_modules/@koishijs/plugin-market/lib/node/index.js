var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/external/console/packages/market/src/node/index.ts
var node_exports = {};
__export(node_exports, {
  Config: () => Config,
  Installer: () => installer_default,
  apply: () => apply,
  name: () => name,
  using: () => using
});
module.exports = __toCommonJS(node_exports);
var import_koishi5 = require("koishi");
var import_path3 = require("path");

// koishi/external/console/packages/market/src/node/installer.ts
var import_koishi2 = require("koishi");
var import_plugin_console = require("@koishijs/plugin-console");
var import_path = require("path");
var import_fs2 = require("fs");

// koishi/external/console/packages/market/src/node/utils.ts
var import_fs = require("fs");
var import_koishi = require("koishi");
function loadManifest(name2) {
  const filename = require.resolve(name2 + "/package.json");
  const meta = JSON.parse((0, import_fs.readFileSync)(filename, "utf8"));
  meta.dependencies || (meta.dependencies = {});
  (0, import_koishi.defineProperty)(meta, "$workspace", !filename.includes("node_modules"));
  return meta;
}
__name(loadManifest, "loadManifest");

// koishi/external/console/packages/market/src/node/installer.ts
var import_semver = require("semver");
var import_get_registry = __toESM(require("get-registry"));
var import_which_pm_runs = __toESM(require("which-pm-runs"));
var import_execa = __toESM(require("execa"));
var import_p_map = __toESM(require("p-map"));
var logger = new import_koishi2.Logger("market");
var _a;
var Installer = class extends import_plugin_console.DataService {
  constructor(ctx, config) {
    super(ctx, "dependencies", { authority: 4 });
    this.ctx = ctx;
    this.config = config;
    this.agent = ((_a = (0, import_which_pm_runs.default)()) == null ? void 0 : _a.name) || "npm";
    this.installDep = async (deps) => {
      const oldPayload = await this.get();
      await this.override(deps);
      let shouldInstall = false;
      for (const name2 in deps) {
        const { resolved } = oldPayload[name2] || {};
        if (deps[name2] && resolved && (0, import_semver.satisfies)(resolved, deps[name2], { includePrerelease: true }))
          continue;
        shouldInstall = true;
        break;
      }
      if (shouldInstall) {
        const code = await this.install();
        if (code)
          return code;
      }
      await this.refresh();
      const newPayload = await this.get();
      for (const name2 in oldPayload) {
        const { resolved, workspace } = oldPayload[name2];
        if (workspace || !newPayload[name2])
          continue;
        if (newPayload[name2].resolved === resolved)
          continue;
        if (!(require.resolve(name2) in require.cache))
          continue;
        this.ctx.loader.fullReload();
      }
      this.ctx.console.packages.refresh();
      return 0;
    };
    this.manifest = loadManifest(this.cwd);
    ctx.console.addListener("market/install", this.installDep, { authority: 4 });
  }
  get cwd() {
    return this.ctx.baseDir;
  }
  async prepare() {
    const { endpoint, timeout } = this.config;
    this.registry = endpoint || await (0, import_get_registry.default)();
    this.http = this.ctx.http.extend({ endpoint: this.registry, timeout });
  }
  async start() {
    await this.prepare();
  }
  async _get() {
    const result = (0, import_koishi2.valueMap)(this.manifest.dependencies, (request) => {
      return { request: request.replace(/^[~^]/, "") };
    });
    await (0, import_p_map.default)(Object.keys(result), async (name2) => {
      try {
        const meta = loadManifest(name2);
        result[name2].resolved = meta.version;
        result[name2].workspace = meta.$workspace;
        if (meta.$workspace)
          return;
      } catch {
      }
      if (!(0, import_semver.valid)(result[name2].request)) {
        result[name2].invalid = true;
        return;
      }
      try {
        const registry = await this.http.get(`/${name2}`);
        const entries = Object.values(registry.versions).map((item) => [item.version, (0, import_koishi2.pick)(item, ["peerDependencies", "peerDependenciesMeta"])]).sort(([a], [b]) => (0, import_semver.compare)(b, a));
        result[name2].latest = entries[0][0];
        result[name2].versions = Object.fromEntries(entries);
      } catch (e) {
        logger.warn(e.message);
      }
    }, { concurrency: 10 });
    return result;
  }
  async get(force = false) {
    if (!force && this.task)
      return this.task;
    return this.task = this._get();
  }
  async exec(command, args) {
    return new Promise((resolve3) => {
      const child = (0, import_execa.default)(command, args, { cwd: this.cwd });
      child.on("exit", (code) => resolve3(code));
      child.on("error", () => resolve3(-1));
      child.stderr.on("data", (data) => {
        data = data.toString().trim();
        if (!data)
          return;
        for (const line of data.split("\n")) {
          logger.warn(line);
        }
      });
      child.stdout.on("data", (data) => {
        data = data.toString().trim();
        if (!data)
          return;
        for (const line of data.split("\n")) {
          logger.info(line);
        }
      });
    });
  }
  async override(deps) {
    const filename = (0, import_path.resolve)(this.cwd, "package.json");
    for (const key in deps) {
      if (deps[key]) {
        this.manifest.dependencies[key] = deps[key];
      } else {
        delete this.manifest.dependencies[key];
      }
    }
    this.manifest.dependencies = Object.fromEntries(Object.entries(this.manifest.dependencies).sort((a, b) => a[0].localeCompare(b[0])));
    await import_fs2.promises.writeFile(filename, JSON.stringify(this.manifest, null, 2));
  }
  install() {
    const args = [];
    if (this.agent !== "yarn")
      args.push("install");
    args.push("--registry", this.registry);
    return this.exec(this.agent, args);
  }
};
__name(Installer, "Installer");
((Installer2) => {
  Installer2.Config = import_koishi2.Schema.object({
    endpoint: import_koishi2.Schema.string().role("link").description("插件的下载源。默认跟随当前项目的 npm config。"),
    timeout: import_koishi2.Schema.number().role("time").default(import_koishi2.Time.second * 5).description("获取插件数据的超时时间。")
  }).description("插件源设置");
})(Installer || (Installer = {}));
var installer_default = Installer;

// koishi/external/console/packages/market/src/node/market.ts
var import_koishi3 = require("koishi");
var import_registry = __toESM(require("@koishijs/registry"));
var import_shared = require("../shared");
var import_throttle_debounce = require("throttle-debounce");
var MarketProvider = class extends import_shared.MarketProvider {
  constructor(ctx, config) {
    super(ctx);
    this.config = config;
    this.failed = [];
    this.fullCache = {};
    this.tempCache = {};
    this.flushData = (0, import_throttle_debounce.throttle)(500, () => {
      this.ctx.console.broadcast("market/patch", {
        data: this.tempCache,
        failed: this.failed.length,
        total: this.scanner.total,
        progress: this.scanner.progress
      });
      this.tempCache = {};
    });
    if (config.endpoint)
      this.http = ctx.http.extend(config);
  }
  async start() {
    super.start();
    this.failed = [];
    this.fullCache = {};
    this.tempCache = {};
    this.ctx.console.dependencies.refresh();
    await this.prepare();
    this.refresh();
  }
  stop() {
    this.flushData.cancel();
  }
  async collect() {
    const { timeout } = this.config;
    this.failed = [];
    this.scanner = new import_registry.default(this.ctx.console.dependencies.http.get);
    if (this.http) {
      const result = await this.http.get("");
      this.scanner.objects = result.objects.filter((object) => !object.ignored);
      this.scanner.total = this.scanner.objects.length;
    } else {
      await this.scanner.collect({ timeout });
    }
    this.scanner.analyze({
      version: "4",
      onFailure: (name2, reason) => {
        this.failed.push(name2);
      },
      onSuccess: (item) => {
        const { name: name2, versions } = item;
        this.tempCache[name2] = this.fullCache[name2] = {
          ...item,
          versions: (0, import_koishi3.valueMap)(versions, (item2) => (0, import_koishi3.pick)(item2, ["peerDependencies", "peerDependenciesMeta"]))
        };
      },
      after: () => this.flushData()
    });
    return null;
  }
  async get() {
    await this.prepare();
    if (this._error)
      return { data: {}, failed: 0, total: 0, progress: 0 };
    return {
      data: this.fullCache,
      failed: this.failed.length,
      total: this.scanner.total,
      progress: this.scanner.progress,
      gravatar: process.env.GRAVATAR_MIRROR
    };
  }
};
__name(MarketProvider, "MarketProvider");
MarketProvider.using = ["console.dependencies"];
((MarketProvider2) => {
  MarketProvider2.Config = import_koishi3.Schema.object({
    endpoint: import_koishi3.Schema.string().role("link").description("用于搜索插件市场的网址。默认跟随 registry 设置。"),
    timeout: import_koishi3.Schema.number().role("time").default(import_koishi3.Time.second * 30).description("搜索插件市场的超时时间。"),
    proxyAgent: import_koishi3.Schema.string().role("link").description("用于搜索插件市场的代理。")
  }).description("搜索设置");
})(MarketProvider || (MarketProvider = {}));
var market_default = MarketProvider;

// koishi/external/console/packages/market/src/node/packages.ts
var import_koishi4 = require("koishi");
var import_registry2 = require("@koishijs/registry");
var import_fs3 = require("fs");
var import_path2 = require("path");
var import_loader = require("@koishijs/loader");
var import_shared2 = require("../shared");
var logger2 = new import_koishi4.Logger("market");
function getExports(id) {
  const path = require.resolve(id);
  const keys = Object.keys(require.cache);
  let result = require.cache[path];
  if (!result) {
    require(path);
    result = require.cache[path];
    (0, import_koishi4.remove)(module.children, result);
    for (const key in require.cache) {
      if (!keys.includes(key)) {
        delete require.cache[key];
      }
    }
  }
  return (0, import_loader.unwrapExports)(result.exports);
}
__name(getExports, "getExports");
var PackageProvider = class extends import_shared2.PackageProvider {
  constructor() {
    super(...arguments);
    this.cache = {};
  }
  update(state) {
    const entry = Object.keys(require.cache).find((key) => {
      return (0, import_loader.unwrapExports)(require.cache[key].exports) === state.runtime.plugin;
    });
    if (!this.cache[entry])
      return;
    const data = this.cache[entry];
    this.parseRuntime(state.runtime, data);
    this.refresh();
  }
  async prepare() {
    this.cache = {};
    let { baseDir } = this.ctx;
    const tasks = [];
    while (1) {
      tasks.push(this.loadDirectory(baseDir));
      const parent = (0, import_path2.dirname)(baseDir);
      if (baseDir === parent)
        break;
      baseDir = parent;
    }
    await Promise.all(tasks);
  }
  async get(forced = false) {
    if (forced)
      delete this.task;
    await (this.task || (this.task = this.prepare()));
    const packages = Object.values(this.cache);
    packages.unshift({
      name: "",
      shortname: "",
      schema: import_koishi4.Context.Config
    });
    return Object.fromEntries(packages.filter((x) => x).map((data) => [data.name, data]));
  }
  async loadDirectory(baseDir) {
    const base = baseDir + "/node_modules";
    const files = await import_fs3.promises.readdir(base).catch(() => []);
    for (const name2 of files) {
      const base2 = base + "/" + name2;
      if (name2.startsWith("@")) {
        const files2 = await import_fs3.promises.readdir(base2).catch(() => []);
        for (const name22 of files2) {
          if (name2 === "@koishijs" && name22.startsWith("plugin-") || name22.startsWith("koishi-plugin-")) {
            this.loadPackage(name2 + "/" + name22);
          }
        }
      } else {
        if (name2.startsWith("koishi-plugin-")) {
          this.loadPackage(name2);
        }
      }
    }
  }
  loadPackage(name2) {
    try {
      this.cache[require.resolve(name2)] = this.parsePackage(name2);
    } catch (error) {
      logger2.warn("failed to parse %c", name2);
      logger2.warn(error);
    }
  }
  parsePackage(name2) {
    const data = loadManifest(name2);
    const result = (0, import_koishi4.pick)(data, [
      "name",
      "version",
      "description"
    ]);
    result.workspace = data.$workspace;
    result.shortname = data.name.replace(/(koishi-|^@koishijs\/)plugin-/, "");
    result.manifest = (0, import_registry2.conclude)(data);
    result.peerDependencies = { ...data.peerDependencies };
    const exports = getExports(name2);
    result.schema = (exports == null ? void 0 : exports.Config) || (exports == null ? void 0 : exports.schema);
    result.usage = exports == null ? void 0 : exports.usage;
    result.filter = exports == null ? void 0 : exports.filter;
    const runtime = this.ctx.registry.get(exports);
    if (runtime)
      this.parseRuntime(runtime, result);
    JSON.stringify(result);
    return result;
  }
  async getManifest(name2) {
    const filename = await this.ctx.loader.resolve(name2 + "/package.json");
    return (0, import_registry2.conclude)(JSON.parse(await import_fs3.promises.readFile(filename, "utf8")));
  }
};
__name(PackageProvider, "PackageProvider");
var packages_default = PackageProvider;

// koishi/external/console/packages/market/src/node/index.ts
var import_shared3 = require("../shared");
__reExport(node_exports, require("../shared"), module.exports);
var name = "manager";
var using = ["console", "loader"];
var Config = import_koishi5.Schema.intersect([
  import_koishi5.Schema.object({
    registry: installer_default.Config,
    search: market_default.Config
  })
]);
function apply(ctx, config) {
  if (!ctx.loader.writable) {
    return ctx.logger("manager").warn("manager is only available for json/yaml config file");
  }
  ctx.plugin(installer_default, config.registry);
  ctx.plugin(market_default, config.search);
  ctx.plugin(packages_default);
  ctx.plugin(import_shared3.ServiceProvider);
  ctx.plugin(import_shared3.ConfigWriter);
  ctx.console.addEntry({
    dev: (0, import_path3.resolve)(__dirname, "../../client/index.ts"),
    prod: (0, import_path3.resolve)(__dirname, "../../dist")
  });
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  Installer,
  apply,
  name,
  using
});
//# sourceMappingURL=index.js.map
