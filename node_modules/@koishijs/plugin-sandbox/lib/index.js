var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/external/console/packages/sandbox/src/index.ts
var src_exports = {};
__export(src_exports, {
  Config: () => Config,
  UserProvider: () => UserProvider,
  apply: () => apply,
  name: () => name,
  using: () => using
});
module.exports = __toCommonJS(src_exports);
var import_koishi2 = require("koishi");
var import_plugin_console = require("@koishijs/plugin-console");
var import_path = require("path");

// koishi/external/console/packages/sandbox/src/bot.ts
var import_koishi = require("koishi");
var SandboxMessenger = class extends import_koishi.Messenger {
  constructor() {
    super(...arguments);
    this.buffer = "";
  }
  async flush() {
    if (!this.buffer.trim())
      return;
    const content = await import_koishi.segment.transformAsync(this.buffer.trim(), {
      image: async (data) => {
        if (data.url.startsWith("file://") && process.env.KOISHI_ENV !== "browser") {
          const file = await this.bot.ctx.http.file(data.url);
          return import_koishi.segment.image(`data:${file.mime};base64,` + Buffer.from(file.data).toString("base64"));
        }
        if (!data.url.startsWith("base64://"))
          return (0, import_koishi.segment)("image", data);
        return import_koishi.segment.image("data:image/png;base64," + data.url.slice(9));
      }
    });
    const session = this.bot.session(this.session);
    session.messageId = import_koishi.Random.id();
    session.app.console.broadcast("sandbox", {
      content,
      user: "Koishi",
      channel: session.channelId,
      id: session.messageId
    });
    this.results.push(session);
    this.buffer = "";
  }
  async visit(element) {
    const { type, children } = element;
    if (type === "message" || type === "figure") {
      await this.flush();
      await this.render(children);
      await this.flush();
    } else {
      this.buffer += element.toString();
    }
  }
};
__name(SandboxMessenger, "SandboxMessenger");
var SandboxBot = class extends import_koishi.Bot {
  constructor(ctx) {
    super(ctx, {
      platform: "sandbox",
      selfId: "koishi"
    });
    this.ctx = ctx;
    this.username = "koishi";
    this.hidden = true;
    this.internal = {};
    const self = this;
    ctx.console.addListener("sandbox/message", async function(user, channel, content) {
      const id = import_koishi.Random.id();
      ctx.console.broadcast("sandbox", { id, content, user, channel });
      const session = self.session({
        userId: user,
        content,
        messageId: id,
        channelId: channel,
        guildId: channel === "@" + user ? void 0 : channel,
        type: "message",
        subtype: channel === "@" + user ? "private" : "group",
        author: {
          userId: user,
          username: user
        }
      });
      (0, import_koishi.defineProperty)(session, "handle", this);
      self.dispatch(session);
    }, { authority: 4 });
  }
  async sendMessage(channelId, fragment, guildId) {
    return new SandboxMessenger(this, channelId, guildId).send(fragment);
  }
  async deleteMessage(channelId, messageId) {
    this.ctx.console.broadcast("sandbox/delete", { id: messageId, channel: channelId });
  }
  async getGuildMemberList(guildId) {
    return words.map((word) => ({
      nickname: word,
      userId: word
    }));
  }
};
__name(SandboxBot, "SandboxBot");
var words = [
  "Alice",
  "Bob",
  "Carol",
  "Dave",
  "Eve",
  "Frank",
  "Grace",
  "Hank",
  "Ivy",
  "Jack",
  "Kathy",
  "Lily",
  "Mandy",
  "Nancy",
  "Oscar",
  "Peggy",
  "Quinn",
  "Randy",
  "Sandy",
  "Toby",
  "Uma",
  "Vicky",
  "Wendy",
  "Xander",
  "Yvonne",
  "Zoe"
];

// koishi/external/console/packages/sandbox/src/locales/zh.yml
var zh_default = { commands: { clear: { description: "清空聊天记录" } } };

// koishi/external/console/packages/sandbox/src/index.ts
var import_meta = {};
var UserProvider = class extends import_plugin_console.DataService {
  constructor(ctx) {
    super(ctx, "users", { authority: 4 });
    ctx.console.addListener("sandbox/user", async (name2, data) => {
      const users = await this.get();
      if (!users[name2]) {
        if (!data)
          return;
        const user = await this.ctx.database.createUser("sandbox", name2, {
          authority: 1,
          ...data
        });
        return this.observe(user, users);
      } else if (!data) {
        delete users[name2];
        this.ctx.$internal._userCache.set("sandbox", "sandbox:" + name2, null);
        return this.ctx.database.remove("user", { sandbox: name2 });
      }
      Object.assign(users[name2], data);
      return users[name2].$update();
    }, { authority: 4 });
  }
  observe(user, users) {
    const uid = "sandbox:" + user.sandbox;
    users[user.sandbox] = (0, import_koishi2.observe)(user, async (diff) => {
      await this.ctx.database.setUser("sandbox", user.sandbox, diff);
      this.refresh();
    });
    this.ctx.$internal._userCache.set("sandbox", uid, users[user.sandbox]);
  }
  async prepare() {
    const data = await this.ctx.database.getUser("sandbox", words);
    const result = {};
    for (const user of data) {
      this.observe(user, result);
    }
    return result;
  }
  stop() {
    this.ctx.$internal._userCache.delete("sandbox");
  }
  async get() {
    return this.task || (this.task = this.prepare());
  }
};
__name(UserProvider, "UserProvider");
UserProvider.using = ["database"];
var name = "sandbox";
var using = ["console"];
var Config = import_koishi2.Schema.object({});
function apply(ctx, config) {
  ctx.plugin(SandboxBot);
  ctx.plugin(UserProvider);
  ctx.console.addEntry(process.env.KOISHI_BASE ? [
    process.env.KOISHI_BASE + "/dist/index.js",
    process.env.KOISHI_BASE + "/dist/style.css"
  ] : process.env.KOISHI_ENV === "browser" ? [
    import_meta.url.replace(/\/src\/[^/]+$/, "/client/index.ts")
  ] : {
    dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
    prod: (0, import_path.resolve)(__dirname, "../dist")
  });
  ctx.i18n.define("zh", zh_default);
  ctx.platform("sandbox").command("clear").action(({ session }) => {
    session.handle.send({
      type: "sandbox/clear"
    });
  });
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  UserProvider,
  apply,
  name,
  using
});
//# sourceMappingURL=index.js.map
