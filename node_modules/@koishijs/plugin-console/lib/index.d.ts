import { Context, Service, Awaitable, Dict, Schema, WebSocketLayer } from 'koishi';
export namespace DataService {
    interface Options {
        immediate?: boolean;
        authority?: number;
    }
}
export abstract class DataService<T = never> extends Service {
    protected ctx: Context;
    protected key: keyof Console.Services;
    options: DataService.Options;
    static keys: Set<string>;
    static define(name: keyof Console.Services): void;
    get(forced?: boolean): Promise<T>;
    constructor(ctx: Context, key: keyof Console.Services, options?: DataService.Options);
    start(): void;
    refresh(): Promise<void>;
    patch(value: T): void;
}
export interface AbstractWebSocket {
    onopen(event: any): void;
    onerror(event: any): void;
    onmessage(event: any): void;
    onclose(event: any): void;
    send(data: string): void;
    addEventListener(event: string, listener: (event: any) => void): void;
    removeEventListener(event: string, listener: (event: any) => void): void;
}
type NestedServices = {
    [K in keyof Console.Services as `console.${K}`]: Console.Services[K];
};
declare module 'koishi' {
    interface Context extends NestedServices {
        console: NodeConsole;
    }
    interface Events {
        'console/intercept'(handle: SocketHandle, listener: DataService.Options): Awaitable<boolean>;
    }
}
export interface Console extends Console.Services {
}
export interface Listener extends DataService.Options {
    callback(this: SocketHandle, ...args: any[]): Awaitable<any>;
}
export class SocketHandle {
    readonly ctx: Context;
    socket: AbstractWebSocket;
    readonly id: string;
    constructor(ctx: Context, socket: AbstractWebSocket);
    send(payload: any): void;
    receive(data: any): Promise<void>;
    refresh(): void;
}
export interface Entry {
    dev: string;
    prod: string | string[];
}
export class EntryProvider extends DataService<string[]> {
    constructor(ctx: Context);
    get(): Promise<string[]>;
}
export abstract class Console extends Service {
    ctx: Context;
    readonly entries: Dict<string[]>;
    readonly listeners: Dict<Listener>;
    readonly handles: Dict<SocketHandle>;
    constructor(ctx: Context);
    get(): Promise<string[]>;
    abstract resolveEntry(entry: string | string[] | Entry): string | string[];
    addEntry(entry: string | string[] | Entry): void;
    addListener<K extends keyof Events>(event: K, callback: Events[K], options?: DataService.Options): void;
    broadcast(type: string, body: any, options?: DataService.Options): void;
}
export interface Events {
}
export namespace Console {
    interface Services {
        entry: EntryProvider;
    }
}
export interface ClientConfig {
    devMode: boolean;
    uiPath: string;
    endpoint: string;
    static?: boolean;
}
declare class NodeConsole extends Console {
    ctx: Context;
    config: NodeConsole.Config;
    private vite;
    root: string;
    global: ClientConfig;
    readonly layer: WebSocketLayer;
    constructor(ctx: Context, config: NodeConsole.Config);
    start(): Promise<void>;
    resolveEntry(entry: string | string[] | Entry): string | string[];
    get(): Promise<string[]>;
    private serveAssets;
    private transformHtml;
    private createVite;
    stop(): void;
}
declare namespace NodeConsole {
    interface Config {
        root?: string;
        uiPath?: string;
        devMode?: boolean;
        cacheDir?: string;
        open?: boolean;
        selfUrl?: string;
        apiPath?: string;
    }
    const Config: Schema<Config>;
}
export default Console;
declare class BrowserConsole extends Console {
    start(): void;
    resolveEntry(entry: string | string[] | Entry): string | string[];
}
declare namespace BrowserConsole {
    interface Config {
    }
    const Config: Schema<Config>;
}
