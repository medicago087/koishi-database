var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/external/console/packages/console/src/node/index.ts
var node_exports = {};
__export(node_exports, {
  default: () => node_default
});
module.exports = __toCommonJS(node_exports);
var import_koishi = require("koishi");
var import_shared = require("../shared");
var import_path = require("path");
var import_fs = require("fs");
var import_open = __toESM(require("open"));
__reExport(node_exports, require("../shared"), module.exports);
var NodeConsole = class extends import_shared.Console {
  constructor(ctx, config) {
    super(ctx);
    this.ctx = ctx;
    this.config = config;
    this.global = {};
    const { devMode, uiPath, apiPath, selfUrl } = config;
    this.global.devMode = devMode;
    this.global.uiPath = uiPath;
    this.global.endpoint = selfUrl + apiPath;
    this.layer = ctx.router.ws(config.apiPath, (socket) => {
      new import_shared.SocketHandle(ctx, socket);
      ctx.envData.clientCount = this.layer.clients.size;
      socket.on("close", () => {
        ctx.envData.clientCount = this.layer.clients.size;
      });
    });
    this.root = config.root || config.devMode ? (0, import_path.resolve)(require.resolve("@koishijs/client/package.json"), "../app") : (0, import_path.resolve)(__dirname, "../../dist");
  }
  async start() {
    if (this.config.devMode)
      await this.createVite();
    this.serveAssets();
    if (this.config.open && !this.ctx.envData.clientCount && !process.env.KOISHI_AGENT) {
      const { host, port } = this.ctx.root.config;
      (0, import_open.default)(`http://${host || "localhost"}:${port}${this.config.uiPath}`);
    }
  }
  resolveEntry(entry) {
    if (typeof entry === "string" || Array.isArray(entry))
      return entry;
    if (!this.config.devMode)
      return entry.prod;
    if (!(0, import_fs.existsSync)(entry.dev))
      return entry.prod;
    return entry.dev;
  }
  async get() {
    const { devMode, uiPath } = this.config;
    const filenames = [];
    for (const key in this.entries) {
      for (const local of this.entries[key]) {
        const filename = devMode ? "/vite/@fs/" + local : uiPath + "/" + key;
        if ((0, import_path.extname)(local)) {
          filenames.push(filename);
        } else {
          filenames.push(filename + "/index.js");
          if ((0, import_fs.existsSync)(local + "/style.css")) {
            filenames.push(filename + "/style.css");
          }
        }
      }
    }
    return filenames;
  }
  serveAssets() {
    const { uiPath } = this.config;
    this.ctx.router.get(uiPath + "(/.+)*", async (ctx, next) => {
      await next();
      if (ctx.body || ctx.response.body)
        return;
      if (ctx.path === uiPath && !uiPath.endsWith("/")) {
        return ctx.redirect(ctx.path + "/");
      }
      const name = ctx.path.slice(uiPath.length).replace(/^\/+/, "");
      const sendFile = /* @__PURE__ */ __name((filename2) => {
        ctx.type = (0, import_path.extname)(filename2);
        return ctx.body = (0, import_fs.createReadStream)(filename2);
      }, "sendFile");
      if (name.startsWith("extension-")) {
        const key = name.slice(0, 18);
        if (this.entries[key])
          return sendFile(this.entries[key][0] + name.slice(18));
      }
      const filename = (0, import_path.resolve)(this.root, name);
      if (!filename.startsWith(this.root) && !filename.includes("node_modules")) {
        return ctx.status = 403;
      }
      const stats = await import_fs.promises.stat(filename).catch(import_koishi.noop);
      if (stats == null ? void 0 : stats.isFile())
        return sendFile(filename);
      const ext = (0, import_path.extname)(filename);
      if (ext && ext !== ".html")
        return ctx.status = 404;
      const template = await import_fs.promises.readFile((0, import_path.resolve)(this.root, "index.html"), "utf8");
      ctx.type = "html";
      ctx.body = await this.transformHtml(template);
    });
  }
  async transformHtml(template) {
    const { uiPath } = this.config;
    if (this.vite) {
      template = await this.vite.transformIndexHtml(uiPath, template);
    } else {
      template = template.replace(/(href|src)="(?=\/)/g, (_, $1) => `${$1}="${uiPath}`);
    }
    const headInjection = `<script>KOISHI_CONFIG = ${JSON.stringify(this.ctx.console.global)}<\/script>`;
    return template.replace("</title>", "</title>" + headInjection);
  }
  async createVite() {
    const { cacheDir } = this.config;
    const { createServer } = require("vite");
    const { default: vue } = require("@vitejs/plugin-vue");
    this.vite = await createServer({
      root: this.root,
      base: "/vite/",
      cacheDir: (0, import_path.resolve)(this.ctx.baseDir, cacheDir),
      server: {
        middlewareMode: true,
        fs: {
          strict: false
        }
      },
      plugins: [vue()],
      resolve: {
        dedupe: ["vue", "vue-router", "element-plus", "@vueuse/core", "@popperjs/core"],
        alias: {
          "../client.js": "@koishijs/client",
          "../vue.js": "vue",
          "../vue-router.js": "vue-router",
          "../vueuse.js": "@vueuse/core"
        }
      },
      optimizeDeps: {
        include: [
          "vue",
          "vue-router",
          "element-plus",
          "@vueuse/core",
          "@popperjs/core",
          "d3-force",
          "semver",
          "spark-md5",
          "ansi_up"
        ]
      },
      build: {
        rollupOptions: {
          input: this.root + "/index.html"
        }
      }
    });
    this.ctx.router.all("/vite(/.+)*", (ctx) => new Promise((resolve2) => {
      this.vite.middlewares(ctx.req, ctx.res, resolve2);
    }));
    this.ctx.on("dispose", () => this.vite.close());
  }
  stop() {
    this.layer.close();
  }
};
__name(NodeConsole, "NodeConsole");
((NodeConsole2) => {
  NodeConsole2.Config = import_koishi.Schema.object({
    root: import_koishi.Schema.string().description("前端页面的根目录。").hidden(),
    uiPath: import_koishi.Schema.string().description("前端页面呈现的路径。").default(""),
    apiPath: import_koishi.Schema.string().description("后端 API 服务的路径。").default("/status"),
    selfUrl: import_koishi.Schema.string().description("Koishi 服务暴露在公网的地址。").role("link").default(""),
    open: import_koishi.Schema.boolean().description("在应用启动后自动在浏览器中打开控制台。"),
    devMode: import_koishi.Schema.boolean().description("启用调试模式（仅供开发者使用）。").default(process.env.NODE_ENV === "development").hidden(),
    cacheDir: import_koishi.Schema.string().description("调试服务器缓存目录。").default(".vite").hidden()
  });
})(NodeConsole || (NodeConsole = {}));
var node_default = NodeConsole;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map
