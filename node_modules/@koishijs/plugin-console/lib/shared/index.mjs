var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// koishi/external/console/packages/console/src/shared/index.ts
import { coerce, Logger, makeArray, Random, Service as Service2 } from "koishi";

// koishi/external/console/packages/console/src/shared/service.ts
import { Service } from "koishi";
var _DataService = class extends Service {
  constructor(ctx, key, options = {}) {
    super(ctx, `console.${key}`, options.immediate);
    this.ctx = ctx;
    this.key = key;
    this.options = options;
    _DataService.define(key);
  }
  static define(name) {
    this.keys.add(name);
    if (Object.prototype.hasOwnProperty.call(shared_default.prototype, name))
      return;
    const key = `console.${name}`;
    Object.defineProperty(shared_default.prototype, name, {
      get() {
        return this.caller[key];
      },
      set(value) {
        this.caller[key] = value;
      }
    });
  }
  get(forced) {
    return null;
  }
  start() {
    this.refresh();
  }
  async refresh() {
    this.ctx.console?.broadcast("data", {
      key: this.key,
      value: await this.get(true)
    }, this.options);
  }
  patch(value) {
    this.ctx.console?.broadcast("patch", {
      key: this.key,
      value
    }, this.options);
  }
};
var DataService = _DataService;
__name(DataService, "DataService");
__publicField(DataService, "keys", /* @__PURE__ */ new Set());

// koishi/external/console/packages/console/src/shared/index.ts
var logger = new Logger("console");
var SocketHandle = class {
  constructor(ctx, socket) {
    this.ctx = ctx;
    this.socket = socket;
    socket.onmessage = this.receive.bind(this);
    ctx.on("ready", () => {
      ctx.console.handles[this.id] = this;
      this.refresh();
    });
  }
  id = Random.id();
  send(payload) {
    this.socket.send(JSON.stringify(payload));
  }
  async receive(data) {
    const { type, args, id } = JSON.parse(data.data.toString());
    const listener = this.ctx.console.listeners[type];
    if (!listener) {
      logger.info("unknown message:", type, ...args);
      return this.send({ type: "response", body: { id, error: "not implemented" } });
    }
    if (await this.ctx.serial("console/intercept", this, listener)) {
      return this.send({ type: "response", body: { id, error: "unauthorized" } });
    }
    try {
      const value = await listener.callback.call(this, ...args);
      return this.send({ type: "response", body: { id, value } });
    } catch (e) {
      logger.debug(e);
      const error = coerce(e);
      return this.send({ type: "response", body: { id, error } });
    }
  }
  refresh() {
    DataService.keys.forEach(async (key) => {
      const service = this.ctx[`console.${key}`];
      if (!service)
        return;
      if (await this.ctx.serial("console/intercept", this, service.options)) {
        return this.send({ type: "data", body: { key, value: null } });
      }
      try {
        const value = await service.get();
        if (!value)
          return;
        this.send({ type: "data", body: { key, value } });
      } catch (error) {
        this.ctx.logger("console").warn(error);
      }
    });
  }
};
__name(SocketHandle, "SocketHandle");
var EntryProvider = class extends DataService {
  constructor(ctx) {
    super(ctx, "entry", { immediate: true });
  }
  async get() {
    return this.ctx.console.get();
  }
};
__name(EntryProvider, "EntryProvider");
var Console = class extends Service2 {
  constructor(ctx) {
    super(ctx, "console", true);
    this.ctx = ctx;
    ctx.plugin(EntryProvider);
  }
  entries = /* @__PURE__ */ Object.create(null);
  listeners = /* @__PURE__ */ Object.create(null);
  handles = /* @__PURE__ */ Object.create(null);
  async get() {
    return Object.values(this.entries).flat();
  }
  addEntry(entry) {
    const key = "extension-" + Random.id();
    this.entries[key] = makeArray(this.resolveEntry(entry));
    this.entry.refresh();
    this.caller?.on("dispose", () => {
      delete this.entries[key];
      this.entry?.refresh();
    });
  }
  addListener(event, callback, options) {
    this.listeners[event] = { callback, ...options };
  }
  broadcast(type, body, options = {}) {
    const handles = Object.values(this.handles);
    if (!handles.length)
      return;
    const data = JSON.stringify({ type, body });
    Promise.all(Object.values(this.handles).map(async (handle) => {
      if (await this.ctx.serial("console/intercept", handle, options))
        return;
      handle.socket.send(data);
    }));
  }
};
__name(Console, "Console");
var shared_default = Console;
export {
  Console,
  DataService,
  EntryProvider,
  SocketHandle,
  shared_default as default
};
//# sourceMappingURL=index.mjs.map
