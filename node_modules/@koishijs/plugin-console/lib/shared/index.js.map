{
  "version": 3,
  "sources": ["../../src/shared/index.ts", "../../src/shared/service.ts"],
  "sourcesContent": ["import { Awaitable, coerce, Context, Dict, Logger, makeArray, Random, Service } from 'koishi'\nimport { DataService } from './service'\nimport NodeConsole from '../node'\n\nexport * from './service'\n\nexport interface AbstractWebSocket {\n  onopen(event: any): void\n  onerror(event: any): void\n  onmessage(event: any): void\n  onclose(event: any): void\n  send(data: string): void\n  addEventListener(event: string, listener: (event: any) => void): void\n  removeEventListener(event: string, listener: (event: any) => void): void\n}\n\ntype NestedServices = {\n  [K in keyof Console.Services as `console.${K}`]: Console.Services[K]\n}\n\ndeclare module 'koishi' {\n  interface Context extends NestedServices {\n    console: NodeConsole\n  }\n\n  interface Events {\n    'console/intercept'(handle: SocketHandle, listener: DataService.Options): Awaitable<boolean>\n  }\n}\n\nexport interface Console extends Console.Services {}\n\nexport interface Listener extends DataService.Options {\n  callback(this: SocketHandle, ...args: any[]): Awaitable<any>\n}\n\nconst logger = new Logger('console')\n\nexport class SocketHandle {\n  readonly id: string = Random.id()\n\n  constructor(readonly ctx: Context, public socket: AbstractWebSocket) {\n    socket.onmessage = this.receive.bind(this)\n    ctx.on('ready', () => {\n      ctx.console.handles[this.id] = this\n      this.refresh()\n    })\n  }\n\n  send(payload: any) {\n    this.socket.send(JSON.stringify(payload))\n  }\n\n  async receive(data: any) {\n    const { type, args, id } = JSON.parse(data.data.toString())\n    const listener = this.ctx.console.listeners[type]\n    if (!listener) {\n      logger.info('unknown message:', type, ...args)\n      return this.send({ type: 'response', body: { id, error: 'not implemented' } })\n    }\n\n    if (await this.ctx.serial('console/intercept', this, listener)) {\n      return this.send({ type: 'response', body: { id, error: 'unauthorized' } })\n    }\n\n    try {\n      const value = await listener.callback.call(this, ...args)\n      return this.send({ type: 'response', body: { id, value } })\n    } catch (e) {\n      logger.debug(e)\n      const error = coerce(e)\n      return this.send({ type: 'response', body: { id, error } })\n    }\n  }\n\n  refresh() {\n    DataService.keys.forEach(async (key) => {\n      const service = this.ctx[`console.${key}`] as DataService\n      if (!service) return\n      if (await this.ctx.serial('console/intercept', this, service.options)) {\n        return this.send({ type: 'data', body: { key, value: null } })\n      }\n\n      try {\n        const value = await service.get()\n        if (!value) return\n        this.send({ type: 'data', body: { key, value } })\n      } catch (error) {\n        this.ctx.logger('console').warn(error)\n      }\n    })\n  }\n}\n\nexport interface Entry {\n  dev: string\n  prod: string | string[]\n}\n\nexport class EntryProvider extends DataService<string[]> {\n  constructor(ctx: Context) {\n    super(ctx, 'entry', { immediate: true })\n  }\n\n  async get() {\n    return this.ctx.console.get()\n  }\n}\n\nexport abstract class Console extends Service {\n  readonly entries: Dict<string[]> = Object.create(null)\n  readonly listeners: Dict<Listener> = Object.create(null)\n  readonly handles: Dict<SocketHandle> = Object.create(null)\n\n  constructor(public ctx: Context) {\n    super(ctx, 'console', true)\n    ctx.plugin(EntryProvider)\n  }\n\n  async get() {\n    return Object.values(this.entries).flat()\n  }\n\n  abstract resolveEntry(entry: string | string[] | Entry): string | string[]\n\n  addEntry(entry: string | string[] | Entry) {\n    const caller = this.caller\n    const key = 'extension-' + Random.id()\n    this.entries[key] = makeArray(this.resolveEntry(entry))\n    this.entry.refresh()\n    caller?.on('dispose', () => {\n      delete this.entries[key]\n      this.entry?.refresh()\n    })\n  }\n\n  addListener<K extends keyof Events>(event: K, callback: Events[K], options?: DataService.Options) {\n    this.listeners[event] = { callback, ...options }\n  }\n\n  broadcast(type: string, body: any, options: DataService.Options = {}) {\n    const handles = Object.values(this.handles)\n    if (!handles.length) return\n    const data = JSON.stringify({ type, body })\n    Promise.all(Object.values(this.handles).map(async (handle) => {\n      if (await this.ctx.serial('console/intercept', handle, options)) return\n      handle.socket.send(data)\n    }))\n  }\n}\n\nexport interface Events {}\n\nexport namespace Console {\n  export interface Services {\n    entry: EntryProvider\n  }\n}\n\nexport default Console\n", "import { Context, Service } from 'koishi'\nimport Console from '.'\n\nexport namespace DataService {\n  export interface Options {\n    immediate?: boolean\n    authority?: number\n  }\n}\n\nexport abstract class DataService<T = never> extends Service {\n  static keys = new Set<string>()\n\n  static define(name: keyof Console.Services) {\n    this.keys.add(name)\n    if (Object.prototype.hasOwnProperty.call(Console.prototype, name)) return\n    const key = `console.${name}`\n    Object.defineProperty(Console.prototype, name, {\n      get(this: Console) {\n        return this.caller[key]\n      },\n      set(this: Console, value) {\n        this.caller[key] = value\n      },\n    })\n  }\n\n  public get(forced?: boolean): Promise<T> {\n    return null\n  }\n\n  constructor(protected ctx: Context, protected key: keyof Console.Services, public options: DataService.Options = {}) {\n    super(ctx, `console.${key}`, options.immediate)\n    DataService.define(key)\n  }\n\n  start() {\n    this.refresh()\n  }\n\n  async refresh() {\n    this.ctx.console?.broadcast('data', {\n      key: this.key,\n      value: await this.get(true),\n    }, this.options)\n  }\n\n  patch(value: T) {\n    this.ctx.console?.broadcast('patch', {\n      key: this.key,\n      value,\n    }, this.options)\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_koishi"]
}
