var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/external/console/packages/console/src/shared/index.ts
var shared_exports = {};
__export(shared_exports, {
  Console: () => Console,
  DataService: () => DataService,
  EntryProvider: () => EntryProvider,
  SocketHandle: () => SocketHandle,
  default: () => shared_default
});
module.exports = __toCommonJS(shared_exports);
var import_koishi2 = require("koishi");

// koishi/external/console/packages/console/src/shared/service.ts
var import_koishi = require("koishi");
var _DataService = class extends import_koishi.Service {
  constructor(ctx, key, options = {}) {
    super(ctx, `console.${key}`, options.immediate);
    this.ctx = ctx;
    this.key = key;
    this.options = options;
    _DataService.define(key);
  }
  static define(name) {
    this.keys.add(name);
    if (Object.prototype.hasOwnProperty.call(shared_default.prototype, name))
      return;
    const key = `console.${name}`;
    Object.defineProperty(shared_default.prototype, name, {
      get() {
        return this.caller[key];
      },
      set(value) {
        this.caller[key] = value;
      }
    });
  }
  get(forced) {
    return null;
  }
  start() {
    this.refresh();
  }
  async refresh() {
    var _a;
    (_a = this.ctx.console) == null ? void 0 : _a.broadcast("data", {
      key: this.key,
      value: await this.get(true)
    }, this.options);
  }
  patch(value) {
    var _a;
    (_a = this.ctx.console) == null ? void 0 : _a.broadcast("patch", {
      key: this.key,
      value
    }, this.options);
  }
};
var DataService = _DataService;
__name(DataService, "DataService");
DataService.keys = /* @__PURE__ */ new Set();

// koishi/external/console/packages/console/src/shared/index.ts
var logger = new import_koishi2.Logger("console");
var SocketHandle = class {
  constructor(ctx, socket) {
    this.ctx = ctx;
    this.socket = socket;
    this.id = import_koishi2.Random.id();
    socket.onmessage = this.receive.bind(this);
    ctx.on("ready", () => {
      ctx.console.handles[this.id] = this;
      this.refresh();
    });
  }
  send(payload) {
    this.socket.send(JSON.stringify(payload));
  }
  async receive(data) {
    const { type, args, id } = JSON.parse(data.data.toString());
    const listener = this.ctx.console.listeners[type];
    if (!listener) {
      logger.info("unknown message:", type, ...args);
      return this.send({ type: "response", body: { id, error: "not implemented" } });
    }
    if (await this.ctx.serial("console/intercept", this, listener)) {
      return this.send({ type: "response", body: { id, error: "unauthorized" } });
    }
    try {
      const value = await listener.callback.call(this, ...args);
      return this.send({ type: "response", body: { id, value } });
    } catch (e) {
      logger.debug(e);
      const error = (0, import_koishi2.coerce)(e);
      return this.send({ type: "response", body: { id, error } });
    }
  }
  refresh() {
    DataService.keys.forEach(async (key) => {
      const service = this.ctx[`console.${key}`];
      if (!service)
        return;
      if (await this.ctx.serial("console/intercept", this, service.options)) {
        return this.send({ type: "data", body: { key, value: null } });
      }
      try {
        const value = await service.get();
        if (!value)
          return;
        this.send({ type: "data", body: { key, value } });
      } catch (error) {
        this.ctx.logger("console").warn(error);
      }
    });
  }
};
__name(SocketHandle, "SocketHandle");
var EntryProvider = class extends DataService {
  constructor(ctx) {
    super(ctx, "entry", { immediate: true });
  }
  async get() {
    return this.ctx.console.get();
  }
};
__name(EntryProvider, "EntryProvider");
var Console = class extends import_koishi2.Service {
  constructor(ctx) {
    super(ctx, "console", true);
    this.ctx = ctx;
    this.entries = /* @__PURE__ */ Object.create(null);
    this.listeners = /* @__PURE__ */ Object.create(null);
    this.handles = /* @__PURE__ */ Object.create(null);
    ctx.plugin(EntryProvider);
  }
  async get() {
    return Object.values(this.entries).flat();
  }
  addEntry(entry) {
    const caller = this.caller;
    const key = "extension-" + import_koishi2.Random.id();
    this.entries[key] = (0, import_koishi2.makeArray)(this.resolveEntry(entry));
    this.entry.refresh();
    caller == null ? void 0 : caller.on("dispose", () => {
      var _a;
      delete this.entries[key];
      (_a = this.entry) == null ? void 0 : _a.refresh();
    });
  }
  addListener(event, callback, options) {
    this.listeners[event] = { callback, ...options };
  }
  broadcast(type, body, options = {}) {
    const handles = Object.values(this.handles);
    if (!handles.length)
      return;
    const data = JSON.stringify({ type, body });
    Promise.all(Object.values(this.handles).map(async (handle) => {
      if (await this.ctx.serial("console/intercept", handle, options))
        return;
      handle.socket.send(data);
    }));
  }
};
__name(Console, "Console");
var shared_default = Console;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Console,
  DataService,
  EntryProvider,
  SocketHandle
});
//# sourceMappingURL=index.js.map
