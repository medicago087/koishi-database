"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.conclude = void 0;
const semver_1 = require("semver");
const cosmokit_1 = require("cosmokit");
const p_map_1 = __importDefault(require("p-map"));
const stopWords = [
    'koishi',
    'plugin',
    'bot',
    'coolq',
    'cqhttp',
];
function conclude(meta) {
    var _a, _b;
    const manifest = {
        description: {
            en: meta.description,
        },
        locales: [],
        ...meta.koishi,
        service: {
            required: [],
            optional: [],
            implements: [],
            ...(_a = meta.koishi) === null || _a === void 0 ? void 0 : _a.service,
        },
    };
    for (const keyword of (_b = meta.keywords) !== null && _b !== void 0 ? _b : []) {
        if (keyword === 'market:hidden') {
            manifest.hidden = true;
        }
        else if (keyword.startsWith('required:')) {
            manifest.service.required.push(keyword.slice(9));
        }
        else if (keyword.startsWith('optional:')) {
            manifest.service.optional.push(keyword.slice(9));
        }
        else if (keyword.startsWith('impl:')) {
            manifest.service.implements.push(keyword.slice(5));
        }
        else if (keyword.startsWith('locale:')) {
            manifest.locales.push(keyword.slice(7));
        }
    }
    return manifest;
}
exports.conclude = conclude;
class Scanner {
    constructor(request) {
        this.request = request;
        (0, cosmokit_1.defineProperty)(this, 'progress', 0);
    }
    async search(offset, config) {
        const { step = 250, timeout = cosmokit_1.Time.second * 30 } = config;
        const result = await this.request(`/-/v1/search?text=koishi+plugin&size=${step}&from=${offset}`, { timeout });
        this.objects.push(...result.objects);
        return result.total;
    }
    async collect(config = {}) {
        const { step = 250, shared = [], concurrency = 5 } = config;
        this.objects = [];
        this.time = new Date().toUTCString();
        const total = await this.search(0, config);
        for (let offset = this.objects.length; offset < total; offset += step) {
            await this.search(offset, config);
        }
        this.objects = this.objects.filter((object) => {
            const { name } = object.package;
            const official = /^@koishijs\/plugin-.+/.test(name);
            const community = /(^|\/)koishi-plugin-.+/.test(name);
            return !object.ignored && (official || community);
        });
        this.shared = (await (0, p_map_1.default)(shared, async (name) => {
            const registry = await this.request(`/${name}`);
            const version = (0, semver_1.maxSatisfying)(Object.keys(registry.versions), '*');
            if (!version)
                return;
            return {
                ...(0, cosmokit_1.pick)(registry, ['name', 'description']),
                version,
                date: registry.time.modified,
                versions: (0, cosmokit_1.pick)(registry.versions, [version]),
            };
        }, { concurrency })).filter(isNonNullable);
        this.total = this.objects.length;
    }
    async process(object, range) {
        var _a, _b, _c;
        const { name } = object.package;
        const official = name.startsWith('@koishijs/plugin-');
        const registry = await this.request(`/${name}`);
        const versions = Object.values(registry.versions).filter((remote) => {
            const { peerDependencies = {}, deprecated } = remote;
            const declaredVersion = peerDependencies['koishi'];
            try {
                return !deprecated && declaredVersion && (0, semver_1.intersects)(range, declaredVersion);
            }
            catch { }
        }).sort((a, b) => (0, semver_1.compare)(b.version, a.version));
        if (!versions.length)
            return;
        const latest = registry.versions[versions[0].version];
        const manifest = conclude(latest);
        const shortname = name.replace(/(koishi-|^@koishijs\/)plugin-/, '');
        const keywords = ((_a = latest.keywords) !== null && _a !== void 0 ? _a : [])
            .map(keyword => keyword.toLowerCase())
            .filter((keyword) => {
            return !keyword.includes(':')
                && !shortname.includes(keyword)
                && !stopWords.some(word => keyword.includes(word));
        });
        const analyzed = {
            name,
            manifest,
            shortname,
            keywords,
            verified: (_b = object.verified) !== null && _b !== void 0 ? _b : official,
            insecure: object.package.insecure || manifest.insecure,
            versions: Object.fromEntries(versions.map(item => [item.version, item])),
            ...(0, cosmokit_1.pick)(object, ['score', 'downloads', 'installSize', 'publishSize']),
            ...(0, cosmokit_1.pick)(object.package, ['date', 'links', 'publisher', 'maintainers', 'portable']),
            ...(0, cosmokit_1.pick)(latest, ['version', 'description', 'license', 'author', 'contributors']),
        };
        (_c = analyzed.contributors) !== null && _c !== void 0 ? _c : (analyzed.contributors = analyzed.author ? [analyzed.author] : []);
        (0, cosmokit_1.defineProperty)(analyzed, 'object', object);
        return analyzed;
    }
    async analyze(config) {
        const { concurrency = 5, version, before, onSuccess, onFailure, onSkipped, after } = config;
        const result = await (0, p_map_1.default)(this.objects, async (object) => {
            if (object.ignored)
                return;
            before === null || before === void 0 ? void 0 : before(object);
            const { name } = object.package;
            try {
                const analyzed = await this.process(object, version);
                if (analyzed) {
                    await (onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(analyzed, object));
                    return analyzed;
                }
                else {
                    object.ignored = true;
                    await (onSkipped === null || onSkipped === void 0 ? void 0 : onSkipped(name));
                }
            }
            catch (error) {
                object.ignored = true;
                await (onFailure === null || onFailure === void 0 ? void 0 : onFailure(name, error));
            }
            finally {
                this.progress += 1;
                after === null || after === void 0 ? void 0 : after(object);
            }
        }, { concurrency });
        return result.filter(isNonNullable);
    }
}
exports.default = Scanner;
function isNonNullable(value) {
    return value !== null && value !== undefined;
}
