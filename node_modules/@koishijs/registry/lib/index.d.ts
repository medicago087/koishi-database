import { Awaitable, Dict } from 'cosmokit';
export interface User {
    name: string;
    email: string;
    url?: string;
    username?: string;
}
export interface BasePackage {
    name: string;
    version: string;
    description: string;
}
export type DependencyType = 'dependencies' | 'devDependencies' | 'peerDependencies' | 'optionalDependencies';
export interface PackageJson extends BasePackage, Partial<Record<DependencyType, Record<string, string>>> {
    main?: string;
    module?: string;
    bin?: string | Dict<string>;
    scripts?: Dict<string>;
    exports?: PackageJson.Exports;
    koishi?: Partial<Manifest>;
    keywords: string[];
    engines?: Dict<string>;
    os?: string[];
    cpu?: string[];
    overrides?: Dict<PackageJson.Overrides>;
    peerDependenciesMeta?: Dict<PackageJson.PeerMeta>;
}
export declare namespace PackageJson {
    type Exports = string | {
        [key: string]: Exports;
    };
    type Overrides = string | {
        [key: string]: Overrides;
    };
    interface PeerMeta {
        optional?: boolean;
    }
}
export interface IconSvg {
    type: 'svg';
    viewBox: string;
    pathData: string;
}
export interface Manifest {
    icon?: IconSvg;
    hidden?: boolean;
    preview?: boolean;
    insecure?: boolean;
    browser?: boolean;
    category?: string;
    public?: string[];
    description: Dict<string>;
    service: Manifest.Service;
    locales: string[];
}
export declare namespace Manifest {
    interface Service {
        required: string[];
        optional: string[];
        implements: string[];
    }
}
export interface RemotePackage extends PackageJson {
    deprecated?: string;
    author: User;
    contributors: User[];
    maintainers: User[];
    license: string;
    dist: RemotePackage.Dist;
}
export declare namespace RemotePackage {
    interface Dist {
        shasum: string;
        integrity: string;
        tarball: string;
        fileCount: number;
        unpackedSize: number;
    }
}
export interface Registry extends BasePackage {
    versions: Dict<RemotePackage>;
    time: {
        created: string;
        modified: string;
    };
    license: string;
    readme: string;
    readmeFilename: string;
}
export interface DatedPackage extends BasePackage {
    date: string;
    insecure?: boolean;
    portable?: boolean;
    object?: SearchObject;
}
export interface SearchPackage extends DatedPackage {
    links: Dict<string>;
    author: User;
    keywords: string[];
    publisher: User;
    maintainers: User[];
}
export interface Extension {
    score: Score;
    verified: boolean;
    publishSize?: number;
    installSize?: number;
    downloads?: {
        lastMonth: number;
    };
}
export interface SearchObject extends Extension {
    package: SearchPackage;
    searchScore: number;
    ignored?: boolean;
}
export interface Score {
    final: number;
    detail: Score.Detail;
}
export declare namespace Score {
    interface Detail {
        quality: number;
        popularity: number;
        maintenance: number;
    }
}
export interface SearchResult {
    total: number;
    time: string;
    objects: SearchObject[];
    shared?: SharedPackage[];
    version?: number;
}
export interface MarketResult {
    timestamp: number;
    objects: AnalyzedPackage[];
}
export interface SharedPackage extends DatedPackage {
    versions: Dict<Partial<RemotePackage>>;
}
export interface AnalyzedPackage extends SearchPackage, Extension {
    contributors: User[];
    shortname: string;
    license: string;
    manifest: Manifest;
    versions?: Dict<Partial<RemotePackage>>;
}
export interface CollectConfig {
    step?: number;
    timeout?: number;
    shared?: string[];
    concurrency?: number;
}
export interface AnalyzeConfig {
    version: string;
    concurrency?: number;
    before?(object: SearchObject): void;
    onSuccess?(item: AnalyzedPackage, object: SearchObject): Awaitable<void>;
    onFailure?(name: string, reason: any): Awaitable<void>;
    onSkipped?(name: string): Awaitable<void>;
    after?(object: SearchObject): void;
}
export interface ScanConfig extends CollectConfig, AnalyzeConfig {
    request<T>(url: string): Promise<T>;
}
export declare function conclude(meta: PackageJson): Manifest;
export interface RequestConfig {
    timeout?: number;
}
export default interface Scanner extends SearchResult {
    progress: number;
}
export default class Scanner {
    request: <T>(url: string, config?: RequestConfig) => Promise<T>;
    constructor(request: <T>(url: string, config?: RequestConfig) => Promise<T>);
    private search;
    collect(config?: CollectConfig): Promise<void>;
    process(object: SearchObject, range: string): Promise<AnalyzedPackage | undefined>;
    analyze(config: AnalyzeConfig): Promise<AnalyzedPackage[]>;
}
