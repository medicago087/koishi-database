var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// external/console/packages/logger/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_koishi = require("koishi");
var import_plugin_console = require("@koishijs/plugin-console");
var import_path = require("path");
var import_fs = require("fs");
var { open, rm } = import_fs.promises;
var LogProvider = class extends import_plugin_console.DataService {
  constructor(ctx, config = {}) {
    super(ctx, "logs", { authority: 4 });
    this.config = config;
    this.files = [];
    ctx.console.addEntry({
      dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
      prod: (0, import_path.resolve)(__dirname, "../dist")
    });
    this.ctx.on("ready", () => {
      this.prepareWriter();
      this.prepareLogger();
    }, true);
  }
  prepareWriter() {
    this.root = (0, import_path.resolve)(this.ctx.baseDir, this.config.root);
    (0, import_fs.mkdirSync)(this.root, { recursive: true });
    for (const filename of (0, import_fs.readdirSync)(this.root)) {
      if (!filename.endsWith(".log"))
        continue;
      this.files.push(import_koishi.Time.getDateNumber(new Date(filename.slice(0, -4)), 0));
    }
    this.createFile();
    this.ctx.on("dispose", () => {
      var _a;
      (_a = this.writer) == null ? void 0 : _a.close();
      this.writer = null;
    });
  }
  createFile() {
    this.date = import_koishi.Time.template("yyyy-MM-dd");
    this.writer = new FileWriter(`${this.root}/${this.date}.log`);
    const { maxAge } = this.config;
    if (!maxAge)
      return;
    const current = import_koishi.Time.getDateNumber(new Date(), 0);
    this.files = this.files.filter((date) => {
      if (date >= current - maxAge)
        return true;
      rm(`${this.root}/${import_koishi.Time.template("yyyy-MM-dd", import_koishi.Time.fromDateNumber(date, 0))}.log`);
    });
  }
  prepareLogger() {
    if (this.ctx.prologue) {
      for (const line of this.ctx.prologue) {
        this.printText(line);
      }
      this.ctx.root.prologue = null;
    }
    const target = {
      colors: 3,
      showTime: "yyyy-MM-dd hh:mm:ss",
      print: this.printText.bind(this)
    };
    import_koishi.Logger.targets.push(target);
    this.ctx.on("dispose", () => {
      (0, import_koishi.remove)(import_koishi.Logger.targets, target);
    });
  }
  printText(text) {
    if (!text.startsWith(this.date)) {
      this.writer.close();
      this.createFile();
    }
    this.writer.write(text);
    this.patch([text]);
  }
  async get() {
    var _a;
    return (_a = this.writer) == null ? void 0 : _a.read();
  }
};
__name(LogProvider, "LogProvider");
LogProvider.using = ["console"];
((LogProvider2) => {
  LogProvider2.Config = import_koishi.Schema.object({
    root: import_koishi.Schema.string().default("logs").description("存放输出日志的本地目录。"),
    maxAge: import_koishi.Schema.natural().default(30).description("日志文件保存的最大天数。")
  });
})(LogProvider || (LogProvider = {}));
var src_default = LogProvider;
var FileWriter = class {
  constructor(path) {
    this.content = [];
    this.task = open(path, "a+").then(async (handle) => {
      const text = await handle.readFile("utf-8");
      if (text)
        this.content = text.split(/\n(?=\S)/g);
      return handle;
    });
  }
  async read() {
    await this.task;
    return this.content;
  }
  async write(text) {
    const handle = await this.task;
    await handle.write(text + "\n");
    this.content.push(text);
  }
  async close() {
    const handle = await this.task;
    await handle.close();
  }
};
__name(FileWriter, "FileWriter");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map
