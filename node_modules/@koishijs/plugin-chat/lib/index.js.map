{
  "version": 3,
  "sources": ["../src/index.ts", "../src/receiver.ts"],
  "sourcesContent": ["import { Context, Logger, Quester, Schema, segment } from 'koishi'\nimport { resolve } from 'path'\nimport receiver, { Message, RefreshConfig } from './receiver'\nimport {} from '@koishijs/plugin-console'\nimport zh from './locales/zh.yml'\nimport internal from 'stream'\n\nexport * from './receiver'\n\ndeclare module 'koishi' {\n  interface Events {\n    'chat/receive'(message: Message, session: Session): void\n  }\n}\n\ninterface ChatPayload {\n  content: string\n  platform: string\n  channelId: string\n  guildId: string\n  selfId: string\n}\n\ndeclare module '@koishijs/plugin-console' {\n  interface ClientConfig extends ClientExtension {}\n\n  interface Events {\n    chat(message: ChatPayload): Promise<void>\n  }\n}\n\ninterface ClientExtension {\n  whitelist?: string[]\n  maxMessages?: number\n}\n\nconst builtinWhitelist = [\n  'https://gchat.qpic.cn/',\n  'https://c2cpicdw.qpic.cn/',\n]\n\nconst defaultOptions: Config = {\n  maxMessages: 1000,\n}\n\nexport const name = 'chat'\n\nexport const using = ['database'] as const\n\nexport interface Config extends ClientExtension {\n  refresh?: RefreshConfig\n  logLevel?: number\n}\n\nexport const Config: Schema<Config> = Schema.object({\n  whitelist: Schema.array(String),\n  maxMessages: Schema.natural(),\n  logLevel: Schema.natural().max(3),\n  refresh: RefreshConfig,\n})\n\nconst logger = new Logger('message')\n\nexport function apply(ctx: Context, options: Config = {}) {\n  ctx.i18n.define('zh', zh)\n\n  options = { ...defaultOptions, ...options }\n  ctx.plugin(receiver, options.refresh)\n\n  logger.level = options.logLevel || 3\n\n  ctx.on('chat/receive', async (message, session) => {\n    if (session.subtype !== 'private' && ctx.database) {\n      const channel = await ctx.database.getChannel(session.platform, session.channelId, ['assignee'])\n      if (!channel || channel.assignee !== session.selfId) return\n    }\n\n    // render template with fallback options\n    let templatePath = 'chat.log.' + (session.type === 'message' ? 'receive' : 'send')\n    if (!message.channelName) templatePath += '-fallback'\n    logger.debug(session.text(templatePath, message))\n  })\n\n  ctx.using(['console'], (ctx) => {\n    const { apiPath } = ctx.console.config\n    const whitelist = [...builtinWhitelist, ...options.whitelist || []]\n\n    ctx.console.global.whitelist = whitelist\n    ctx.console.global.maxMessages = options.maxMessages\n\n    ctx.console.addEntry({\n      dev: resolve(__dirname, '../client/index.ts'),\n      prod: resolve(__dirname, '../dist'),\n    })\n\n    ctx.console.addListener('chat', async ({ content, platform, channelId, guildId, selfId }) => {\n      if (ctx.assets) content = await ctx.assets.transform(content)\n      ctx.bots[`${platform}:${selfId}`]?.sendMessage(channelId, content, guildId)\n    }, { authority: 3 })\n\n    ctx.on('chat/receive', async (message) => {\n      message.content = segment.transform(message.content, {\n        image(data) {\n          if (whitelist.some(prefix => data.url.startsWith(prefix))) {\n            data.url = apiPath + '/proxy/' + encodeURIComponent(data.url)\n          }\n          return segment('image', data)\n        },\n      })\n      ctx.console.broadcast('chat', message, { authority: 3 })\n    })\n\n    const { get } = ctx.http\n    ctx.router.get(apiPath + '/proxy/:url', async (ctx) => {\n      if (!whitelist.some(prefix => ctx.params.url.startsWith(prefix))) {\n        return ctx.status = 403\n      }\n      try {\n        ctx.body = await get<internal.Readable>(ctx.params.url, { responseType: 'stream' })\n      } catch (error) {\n        if (!Quester.isAxiosError(error) || !error.response) throw error\n        ctx.status = error.response.status\n        ctx.body = error.response.data\n      }\n    })\n  })\n}\n", "import { Bot, Context, Dict, pick, Schema, segment, Session, Time } from 'koishi'\n\nexport interface RefreshConfig {\n  user?: number\n  guild?: number\n  channel?: number\n}\n\nexport const RefreshConfig: Schema<RefreshConfig> = Schema.object({\n  user: Schema.natural().role('ms').description('刷新用户数据的时间间隔。').default(Time.hour),\n  guild: Schema.natural().role('ms').description('刷新群组数据的时间间隔。').default(Time.hour),\n  channel: Schema.natural().role('ms').description('刷新频道数据的时间间隔。').default(Time.hour),\n}).description('刷新选项')\n\nconst textSegmentTypes = ['text', 'header', 'section']\n\nconst segmentTypes = [\n  'at.all',\n  'at.here',\n  'at.role',\n  'at.user',\n  'share',\n  'contact.friend',\n  'contact.guild',\n  'face',\n  'record',\n  'video',\n  'image',\n  'music',\n  'quote',\n  'forward',\n  'dice',\n  'rps',\n  'poke',\n  'json',\n  'xml',\n  'card',\n] as const\n\ntype SegmentType = typeof segmentTypes[number]\n\nfunction segmentToLocale(session: Session, type: SegmentType, params?: object): string {\n  if (segmentTypes.includes(type)) {\n    return session.text('chat.segmentTypes.' + type, params)\n  }\n\n  return session.text('chat.segmentTypes.unknown')\n}\n\nexport interface Message {\n  avatar?: string\n  content?: string\n  abstract?: string\n  username?: string\n  nickname?: string\n  platform?: string\n  messageId?: string\n  userId?: string\n  channelId?: string\n  guildId?: string\n  selfId?: string\n  selfName?: string\n  channelName?: string\n  guildName?: string\n  timestamp?: number\n  quote?: Message\n}\n\nasync function getUserName(bot: Bot, guildId: string, userId: string) {\n  try {\n    const { username } = await bot.getGuildMember(guildId, userId)\n    return username\n  } catch {\n    return userId\n  }\n}\n\nasync function getGroupName(bot: Bot, guildId: string) {\n  try {\n    const { guildName } = await bot.getGuild(guildId)\n    return guildName\n  } catch {\n    return guildId\n  }\n}\n\nasync function getChannelName(bot: Bot, channelId: string, guildId: string) {\n  try {\n    const { channelName } = await bot.getChannel(channelId, guildId)\n    return channelName\n  } catch {\n    return channelId\n  }\n}\n\nexport default function receiver(ctx: Context, config: RefreshConfig = {}) {\n  const {\n    user: refreshUserName = Time.hour,\n    guild: refreshGroupName = Time.hour,\n    channel: refreshChannelName = Time.hour,\n  } = config\n\n  const channelMap: Dict<[Promise<string>, number]> = {}\n  const groupMap: Dict<[Promise<string>, number]> = {}\n  const userMap: Dict<[Promise<string>, number]> = {}\n\n  ctx.on('ready', () => {\n    const timestamp = Date.now()\n    ctx.bots.forEach(bot => userMap[bot.sid] = [Promise.resolve(bot.username), timestamp])\n  })\n\n  async function prepareChannel(session: Session, params: Message, timestamp: number) {\n    const { cid, guildId, channelName } = session\n    if (channelName) {\n      channelMap[cid] = [Promise.resolve(channelName), timestamp]\n      return\n    }\n    if (!guildId) return\n    if (!channelMap[cid] || timestamp - channelMap[cid][1] >= refreshChannelName) {\n      channelMap[cid] = [getChannelName(session.bot, session.channelId, session.guildId), timestamp]\n    }\n    params.channelName = await channelMap[cid][0]\n  }\n\n  async function prepareGroup(session: Session, params: Message, timestamp: number) {\n    const { cid, gid, guildId, guildName } = session\n    if (guildName) {\n      groupMap[gid] = [Promise.resolve(guildName), timestamp]\n      return\n    }\n    if (!guildId || cid === gid) return\n    if (!groupMap[gid] || timestamp - groupMap[gid][1] >= refreshGroupName) {\n      groupMap[gid] = [getGroupName(session.bot, guildId), timestamp]\n    }\n    params.guildName = await groupMap[gid][0]\n  }\n\n  async function prepareAbstract(session: Session, params: Message, timestamp: number) {\n    const stl = segmentToLocale.bind(this, session)\n\n    const codes = segment.parse(params.content.split(/\\r?\\n/, 1)[0])\n    params.abstract = ''\n    for (const code of codes) {\n      if (textSegmentTypes.includes(code.type)) {\n        params.abstract += segment.unescape(code.data.content)\n      } else if (code.type === 'at') {\n        if (code.data.type === 'all') {\n          params.abstract += stl('at.all')\n        } else if (code.data.type === 'here') {\n          params.abstract += stl('at.here')\n        } else if (code.data.role) {\n          params.abstract += stl('at.role')\n        } else if (session.subtype === 'group') {\n          const id = `${session.platform}:${code.data.id}`\n          if (code.data.name) {\n            userMap[id] = [Promise.resolve(code.data.name), timestamp]\n          } else if (!userMap[id] || timestamp - userMap[id][1] >= refreshUserName) {\n            userMap[id] = [getUserName(session.bot, session.guildId, code.data.id), timestamp]\n          }\n          params.abstract += stl('at.user', [(code.data.name = await userMap[id][0])])\n        } else {\n          params.abstract += stl('at.user', [session.bot.username])\n        }\n      } else if (code.type === 'share' || code.type === 'location') {\n        params.abstract += stl('share', [code.data.title])\n      } else if (code.type === 'contact') {\n        params.abstract += stl(code.data.type === 'qq' ? 'contact.friend' : 'contact.guild', [code.data.id])\n      } else {\n        params.abstract += `[${stl(code.type as SegmentType)}]`\n      }\n    }\n  }\n\n  async function prepareContent(session: Session, message: Message, timestamp: number) {\n    const tasks = [prepareAbstract(session, message, timestamp)]\n    // eslint-disable-next-line no-cond-assign\n    if (message.quote = session.quote) {\n      tasks.push(prepareAbstract(session, message.quote, timestamp))\n    }\n    await Promise.all(tasks)\n  }\n\n  async function handleMessage(session: Session) {\n    const params: Message = pick(session, [\n      'content', 'timestamp', 'messageId', 'platform', 'selfId',\n      'channelId', 'channelName', 'guildId', 'guildName', 'userId',\n    ], true)\n    Object.assign(params, pick(session.author, ['username', 'nickname', 'avatar'], true))\n    if (session.type === 'message') {\n      userMap[session.uid] = [Promise.resolve(session.author.username), Date.now()]\n    }\n    const { cid, channelName } = session\n    const timestamp = Date.now()\n    if (channelName) {\n      session.channelName = channelName\n      channelMap[cid] = [Promise.resolve(channelName), timestamp]\n    }\n    params.selfName = session.bot.username\n    await Promise.all([prepareChannel, prepareGroup, prepareContent].map(cb => cb(session, params, timestamp)))\n    ctx.emit('chat/receive', params, session)\n  }\n\n  ctx.any().on('message', handleMessage)\n}\n"],
  "mappings": "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",
  "names": ["import_koishi", "ctx"]
}
