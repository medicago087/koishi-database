var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// external/console/packages/chat/src/index.ts
var src_exports = {};
__export(src_exports, {
  Config: () => Config,
  RefreshConfig: () => RefreshConfig,
  apply: () => apply,
  name: () => name,
  using: () => using
});
module.exports = __toCommonJS(src_exports);
var import_koishi2 = require("koishi");
var import_path = require("path");

// external/console/packages/chat/src/receiver.ts
var import_koishi = require("koishi");
var RefreshConfig = import_koishi.Schema.object({
  user: import_koishi.Schema.natural().role("ms").description("刷新用户数据的时间间隔。").default(import_koishi.Time.hour),
  guild: import_koishi.Schema.natural().role("ms").description("刷新群组数据的时间间隔。").default(import_koishi.Time.hour),
  channel: import_koishi.Schema.natural().role("ms").description("刷新频道数据的时间间隔。").default(import_koishi.Time.hour)
}).description("刷新选项");
var textSegmentTypes = ["text", "header", "section"];
var segmentTypes = [
  "at.all",
  "at.here",
  "at.role",
  "at.user",
  "share",
  "contact.friend",
  "contact.guild",
  "face",
  "record",
  "video",
  "image",
  "music",
  "quote",
  "forward",
  "dice",
  "rps",
  "poke",
  "json",
  "xml",
  "card"
];
function segmentToLocale(session, type, params) {
  if (segmentTypes.includes(type)) {
    return session.text("chat.segmentTypes." + type, params);
  }
  return session.text("chat.segmentTypes.unknown");
}
__name(segmentToLocale, "segmentToLocale");
async function getUserName(bot, guildId, userId) {
  try {
    const { username } = await bot.getGuildMember(guildId, userId);
    return username;
  } catch {
    return userId;
  }
}
__name(getUserName, "getUserName");
async function getGroupName(bot, guildId) {
  try {
    const { guildName } = await bot.getGuild(guildId);
    return guildName;
  } catch {
    return guildId;
  }
}
__name(getGroupName, "getGroupName");
async function getChannelName(bot, channelId, guildId) {
  try {
    const { channelName } = await bot.getChannel(channelId, guildId);
    return channelName;
  } catch {
    return channelId;
  }
}
__name(getChannelName, "getChannelName");
function receiver(ctx, config = {}) {
  const {
    user: refreshUserName = import_koishi.Time.hour,
    guild: refreshGroupName = import_koishi.Time.hour,
    channel: refreshChannelName = import_koishi.Time.hour
  } = config;
  const channelMap = {};
  const groupMap = {};
  const userMap = {};
  ctx.on("ready", () => {
    const timestamp = Date.now();
    ctx.bots.forEach((bot) => userMap[bot.sid] = [Promise.resolve(bot.username), timestamp]);
  });
  async function prepareChannel(session, params, timestamp) {
    const { cid, guildId, channelName } = session;
    if (channelName) {
      channelMap[cid] = [Promise.resolve(channelName), timestamp];
      return;
    }
    if (!guildId)
      return;
    if (!channelMap[cid] || timestamp - channelMap[cid][1] >= refreshChannelName) {
      channelMap[cid] = [getChannelName(session.bot, session.channelId, session.guildId), timestamp];
    }
    params.channelName = await channelMap[cid][0];
  }
  __name(prepareChannel, "prepareChannel");
  async function prepareGroup(session, params, timestamp) {
    const { cid, gid, guildId, guildName } = session;
    if (guildName) {
      groupMap[gid] = [Promise.resolve(guildName), timestamp];
      return;
    }
    if (!guildId || cid === gid)
      return;
    if (!groupMap[gid] || timestamp - groupMap[gid][1] >= refreshGroupName) {
      groupMap[gid] = [getGroupName(session.bot, guildId), timestamp];
    }
    params.guildName = await groupMap[gid][0];
  }
  __name(prepareGroup, "prepareGroup");
  async function prepareAbstract(session, params, timestamp) {
    const stl = segmentToLocale.bind(this, session);
    const codes = import_koishi.segment.parse(params.content.split(/\r?\n/, 1)[0]);
    params.abstract = "";
    for (const code of codes) {
      if (textSegmentTypes.includes(code.type)) {
        params.abstract += import_koishi.segment.unescape(code.data.content);
      } else if (code.type === "at") {
        if (code.data.type === "all") {
          params.abstract += stl("at.all");
        } else if (code.data.type === "here") {
          params.abstract += stl("at.here");
        } else if (code.data.role) {
          params.abstract += stl("at.role");
        } else if (session.subtype === "group") {
          const id = `${session.platform}:${code.data.id}`;
          if (code.data.name) {
            userMap[id] = [Promise.resolve(code.data.name), timestamp];
          } else if (!userMap[id] || timestamp - userMap[id][1] >= refreshUserName) {
            userMap[id] = [getUserName(session.bot, session.guildId, code.data.id), timestamp];
          }
          params.abstract += stl("at.user", [code.data.name = await userMap[id][0]]);
        } else {
          params.abstract += stl("at.user", [session.bot.username]);
        }
      } else if (code.type === "share" || code.type === "location") {
        params.abstract += stl("share", [code.data.title]);
      } else if (code.type === "contact") {
        params.abstract += stl(code.data.type === "qq" ? "contact.friend" : "contact.guild", [code.data.id]);
      } else {
        params.abstract += `[${stl(code.type)}]`;
      }
    }
  }
  __name(prepareAbstract, "prepareAbstract");
  async function prepareContent(session, message, timestamp) {
    const tasks = [prepareAbstract(session, message, timestamp)];
    if (message.quote = session.quote) {
      tasks.push(prepareAbstract(session, message.quote, timestamp));
    }
    await Promise.all(tasks);
  }
  __name(prepareContent, "prepareContent");
  async function handleMessage(session) {
    const params = (0, import_koishi.pick)(session, [
      "content",
      "timestamp",
      "messageId",
      "platform",
      "selfId",
      "channelId",
      "channelName",
      "guildId",
      "guildName",
      "userId"
    ], true);
    Object.assign(params, (0, import_koishi.pick)(session.author, ["username", "nickname", "avatar"], true));
    if (session.type === "message") {
      userMap[session.uid] = [Promise.resolve(session.author.username), Date.now()];
    }
    const { cid, channelName } = session;
    const timestamp = Date.now();
    if (channelName) {
      session.channelName = channelName;
      channelMap[cid] = [Promise.resolve(channelName), timestamp];
    }
    params.selfName = session.bot.username;
    await Promise.all([prepareChannel, prepareGroup, prepareContent].map((cb) => cb(session, params, timestamp)));
    ctx.emit("chat/receive", params, session);
  }
  __name(handleMessage, "handleMessage");
  ctx.any().on("message", handleMessage);
}
__name(receiver, "receiver");

// external/console/packages/chat/src/locales/zh.yml
var zh_default = { chat: { log: { send: "[{ channelName }] { abstract }", "send-fallback": "[私聊] { abstract }", receive: "[{ channelName }] { username }: { abstract }", "receive-fallback": "[私聊] { username }: { abstract }" }, segmentTypes: { at: { all: "@全体成员", here: "@在线成员", role: "@角色组", user: "@{ name }" }, share: "[分享:{ title }]", contact: { friend: "[推荐好友:{ name }]", guild: "[推荐群:{ name }]" }, face: "表情", record: "语音", video: "视频", image: "图片", music: "音乐", quote: "引用", forward: "合并转发", dice: "掷骰子", rps: "猜拳", poke: "戳一戳", json: "JSON", xml: "XML", card: "卡片消息", unknown: "未知" } } };

// external/console/packages/chat/src/index.ts
var builtinWhitelist = [
  "https://gchat.qpic.cn/",
  "https://c2cpicdw.qpic.cn/"
];
var defaultOptions = {
  maxMessages: 1e3
};
var name = "chat";
var using = ["database"];
var Config = import_koishi2.Schema.object({
  whitelist: import_koishi2.Schema.array(String),
  maxMessages: import_koishi2.Schema.natural(),
  logLevel: import_koishi2.Schema.natural().max(3),
  refresh: RefreshConfig
});
var logger = new import_koishi2.Logger("message");
function apply(ctx, options = {}) {
  ctx.i18n.define("zh", zh_default);
  options = { ...defaultOptions, ...options };
  ctx.plugin(receiver, options.refresh);
  logger.level = options.logLevel || 3;
  ctx.on("chat/receive", async (message, session) => {
    if (session.subtype !== "private" && ctx.database) {
      const channel = await ctx.database.getChannel(session.platform, session.channelId, ["assignee"]);
      if (!channel || channel.assignee !== session.selfId)
        return;
    }
    let templatePath = "chat.log." + (session.type === "message" ? "receive" : "send");
    if (!message.channelName)
      templatePath += "-fallback";
    logger.debug(session.text(templatePath, message));
  });
  ctx.using(["console"], (ctx2) => {
    const { apiPath } = ctx2.console.config;
    const whitelist = [...builtinWhitelist, ...options.whitelist || []];
    ctx2.console.global.whitelist = whitelist;
    ctx2.console.global.maxMessages = options.maxMessages;
    ctx2.console.addEntry({
      dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
      prod: (0, import_path.resolve)(__dirname, "../dist")
    });
    ctx2.console.addListener("chat", async ({ content, platform, channelId, guildId, selfId }) => {
      var _a;
      if (ctx2.assets)
        content = await ctx2.assets.transform(content);
      (_a = ctx2.bots[`${platform}:${selfId}`]) == null ? void 0 : _a.sendMessage(channelId, content, guildId);
    }, { authority: 3 });
    ctx2.on("chat/receive", async (message) => {
      message.content = import_koishi2.segment.transform(message.content, {
        image(data) {
          if (whitelist.some((prefix) => data.url.startsWith(prefix))) {
            data.url = apiPath + "/proxy/" + encodeURIComponent(data.url);
          }
          return (0, import_koishi2.segment)("image", data);
        }
      });
      ctx2.console.broadcast("chat", message, { authority: 3 });
    });
    const { get } = ctx2.http;
    ctx2.router.get(apiPath + "/proxy/:url", async (ctx3) => {
      if (!whitelist.some((prefix) => ctx3.params.url.startsWith(prefix))) {
        return ctx3.status = 403;
      }
      try {
        ctx3.body = await get(ctx3.params.url, { responseType: "stream" });
      } catch (error) {
        if (!import_koishi2.Quester.isAxiosError(error) || !error.response)
          throw error;
        ctx3.status = error.response.status;
        ctx3.body = error.response.data;
      }
    });
  });
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  RefreshConfig,
  apply,
  name,
  using
});
//# sourceMappingURL=index.js.map
