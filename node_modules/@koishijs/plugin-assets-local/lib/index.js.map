{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import { Assets, Context, sanitize, Schema, trimSlash } from 'koishi'\nimport { createReadStream, promises as fs } from 'fs'\nimport { basename, resolve } from 'path'\nimport { createHmac } from 'crypto'\nimport { stream as fileTypeStream } from 'file-type'\n\nclass LocalAssets extends Assets {\n  private _promise: Promise<void>\n  private _stats: Assets.Stats = {\n    assetCount: 0,\n    assetSize: 0,\n  }\n\n  private path: string\n  private root: string\n  private selfUrl: string\n\n  constructor(ctx: Context, private config: LocalAssets.Config) {\n    super(ctx)\n\n    this.path = sanitize(config.path || '/assets')\n    if (config.root) {\n      this.root = resolve(ctx.app.baseDir, config.root)\n    } else {\n      this.root = resolve(__dirname, '../public')\n    }\n\n    if (config.selfUrl) {\n      this.selfUrl = trimSlash(config.selfUrl)\n    } else if (!(this.selfUrl = ctx.root.config.selfUrl)) {\n      throw new Error(`missing configuration \"selfUrl\"`)\n    }\n\n    ctx.router.get(this.path, async (ctx) => {\n      return ctx.body = await this.stats()\n    })\n\n    ctx.router.get(this.path + '/:name', async (ctx) => {\n      const filename = resolve(this.root, basename(ctx.params.name))\n      const stream = await fileTypeStream(createReadStream(filename))\n      ctx.type = stream.fileType?.mime\n      return ctx.body = stream\n    })\n\n    ctx.router.post(this.path, async (ctx) => {\n      const { salt, sign, url, file } = ctx.query\n      if (Array.isArray(file) || Array.isArray(url)) {\n        return ctx.status = 400\n      }\n\n      if (config.secret) {\n        if (!salt || !sign) return ctx.status = 400\n        const hash = createHmac('sha1', config.secret).update(file + salt).digest('hex')\n        if (hash !== sign) return ctx.status = 403\n      }\n\n      await this.upload(url, file)\n      return ctx.status = 200\n    })\n\n    this._promise = this.init()\n  }\n\n  start() {}\n\n  stop() {}\n\n  async init() {\n    await fs.mkdir(this.root, { recursive: true })\n    const filenames = await fs.readdir(this.root)\n    this._stats.assetCount = filenames.length\n    await Promise.all(filenames.map(async (file) => {\n      const { size } = await fs.stat(resolve(this.root, file))\n      this._stats.assetSize += size\n    }))\n  }\n\n  async write(buffer: Buffer, filename: string) {\n    await fs.writeFile(filename, buffer)\n    this._stats.assetCount += 1\n    this._stats.assetSize += buffer.byteLength\n  }\n\n  async upload(url: string, file: string) {\n    if (url.startsWith(this.selfUrl)) return url\n    await this._promise\n    const { selfUrl, path, root } = this\n    const { buffer, filename } = await this.analyze(url, file)\n    const savePath = resolve(root, filename)\n    await this.write(buffer, savePath)\n    return `${selfUrl}${path}/${filename}`\n  }\n\n  async stats() {\n    await this._promise\n    return this._stats\n  }\n}\n\nnamespace LocalAssets {\n  export interface Config {\n    path?: string\n    root?: string\n    secret?: string\n    selfUrl?: string\n  }\n\n  export const Config: Schema<Config> = Schema.object({\n    root: Schema.string().description('本地存储资源文件的绝对路径。'),\n    path: Schema.string().default('/files').description('静态图片暴露在服务器的路径。'),\n    selfUrl: Schema.string().role('link').description('Koishi 服务暴露在公网的地址。缺省时将使用全局配置。'),\n    secret: Schema.string().description('用于验证上传者的密钥，配合 assets-remote 使用。').role('secret'),\n  })\n}\n\nexport default LocalAssets\n"],
  "mappings": "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",
  "names": ["ctx", "fileTypeStream", "fs", "LocalAssets"]
}
