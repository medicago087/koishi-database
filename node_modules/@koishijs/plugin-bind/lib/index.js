var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// plugins/a11y/bind/src/locales/zh.yml
var require_zh = __commonJS({
  "plugins/a11y/bind/src/locales/zh.yml"(exports, module2) {
    module2.exports = { "commands.bind": { description: "绑定到账号", messages: { "generated-1": "bind 指令可用于在多个平台间绑定用户数据。绑定过程中，源平台的用户数据将完全保留，而目标平台的用户数据将被源平台的数据所覆盖。\n请确认当前平台是你的目标平台，并在 5 分钟内使用你的账号在源平台内向机器人发送以下文本：\n{0}\n注意：每个账号只能绑定到每个平台一次，此操作将会抹去你当前平台上的数据，请谨慎操作！", "generated-2": "令牌核验成功！下面将进行第二步操作。\n请在 5 分钟内使用你的账号在目标平台内向机器人发送以下文本：\n{0}\n注意：当前平台是你的源平台，这里的用户数据将完全保留，而目标平台的用户数据将被覆盖，请谨慎操作！", failed: "账号绑定失败：你已经绑定过该平台。", success: "账号绑定成功！" } } };
  }
});

// plugins/a11y/bind/src/locales/en.yml
var require_en = __commonJS({
  "plugins/a11y/bind/src/locales/en.yml"(exports, module2) {
    module2.exports = { "commands.bind": { description: "Account binding", messages: { "generated-1": "Bind command is meant to bind user accounts across multiple platforms.\nIn this process, the data from the source platform will be preserved, while the data from the target platform will be overwritten.\nMake sure that you are on the target platform, and send the following text to any robot on the source platform within 5 minutes:\n{0}\nNote: Each account can only be bound to each platform once, and this operation will erase the data on your current platform, please operate with caution!", "generated-2": "Token verification succeeded! Let's move on to the second step.\nPlease send the following text to any robot on the target platform within the target platform using your account within 5 minutes:\n{0}\nNote: The current platform is your source platform, your data here will be completely preserved, and the data of the target platform will be overwritten, please operate with caution!", failed: "Failed: You have already bound this platform.", success: "Your account has been bound successfully!" } } };
  }
});

// plugins/a11y/bind/src/index.ts
var src_exports = {};
__export(src_exports, {
  Config: () => Config,
  apply: () => apply,
  name: () => name,
  using: () => using
});
module.exports = __toCommonJS(src_exports);
var import_koishi = require("koishi");
var name = "bind";
var using = ["database"];
var Config = import_koishi.Schema.object({
  generateToken: import_koishi.Schema.function().hidden()
});
function apply(ctx, config = {}) {
  ctx.i18n.define("zh", require_zh());
  ctx.i18n.define("en", require_en());
  const tokens = {};
  const { tokenPrefix: prefix = "koishi/" } = config;
  const { generateToken = /* @__PURE__ */ __name(() => `${prefix}` + import_koishi.Random.id(6, 10), "generateToken") } = config;
  function generate(session, pending) {
    const token = generateToken();
    tokens[token] = [session.platform, session.userId, pending];
    setTimeout(() => delete tokens[token], 5 * import_koishi.Time.minute);
    return token;
  }
  __name(generate, "generate");
  async function bind(user, platform, userId) {
    await ctx.database.remove("user", { [platform]: [userId] });
    user[platform] = userId;
    await user.$update();
  }
  __name(bind, "bind");
  ctx.command("bind", { authority: 0 }).action(({ session }) => {
    const token = generate(session, +(session.subtype === "group"));
    return session.text(".generated-1", [token]);
  });
  ctx.middleware(async (session, next) => {
    const data = tokens[session.content];
    if (!data)
      return next();
    if (data[2] < 0) {
      const sess = session.bot.session(session);
      sess.platform = data[0];
      sess.userId = data[1];
      const user = await sess.observeUser([session.platform]);
      delete tokens[session.content];
      await bind(user, session.platform, session.userId);
      return session.text("commands.bind.messages.success");
    } else {
      const user = await session.observeUser(["authority", data[0]]);
      if (!user.authority)
        return session.text("internal.low-authority");
      if (user[data[0]])
        return session.text("commands.bind.messages.failed");
      delete tokens[session.content];
      if (data[2]) {
        const token = generate(session, -1);
        return session.text("commands.bind.messages.generated-2", [token]);
      } else {
        await bind(user, data[0], data[1]);
        return session.text("commands.bind.messages.success");
      }
    }
  }, true);
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  apply,
  name,
  using
});
//# sourceMappingURL=index.js.map
