var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// koishi/external/console/packages/commands/src/index.ts
var src_exports = {};
__export(src_exports, {
  Override: () => Override,
  apply: () => apply,
  name: () => name,
  schema: () => schema
});
module.exports = __toCommonJS(src_exports);
var import_koishi = require("koishi");

// koishi/external/console/packages/commands/src/service.ts
var import_plugin_console = require("@koishijs/plugin-console");
var import_throttle_debounce = require("throttle-debounce");
var import_path = require("path");
function traverse(command) {
  return {
    name: command.name,
    aliases: command._aliases,
    children: command.children.map(traverse),
    ...command.config
  };
}
__name(traverse, "traverse");
var CommandProvider = class extends import_plugin_console.DataService {
  constructor(ctx) {
    super(ctx, "commands", { authority: 4 });
    this.update = (0, import_throttle_debounce.debounce)(0, () => this.refresh());
    ctx.on("command-added", this.update);
    ctx.on("command-removed", this.update);
    ctx.on("dispose", this.update.cancel);
    ctx.console.addEntry({
      dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
      prod: (0, import_path.resolve)(__dirname, "../dist")
    });
  }
  async get(forced = false) {
    if (this.cached && !forced)
      return this.cached;
    this.cached = this.ctx.$commander._commandList.filter((cmd) => !cmd.parent).map(traverse);
    return this.cached;
  }
};
__name(CommandProvider, "CommandProvider");
CommandProvider.using = ["console"];

// koishi/external/console/packages/commands/src/index.ts
var Override = import_koishi.Schema.object({
  name: import_koishi.Schema.string(),
  alias: import_koishi.Schema.array(String),
  create: import_koishi.Schema.boolean()
});
var Config = import_koishi.Schema.union([
  import_koishi.Schema.intersect([Override, import_koishi.Command.Config]),
  import_koishi.Schema.transform(String, (name2) => ({ name: name2, alias: [] }))
]);
var schema = import_koishi.Schema.dict(Config);
var name = "commands";
function apply(ctx, config) {
  const snapshots = {};
  function teleport(command, parent = null) {
    if (command.parent === parent)
      return;
    if (command.parent) {
      (0, import_koishi.remove)(command.parent.children, command);
    }
    command.parent = parent;
    parent == null ? void 0 : parent.children.push(command);
  }
  __name(teleport, "teleport");
  function locate(command, name2) {
    const capture = name2.match(/.*(?=[./])/);
    if (!capture)
      return name2;
    const parent = ctx.$commander.resolve(capture[0]);
    if (capture[0] && !parent) {
      ctx.logger("command").warn("cannot find parent command", capture[0]);
      return;
    }
    teleport(command, parent);
    const rest = name2.slice(capture[0].length);
    return rest[0] === "." ? name2 : rest.slice(1);
  }
  __name(locate, "locate");
  function patch(target) {
    const command = Object.create(target);
    command._disposables = ctx.state.disposables;
    return command;
  }
  __name(patch, "patch");
  function accept(target, config2) {
    const { name: name2, create, options = {}, ...rest } = config2;
    const command = create ? target : patch(target);
    const snapshot = (0, import_koishi.pick)(target, ["name", "parent"]);
    for (const key in rest) {
      snapshot[key] = command.config[key];
      command.config[key] = rest[key];
    }
    for (const key in options) {
      const option = command._options[key];
      if (!option)
        continue;
      Object.assign(option, options[key]);
    }
    if (name2) {
      const _name = locate(target, name2);
      if (!_name)
        return;
      command.displayName = _name;
    }
    for (const name3 of config2.alias) {
      command.alias(name3);
    }
    snapshots[target.name] = snapshot;
  }
  __name(accept, "accept");
  for (const key in config) {
    const command = ctx.$commander.resolve(key);
    if (command) {
      accept(command, config[key]);
    } else if (config[key].create) {
      const command2 = ctx.command(key);
      accept(command2, config[key]);
    }
  }
  ctx.on("command-added", (cmd) => {
    for (const key in config) {
      if (cmd === ctx.$commander.resolve(key)) {
        return accept(cmd, config[key]);
      }
    }
  });
  ctx.on("command-removed", (cmd) => {
    delete snapshots[cmd.name];
  });
  ctx.on("dispose", () => {
    for (const key in snapshots) {
      const { name: name2, parent, ...options } = snapshots[key];
      const cmd = ctx.$commander.resolve(name2);
      Object.assign(cmd.config, options);
      teleport(cmd, parent);
    }
  }, true);
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Override,
  apply,
  name,
  schema
});
//# sourceMappingURL=index.js.map
