import { MapPluginToConfig } from './mapping-base';
import { ClassType, PluginRegistrar } from 'cordis-decorators';
import PluginClass = PluginRegistrar.PluginClass;
import { Context, Dict } from 'koishi';
declare type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
export declare function MergePlugin<Ctx extends Context, M extends Dict<PluginClass<Ctx>>, OuterConfig>(dict: M, outerConfig?: ClassType<OuterConfig>): new (ctx: import("cordis").Context<any>, config: import("cordis-decorators").PartialDeep<OuterConfig> & UnionToIntersection<MapPluginToConfig<Ctx, M>[keyof M]>) => {
    _getDict(): M;
    _getPluginConfig(key: keyof M): any;
    _instanceMap: Map<string, PluginRegistrar.PluginClass<Ctx, any, any>>;
    getInstance<K extends keyof M>(key: K): M[K];
    _registerInstances(): void;
    _onThingsDispose(): void;
    ctx: Ctx;
    config: UnionToIntersection<MapPluginToConfig<Ctx, M>[keyof M]>;
} & {
    config: OuterConfig;
};
export {};
