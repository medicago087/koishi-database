"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaRef = exports.SchemaProperty = void 0;
const def_1 = require("../def");
const metadata_1 = require("../metadata/metadata");
const transformer_1 = require("../utility/transformer");
require("reflect-metadata");
function SchemaProperty(options = {}) {
    return (obj, key) => {
        const nativeType = Reflect.getMetadata('design:type', obj, key);
        // const nativeTypeString = getStringFromNativeType(nativeType);
        if (!options.type) {
            if (nativeType !== Array) {
                options.type = nativeType;
            }
            else {
                options.type = 'any';
            }
        }
        const typeInSchema = options.type?.type;
        if (nativeType === Array &&
            options.array !== false &&
            typeInSchema !== 'array' &&
            typeInSchema !== 'tuple') {
            options.array = true;
        }
        if (options.type &&
            typeof options.type !== 'string' &&
            (options.type[def_1.GeneratedSym] || options.type[def_1.RefSym])) {
            const cl = options.type;
            let dec;
            if (options.dict) {
                dec = (0, transformer_1.SetTransformer)((value) => (0, transformer_1.transformDict)(cl, value, options.array));
            }
            else if (options.array) {
                dec = (0, transformer_1.SetTransformer)((value) => (0, transformer_1.transformArray)(cl, value));
            }
            else {
                dec = (0, transformer_1.SetTransformer)((value) => (0, transformer_1.transformSingle)(cl, value));
            }
            dec(obj, key);
        }
        metadata_1.Metadata.set('SchemaMeta', options, 'SchemaMetaKey')(obj, key);
    };
}
exports.SchemaProperty = SchemaProperty;
function SchemaRef(factory) {
    return {
        [def_1.RefSym]: true,
        factory,
    };
}
exports.SchemaRef = SchemaRef;
//# sourceMappingURL=define-property.js.map