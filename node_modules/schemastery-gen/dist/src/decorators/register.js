"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegisterSchema = exports.SchemaClass = exports.schemaFromClass = exports.resolveSchemaType = void 0;
const def_1 = require("../def");
const schemastery_1 = __importDefault(require("schemastery"));
const reflector_1 = require("../metadata/reflector");
const metadata_1 = require("../metadata/metadata");
const kschema_1 = require("../utility/kschema");
const utility_1 = require("../utility/utility");
function resolveSchemaType(schemaType) {
    if (schemaType && schemaType[def_1.RefSym]) {
        return schemaType;
    }
    // eslint-disable-next-line @typescript-eslint/ban-types
    switch (schemaType) {
        case 'any':
            return schemastery_1.default.any();
        case 'never':
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            return schemastery_1.default.never();
        case 'string':
        case String:
            return schemastery_1.default.string();
        case 'number':
        case Number:
            return schemastery_1.default.number();
        case 'boolean':
        case Boolean:
            return schemastery_1.default.boolean();
        case 'object':
            return schemastery_1.default.object({}).default({});
        case Function:
            return schemastery_1.default.function();
        case Date:
            return schemastery_1.default.date();
        default:
            return schemastery_1.default.from(schemaType);
    }
}
exports.resolveSchemaType = resolveSchemaType;
function applyOptionsToSchema(schema, options) {
    Object.assign(schema.meta, {
        ...options,
        type: undefined,
        dict: undefined,
        array: undefined,
    });
}
function getPropertySchemaFromOptions(options) {
    const _schema = resolveSchemaType(options.type);
    if (_schema[def_1.RefSym]) {
        return _schema;
    }
    let schema = _schema;
    if (options.dict) {
        const skeySchema = (options.dict === true
            ? schemastery_1.default.string()
            : schemastery_1.default.from(options.dict));
        schema = schemastery_1.default.dict(schema, skeySchema).default({});
    }
    if (options.array) {
        schema = schemastery_1.default.array(schema).default([]);
    }
    applyOptionsToSchema(schema, options);
    return schema;
}
function resolveSchemaReference(ref) {
    const value = ref.factory();
    /*if (value[kSchema]) {
      return value;
    }
    if (typeof value === 'function' && !value[kSchema]) {
      return SchemaClass(value as { new (...args: any[]): any });
    }*/
    return value;
}
function resolvePropertySchemaFromOptions(options) {
    const schema = getPropertySchemaFromOptions(options);
    if (schema[def_1.RefSym]) {
        return resolvePropertySchemaFromOptions({
            ...options,
            type: resolveSchemaReference(schema),
        });
    }
    return schema;
}
function tempDefGet(obj, key, getter) {
    Object.defineProperty(obj, key, {
        get: getter,
        set: (value) => {
            Object.defineProperty(obj, key, {
                enumerable: true,
                configurable: true,
                writable: true,
                value,
            });
        },
        enumerable: true,
        configurable: true,
    });
}
function schemasFromDict(dict) {
    const schemaDict = (0, utility_1.mapValues)(dict, (opt) => getPropertySchemaFromOptions(opt));
    const schema = schemastery_1.default.object({});
    for (const _key of Object.keys(schemaDict)) {
        const key = _key;
        if (schemaDict[key][def_1.RefSym]) {
            const schemaOptions = dict[key];
            tempDefGet(schema.dict, _key, () => resolvePropertySchemaFromOptions(schemaOptions));
        }
        else {
            schema.dict[_key] = schemaDict[key];
        }
    }
    return schema;
}
function schemaOptionsFromClass(cl) {
    const keys = reflector_1.reflector.getArray('SchemaMetaKey', cl);
    if (!keys) {
        return null;
    }
    const result = {};
    for (const key of keys) {
        const option = reflector_1.reflector.get('SchemaMeta', cl, key);
        if (!option) {
            continue;
        }
        result[key] = option;
    }
    return result;
}
function schemaFromClass(cl) {
    let schema;
    const optionsDict = schemaOptionsFromClass(cl);
    if (!optionsDict) {
        schema = schemastery_1.default.object({});
    }
    else {
        schema = schemasFromDict(optionsDict);
    }
    const classOptions = reflector_1.reflector.get('SchemaClassOptions', cl);
    if (classOptions) {
        applyOptionsToSchema(schema, classOptions);
    }
    return schema;
}
exports.schemaFromClass = schemaFromClass;
const schemaFields = [
    'type',
    'sKey',
    'inner',
    'list',
    'dict',
    'callback',
    'value',
    'meta',
    'uid',
    'refs',
];
const schemaFunctions = [
    // 'toJSON',
    'required',
    'hidden',
    'role',
    'link',
    'default',
    'comment',
    'description',
    'max',
    'min',
    'step',
    'set',
    'push',
];
function applySchemaForClass(schema, originalClass, instance, originalObject) {
    const newRawObject = new schema(originalObject);
    for (const key in schema.dict) {
        const transformer = reflector_1.reflector.get('Transformer', originalClass, key);
        if (transformer) {
            newRawObject[key] = transformer(newRawObject[key]);
        }
    }
    for (const key in newRawObject) {
        instance[key] = newRawObject[key];
    }
    return instance;
}
function SchemaClass(originalClass) {
    if (originalClass[kschema_1.kSchema]) {
        return originalClass;
    }
    const schema = schemaFromClass(originalClass);
    const newClass = function (...args) {
        const instance = new originalClass(...args);
        const originalObject = args[0];
        return applySchemaForClass(schema, originalClass, instance, originalObject);
    };
    newClass[def_1.GeneratedSym] = schema;
    newClass[def_1.OriginalClassSym] = originalClass;
    newClass.prototype = Object.create(originalClass.prototype);
    Object.defineProperty(newClass, 'name', {
        value: originalClass.name,
    });
    Object.setPrototypeOf(newClass, originalClass);
    for (const field of schemaFields) {
        Object.defineProperty(newClass, field, {
            configurable: true,
            enumerable: true,
            get() {
                return newClass[def_1.GeneratedSym][field];
            },
            set(value) {
                newClass[def_1.GeneratedSym][field] = value;
            },
        });
    }
    for (const functionField of schemaFunctions) {
        if (newClass[functionField]) {
            continue;
        }
        Object.defineProperty(newClass, functionField, {
            configurable: true,
            enumerable: false,
            writable: false,
            value: schemastery_1.default.prototype[functionField].bind(newClass),
        });
    }
    Object.defineProperty(newClass, 'toJSON', {
        configurable: true,
        enumerable: false,
        writable: false,
        value: () => schemastery_1.default.prototype.toJSON.call({ ...newClass, toJSON: undefined }),
    });
    newClass.toString = schema.toString.bind(schema);
    newClass[kschema_1.kSchema] = true;
    return newClass;
}
exports.SchemaClass = SchemaClass;
function RegisterSchema(options = {}) {
    return function (originalClass) {
        metadata_1.Metadata.set('SchemaClassOptions', options)(originalClass);
        return SchemaClass(originalClass);
    };
}
exports.RegisterSchema = RegisterSchema;
//# sourceMappingURL=register.js.map