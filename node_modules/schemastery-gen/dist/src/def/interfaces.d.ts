import Schema from 'schemastery';
export declare type ClassType<T> = {
    new (...args: any[]): T;
};
export declare type SchemaNativeType = 'string' | 'number' | 'boolean' | 'object' | 'any' | 'never';
export declare type SchemaSource<S = any, T = S> = null | undefined | string | number | boolean | Schema<S, T> | Function | {
    new (...args: any[]): any;
};
export interface SchemaReference<S = any, T = S> {
    [RefSym]: true;
    factory: () => SchemaType<S, T>;
}
export declare type SchemaOrReference<S = any, T = S> = Schema<S, T> | SchemaReference<S, T>;
export declare type SchemaType<S = any, T = S> = SchemaNativeType | SchemaSource<S, T> | SchemaReference<S, T>;
export declare type SchemaClassOptions = Schema.Meta<any>;
export interface SchemaOptions extends SchemaClassOptions {
    dict?: boolean | Schema<any, string> | string;
    array?: boolean;
    type?: SchemaType;
}
export declare type SchemaOptionsDict<T> = {
    [P in keyof T]?: SchemaOptions;
};
export declare const RefSym: unique symbol;
export declare const GeneratedSym: unique symbol;
export declare const OriginalClassSym: unique symbol;
declare type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
declare type ArrayToUnion<T extends any[]> = T[number];
declare type Intersecton<T extends any[]> = UnionToIntersection<ArrayToUnion<T>>;
export declare type AnyClass = {
    new (...args: any[]): any;
};
declare type TypeOf<T> = T extends {
    new (...args: any[]): infer R;
} ? R : never;
declare type ClassesToTypes<A extends any[]> = A extends [infer L, ...infer R] ? [TypeOf<L>, ...ClassesToTypes<R>] : [];
export declare type FusionClass<A extends AnyClass[]> = new () => Intersecton<ClassesToTypes<A>>;
export {};
