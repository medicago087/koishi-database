"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stripDataPrefix = exports.resizeInput = exports.closestMultiple = exports.login = exports.NetworkError = exports.calcEncryptionKey = exports.calcAccessKey = exports.download = exports.arrayBufferToBase64 = exports.getImageSize = exports.project = void 0;
const koishi_1 = require("koishi");
const libsodium_wrappers_1 = require("libsodium-wrappers");
const image_size_1 = __importDefault(require("image-size"));
function project(object, mapping) {
    const result = {};
    for (const key in mapping) {
        result[key] = object[mapping[key]];
    }
    return result;
}
exports.project = project;
function getImageSize(buffer) {
    if (process.env.KOISHI_ENV === 'browser') {
        const blob = new Blob([buffer]);
        const image = new Image();
        image.src = URL.createObjectURL(blob);
        return (0, koishi_1.pick)(image, ['width', 'height']);
    }
    else {
        return (0, image_size_1.default)(Buffer.from(buffer));
    }
}
exports.getImageSize = getImageSize;
function arrayBufferToBase64(buffer) {
    if (process.env.KOISHI_ENV === 'browser') {
        let result = '';
        const chunk = 8192;
        for (let index = 0; index < buffer.byteLength; index += chunk) {
            result += String.fromCharCode.apply(null, buffer.slice(index, index + chunk));
        }
        return btoa(result);
    }
    else {
        return Buffer.from(buffer).toString('base64');
    }
}
exports.arrayBufferToBase64 = arrayBufferToBase64;
const MAX_OUTPUT_SIZE = 1048576;
const MAX_CONTENT_SIZE = 10485760;
const ALLOWED_TYPES = ['image/jpeg', 'image/png'];
async function download(ctx, url, headers = {}) {
    if (url.startsWith('data:')) {
        const [, type, base64] = url.match(/^data:(image\/\w+);base64,(.*)$/);
        if (!ALLOWED_TYPES.includes(type)) {
            throw new NetworkError('.unsupported-file-type');
        }
        const binary = atob(base64);
        const result = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            result[i] = binary.charCodeAt(i);
        }
        return [result, base64];
    }
    else {
        const head = await ctx.http.head(url, { headers });
        if (+head['content-length'] > MAX_CONTENT_SIZE) {
            throw new NetworkError('.file-too-large');
        }
        if (!ALLOWED_TYPES.includes(head['content-type'])) {
            throw new NetworkError('.unsupported-file-type');
        }
        const buffer = await ctx.http.get(url, { responseType: 'arraybuffer', headers });
        return [buffer, arrayBufferToBase64(buffer)];
    }
}
exports.download = download;
async function calcAccessKey(email, password) {
    await libsodium_wrappers_1.ready;
    return (0, libsodium_wrappers_1.crypto_pwhash)(64, new Uint8Array(Buffer.from(password)), (0, libsodium_wrappers_1.crypto_generichash)(libsodium_wrappers_1.crypto_pwhash_SALTBYTES, password.slice(0, 6) + email + 'novelai_data_access_key'), 2, 2e6, libsodium_wrappers_1.crypto_pwhash_ALG_ARGON2ID13, 'base64').slice(0, 64);
}
exports.calcAccessKey = calcAccessKey;
async function calcEncryptionKey(email, password) {
    await libsodium_wrappers_1.ready;
    return (0, libsodium_wrappers_1.crypto_pwhash)(128, new Uint8Array(Buffer.from(password)), (0, libsodium_wrappers_1.crypto_generichash)(libsodium_wrappers_1.crypto_pwhash_SALTBYTES, password.slice(0, 6) + email + 'novelai_data_encryption_key'), 2, 2e6, libsodium_wrappers_1.crypto_pwhash_ALG_ARGON2ID13, 'base64');
}
exports.calcEncryptionKey = calcEncryptionKey;
class NetworkError extends Error {
    constructor(message, params = {}) {
        super(message);
        this.params = params;
    }
}
exports.NetworkError = NetworkError;
NetworkError.catch = (mapping) => (e) => {
    if (koishi_1.Quester.isAxiosError(e)) {
        const code = e.response?.status;
        for (const key in mapping) {
            if (code === +key) {
                throw new NetworkError(mapping[key]);
            }
        }
    }
    throw e;
};
async function login(ctx) {
    if (ctx.config.type === 'token') {
        await ctx.http.get(ctx.config.endpoint + '/user/subscription', {
            timeout: 30000,
            headers: { authorization: 'Bearer ' + ctx.config.token },
        }).catch(NetworkError.catch({ 401: '.invalid-token' }));
        return ctx.config.token;
    }
    else if (ctx.config.type === 'login' && process.env.KOISHI_ENV !== 'browser') {
        return ctx.http.post(ctx.config.endpoint + '/user/login', {
            timeout: 30000,
            key: await calcAccessKey(ctx.config.email, ctx.config.password),
        }).catch(NetworkError.catch({ 401: '.invalid-password' })).then(res => res.accessToken);
    }
    else {
        return ctx.config.token;
    }
}
exports.login = login;
function closestMultiple(num, mult = 64) {
    const floor = Math.floor(num / mult) * mult;
    const ceil = Math.ceil(num / mult) * mult;
    const closest = num - floor < ceil - num ? floor : ceil;
    if (Number.isNaN(closest))
        return 0;
    return closest <= 0 ? mult : closest;
}
exports.closestMultiple = closestMultiple;
function resizeInput(size) {
    // if width and height produce a valid size, use it
    const { width, height } = size;
    if (width % 64 === 0 && height % 64 === 0 && width * height <= MAX_OUTPUT_SIZE) {
        return { width, height };
    }
    // otherwise, set lower size as 512 and use aspect ratio to the other dimension
    const aspectRatio = width / height;
    if (aspectRatio > 1) {
        const height = 512;
        const width = closestMultiple(height * aspectRatio);
        // check that image is not too large
        if (width * height <= MAX_OUTPUT_SIZE) {
            return { width, height };
        }
    }
    else {
        const width = 512;
        const height = closestMultiple(width / aspectRatio);
        // check that image is not too large
        if (width * height <= MAX_OUTPUT_SIZE) {
            return { width, height };
        }
    }
    // if that fails set the higher size as 1024 and use aspect ratio to the other dimension
    if (aspectRatio > 1) {
        const width = 1024;
        const height = closestMultiple(width / aspectRatio);
        return { width, height };
    }
    else {
        const height = 1024;
        const width = closestMultiple(height * aspectRatio);
        return { width, height };
    }
}
exports.resizeInput = resizeInput;
function stripDataPrefix(base64) {
    // workaround for different gradio versions
    // https://github.com/koishijs/novelai-bot/issues/90
    return base64.replace(/^data:image\/[\w-]+;base64,/, '');
}
exports.stripDataPrefix = stripDataPrefix;
