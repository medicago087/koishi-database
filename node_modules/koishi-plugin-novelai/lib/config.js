"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseInput = exports.parseForbidden = exports.Config = exports.PromptConfig = exports.sampler = exports.orients = exports.models = exports.orientMap = exports.modelMap = void 0;
const koishi_1 = require("koishi");
exports.modelMap = {
    safe: 'safe-diffusion',
    nai: 'nai-diffusion',
    furry: 'nai-diffusion-furry',
};
exports.orientMap = {
    landscape: { height: 512, width: 768 },
    portrait: { height: 768, width: 512 },
    square: { height: 640, width: 640 },
};
const ucPreset = [
    'nsfw, lowres, bad anatomy, bad hands, text, error, missing fingers',
    'extra digit, fewer digits, cropped, worst quality, low quality',
    'normal quality, jpeg artifacts, signature, watermark, username, blurry',
].join(', ');
exports.models = Object.keys(exports.modelMap);
exports.orients = Object.keys(exports.orientMap);
var sampler;
(function (sampler_1) {
    sampler_1.nai = {
        'k_euler_a': 'Euler ancestral',
        'k_euler': 'Euler',
        'k_lms': 'LMS',
        'ddim': 'DDIM',
        'plms': 'PLMS',
    };
    sampler_1.sd = {
        'k_euler_a': 'Euler a',
        'k_euler': 'Euler',
        'k_lms': 'LMS',
        'k_heun': 'Heun',
        'k_dpm_2': 'DPM2',
        'k_dpm_2_a': 'DPM2 a',
        'k_dpmpp_2s_a': 'DPM++ 2S a',
        'k_dpmpp_2m': 'DPM++ 2M',
        'k_dpm_fast': 'DPM fast',
        'k_dpm_ad': 'DPM adaptive',
        'k_lms_ka': 'LMS Karras',
        'k_dpm_2_ka': 'DPM2 Karras',
        'k_dpm_2_a_ka': 'DPM2 a Karras',
        'k_dpmpp_2s_a_ka': 'DPM++ 2S a Karras',
        'k_dpmpp_2m_ka': 'DPM++ 2M Karras',
        'ddim': 'DDIM',
        'plms': 'PLMS',
    };
    function createSchema(map) {
        return koishi_1.Schema.union(Object.entries(map).map(([key, value]) => {
            return koishi_1.Schema.const(key).description(value);
        })).description('默认的采样器。').default('k_euler_a');
    }
    sampler_1.createSchema = createSchema;
    function sd2nai(sampler) {
        if (sampler === 'k_euler_a')
            return 'k_euler_ancestral';
        if (sampler in sampler_1.nai)
            return sampler;
        return 'k_euler_ancestral';
    }
    sampler_1.sd2nai = sd2nai;
})(sampler = exports.sampler || (exports.sampler = {}));
exports.PromptConfig = koishi_1.Schema.object({
    basePrompt: koishi_1.Schema.string().role('textarea').description('默认附加的标签。').default('masterpiece, best quality'),
    negativePrompt: koishi_1.Schema.string().role('textarea').description('默认附加的反向标签。').default(ucPreset),
    forbidden: koishi_1.Schema.string().role('textarea').description('违禁词列表。含有违禁词的请求将被拒绝。').default(''),
    placement: koishi_1.Schema.union([
        koishi_1.Schema.const('before').description('置于最前'),
        koishi_1.Schema.const('after').description('置于最后'),
    ]).description('默认附加标签的位置。').default('after'),
    translator: koishi_1.Schema.boolean().description('是否启用自动翻译。').default(true),
    latinOnly: koishi_1.Schema.boolean().description('是否只接受英文输入。').default(false),
    maxWords: koishi_1.Schema.natural().description('允许的最大单词数量。').default(0),
}).description('输入设置');
exports.Config = koishi_1.Schema.intersect([
    koishi_1.Schema.object({
        type: koishi_1.Schema.union([
            koishi_1.Schema.const('token').description('授权令牌'),
            ...process.env.KOISHI_ENV === 'browser' ? [] : [koishi_1.Schema.const('login').description('账号密码')],
            koishi_1.Schema.const('naifu').description('naifu'),
            koishi_1.Schema.const('sd-webui').description('sd-webui'),
        ]).description('登录方式'),
    }).description('登录设置'),
    koishi_1.Schema.union([
        koishi_1.Schema.intersect([
            koishi_1.Schema.union([
                koishi_1.Schema.object({
                    type: koishi_1.Schema.const('token'),
                    token: koishi_1.Schema.string().description('授权令牌。').role('secret').required(),
                }),
                koishi_1.Schema.object({
                    type: koishi_1.Schema.const('login'),
                    email: koishi_1.Schema.string().description('账号邮箱。').required(),
                    password: koishi_1.Schema.string().description('账号密码。').role('secret').required(),
                }),
            ]),
            koishi_1.Schema.object({
                endpoint: koishi_1.Schema.string().description('API 服务器地址。').default('https://api.novelai.net'),
                headers: koishi_1.Schema.dict(String).description('要附加的额外请求头。').default({
                    'referer': 'https://novelai.net/',
                    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36',
                }),
                allowAnlas: koishi_1.Schema.union([
                    koishi_1.Schema.const(true).description('允许'),
                    koishi_1.Schema.const(false).description('禁止'),
                    koishi_1.Schema.natural().description('权限等级').default(1),
                ]).default(true).description('是否允许使用点数。禁用后部分功能 (图片增强和手动设置某些参数) 将无法使用。'),
            }),
        ]),
        koishi_1.Schema.object({
            type: koishi_1.Schema.const('naifu'),
            token: koishi_1.Schema.string().description('授权令牌。').role('secret'),
            endpoint: koishi_1.Schema.string().description('API 服务器地址。').required(),
            headers: koishi_1.Schema.dict(String).description('要附加的额外请求头。'),
        }),
        koishi_1.Schema.object({
            type: koishi_1.Schema.const('sd-webui'),
            endpoint: koishi_1.Schema.string().description('API 服务器地址。').required(),
            headers: koishi_1.Schema.dict(String).description('要附加的额外请求头。'),
        }),
    ]),
    koishi_1.Schema.union([
        koishi_1.Schema.object({
            type: koishi_1.Schema.const('sd-webui'),
            sampler: sampler.createSchema(sampler.sd),
        }).description('参数设置'),
        koishi_1.Schema.object({
            type: koishi_1.Schema.const('naifu'),
            sampler: sampler.createSchema(sampler.nai),
        }).description('参数设置'),
        koishi_1.Schema.object({
            model: koishi_1.Schema.union(exports.models).description('默认的生成模型。').default('nai'),
            sampler: sampler.createSchema(sampler.nai),
        }).description('参数设置'),
    ]),
    koishi_1.Schema.object({
        orient: koishi_1.Schema.union(exports.orients).description('默认的图片方向。').default('portrait'),
        maxSteps: koishi_1.Schema.natural().description('允许的最大迭代步数。').default(0),
        maxResolution: koishi_1.Schema.natural().description('生成图片的最大尺寸。').default(0),
    }),
    exports.PromptConfig,
    koishi_1.Schema.object({
        output: koishi_1.Schema.union([
            koishi_1.Schema.const('minimal').description('只发送图片'),
            koishi_1.Schema.const('default').description('发送图片和关键信息'),
            koishi_1.Schema.const('verbose').description('发送全部信息'),
        ]).description('输出方式。').default('default'),
        maxRetryCount: koishi_1.Schema.natural().description('连接失败时最大的重试次数。').default(3),
        requestTimeout: koishi_1.Schema.number().role('time').description('当请求超过这个时间时会中止并提示超时。').default(koishi_1.Time.minute),
        recallTimeout: koishi_1.Schema.number().role('time').description('图片发送后自动撤回的时间 (设置为 0 以禁用此功能)。').default(0),
        maxConcurrency: koishi_1.Schema.number().description('单个频道下的最大并发数量 (设置为 0 以禁用此功能)。').default(0),
    }).description('高级设置'),
]);
function parseForbidden(input) {
    return input.trim()
        .toLowerCase()
        .replace(/，/g, ',')
        .split(/(?:,\s*|\s*\n\s*)/g)
        .filter(Boolean)
        .map((pattern) => {
        const strict = pattern.endsWith('!');
        if (strict)
            pattern = pattern.slice(0, -1);
        pattern = pattern.replace(/[^a-z0-9]+/g, ' ').trim();
        return { pattern, strict };
    });
}
exports.parseForbidden = parseForbidden;
const backslash = /@@__BACKSLASH__@@/g;
function parseInput(input, config, forbidden, override) {
    input = input.toLowerCase()
        .replace(/\\\\/g, backslash.source)
        .replace(/，/g, ',')
        .replace(/（/g, '(')
        .replace(/）/g, ')');
    if (config.type === 'sd-webui') {
        input = input
            .split('\\{').map(s => s.replace(/\{/g, '(')).join('\\{')
            .split('\\}').map(s => s.replace(/\}/g, ')')).join('\\}');
    }
    else {
        input = input
            .split('\\(').map(s => s.replace(/\(/g, '{')).join('\\(')
            .split('\\)').map(s => s.replace(/\)/g, '}')).join('\\)');
    }
    input = input
        .replace(backslash, '\\')
        .replace(/_/g, ' ');
    if (config.latinOnly && /[^\s\w"'“”‘’.,:|\\()\[\]{}-]/.test(input)) {
        return ['.latin-only'];
    }
    const negative = [];
    const appendToList = (words, input) => {
        const tags = input.split(/,\s*/g);
        if (config.placement === 'before')
            tags.reverse();
        for (let tag of tags) {
            tag = tag.trim().toLowerCase();
            if (!tag || words.includes(tag))
                continue;
            if (config.placement === 'before') {
                words.unshift(tag);
            }
            else {
                words.push(tag);
            }
        }
    };
    // extract negative prompts
    const capture = input.match(/(,\s*|\s+)(-u\s+|--undesired\s+|negative prompts?:\s*)([\s\S]+)/m);
    if (capture?.[3]) {
        input = input.slice(0, capture.index).trim();
        appendToList(negative, capture[3]);
    }
    // remove forbidden words
    const positive = input.split(/,\s*/g).filter((word) => {
        word = word.replace(/[\x00-\x7f]/g, s => s.replace(/[^0-9a-zA-Z]/, ' ')).replace(/\s+/, ' ').trim();
        if (!word)
            return false;
        for (const { pattern, strict } of forbidden) {
            if (strict && word.split(/\W+/g).includes(pattern)) {
                return false;
            }
            else if (!strict && word.includes(pattern)) {
                return false;
            }
        }
        return true;
    });
    if (Math.max(getWordCount(positive), getWordCount(negative)) > (config.maxWords || Infinity)) {
        return ['.too-many-words'];
    }
    if (!override) {
        appendToList(positive, config.basePrompt);
        appendToList(negative, config.negativePrompt);
    }
    return [null, positive.join(', '), negative.join(', ')];
}
exports.parseInput = parseInput;
function getWordCount(words) {
    return words.join(' ').replace(/[^a-z0-9]+/g, ' ').trim().split(' ').length;
}
