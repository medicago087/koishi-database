"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.apply = exports.name = exports.reactive = void 0;
const koishi_1 = require("koishi");
const config_1 = require("./config");
const utils_1 = require("./utils");
__exportStar(require("./config"), exports);
exports.reactive = true;
exports.name = 'novelai';
const logger = new koishi_1.Logger('novelai');
function handleError(session, err) {
    if (koishi_1.Quester.isAxiosError(err)) {
        if (err.response?.status === 402) {
            return session.text('.unauthorized');
        }
        else if (err.response?.status) {
            return session.text('.response-error', [err.response.status]);
        }
        else if (err.code === 'ETIMEDOUT') {
            return session.text('.request-timeout');
        }
        else if (err.code) {
            return session.text('.request-failed', [err.code]);
        }
    }
    logger.error(err);
    return session.text('.unknown-error');
}
function apply(ctx, config) {
    ctx.i18n.define('zh', require('./locales/zh-CN'));
    ctx.i18n.define('zh-TW', require('./locales/zh-TW'));
    ctx.i18n.define('en', require('./locales/en-US'));
    ctx.i18n.define('fr', require('./locales/fr-FR'));
    ctx.i18n.define('ja', require('./locales/ja-JP'));
    let forbidden;
    const tasks = Object.create(null);
    const globalTasks = new Set();
    ctx.accept(['forbidden'], (config) => {
        forbidden = (0, config_1.parseForbidden)(config.forbidden);
    }, { immediate: true });
    let tokenTask = null;
    const getToken = () => tokenTask || (tokenTask = (0, utils_1.login)(ctx));
    ctx.accept(['token', 'type', 'email', 'password'], () => tokenTask = null);
    const thirdParty = () => !['login', 'token'].includes(config.type);
    const restricted = (session) => {
        if (thirdParty())
            return false;
        if (typeof config.allowAnlas === 'boolean') {
            return !config.allowAnlas;
        }
        else {
            return session.user.authority < config.allowAnlas;
        }
    };
    const step = (source) => {
        const value = +source;
        if (value * 0 === 0 && Math.floor(value) === value && value > 0 && value <= (config.maxSteps || Infinity))
            return value;
        throw new Error();
    };
    const resolution = (source, session) => {
        if (source in config_1.orientMap)
            return config_1.orientMap[source];
        if (restricted(session))
            throw new Error();
        const cap = source.match(/^(\d+)[x×](\d+)$/);
        if (!cap)
            throw new Error();
        const width = (0, utils_1.closestMultiple)(+cap[1]);
        const height = (0, utils_1.closestMultiple)(+cap[2]);
        if (Math.max(width, height) > (config.maxResolution || Infinity)) {
            throw new Error();
        }
        return { width, height };
    };
    const cmd = ctx.command('novelai <prompts:text>')
        .alias('nai')
        .userFields(['authority'])
        .shortcut('画画', { fuzzy: true })
        .shortcut('畫畫', { fuzzy: true })
        .shortcut('约稿', { fuzzy: true })
        .shortcut('約稿', { fuzzy: true })
        .shortcut('增强', { fuzzy: true, options: { enhance: true } })
        .shortcut('增強', { fuzzy: true, options: { enhance: true } })
        .option('enhance', '-e', { hidden: restricted })
        .option('model', '-m <model>', { type: config_1.models, hidden: thirdParty })
        .option('resolution', '-r <resolution>', { type: resolution })
        .option('override', '-O')
        .option('sampler', '-s <sampler>')
        .option('seed', '-x <seed:number>')
        .option('steps', '-t <step>', { type: step, hidden: restricted })
        .option('scale', '-c <scale:number>')
        .option('noise', '-n <noise:number>', { hidden: restricted })
        .option('strength', '-N <strength:number>', { hidden: restricted })
        .option('undesired', '-u <undesired>')
        .option('noTranslator', '-T', { hidden: () => !ctx.translator || !config.translator })
        .option('iterations', '-i <iterations:posint>', { fallback: 1, hidden: () => config.maxIteration <= 1 })
        .action(async ({ session, options }, input) => {
        var _a;
        if (!input?.trim())
            return session.execute('help novelai');
        if (options.iterations && options.iterations > config.maxIteration) {
            return session.text('.exceed-max-iteration', [config.maxIteration]);
        }
        let imgUrl, image;
        if (!restricted(session)) {
            input = koishi_1.segment.transform(input, {
                image(attrs) {
                    imgUrl = attrs.url;
                    return '';
                },
            });
            if (options.enhance && !imgUrl) {
                return session.text('.expect-image');
            }
            if (!input.trim() && !config.basePrompt) {
                return session.text('.expect-prompt');
            }
        }
        else {
            delete options.enhance;
            delete options.steps;
        }
        if (config.translator && ctx.translator && !options.noTranslator) {
            try {
                input = await ctx.translator.translate({ input, target: 'en' });
            }
            catch (err) {
                logger.warn(err);
            }
        }
        const [errPath, prompt, uc] = (0, config_1.parseInput)(input, config, forbidden, options.override);
        if (errPath)
            return session.text(errPath);
        let token;
        try {
            token = await getToken();
        }
        catch (err) {
            if (err instanceof utils_1.NetworkError) {
                return session.text(err.message, err.params);
            }
            logger.error(err);
            return session.text('.unknown-error');
        }
        const model = config_1.modelMap[options.model];
        const seed = options.seed || Math.floor(Math.random() * Math.pow(2, 32));
        const parameters = {
            seed,
            prompt,
            n_samples: 1,
            uc,
            // 0: low quality + bad anatomy
            // 1: low quality
            // 2: none
            ucPreset: 2,
            qualityToggle: false,
        };
        if (imgUrl) {
            try {
                image = await (0, utils_1.download)(ctx, imgUrl);
            }
            catch (err) {
                if (err instanceof utils_1.NetworkError) {
                    return session.text(err.message, err.params);
                }
                logger.error(err);
                return session.text('.download-error');
            }
            Object.assign(parameters, {
                scale: options.scale ?? 11,
                steps: options.steps ?? 50,
            });
            if (options.enhance) {
                const size = (0, utils_1.getImageSize)(image.buffer);
                if (size.width + size.height !== 1280) {
                    return session.text('.invalid-size');
                }
                Object.assign(parameters, {
                    height: size.height * 1.5,
                    width: size.width * 1.5,
                    noise: options.noise ?? 0,
                    strength: options.strength ?? 0.2,
                });
            }
            else {
                options.resolution || (options.resolution = (0, utils_1.resizeInput)((0, utils_1.getImageSize)(image.buffer)));
                Object.assign(parameters, {
                    height: options.resolution.height,
                    width: options.resolution.width,
                    noise: options.noise ?? 0.2,
                    strength: options.strength ?? 0.7,
                });
            }
        }
        else {
            options.resolution || (options.resolution = config_1.orientMap[config.orient]);
            Object.assign(parameters, {
                height: options.resolution.height,
                width: options.resolution.width,
                scale: options.scale ?? 11,
                steps: options.steps ?? 28,
            });
        }
        const getRandomId = () => Math.random().toString(36).slice(2);
        const iterations = Array(options.iterations).fill(0).map(getRandomId);
        if (config.maxConcurrency) {
            const store = tasks[_a = session.cid] || (tasks[_a] = new Set());
            if (store.size >= config.maxConcurrency) {
                return session.text('.concurrent-jobs');
            }
            else {
                iterations.forEach((id) => store.add(id));
            }
        }
        session.send(globalTasks.size
            ? session.text('.pending', [globalTasks.size])
            : session.text('.waiting'));
        iterations.forEach((id) => globalTasks.add(id));
        const cleanUp = (id) => {
            tasks[session.cid]?.delete(id);
            globalTasks.delete(id);
        };
        const path = (() => {
            switch (config.type) {
                case 'sd-webui':
                    return image ? '/sdapi/v1/img2img' : '/sdapi/v1/txt2img';
                case 'naifu':
                    return '/generate-stream';
                default:
                    return '/ai/generate-image';
            }
        })();
        const getPayload = () => {
            if (config.type !== 'sd-webui') {
                parameters.sampler = config_1.sampler.sd2nai(options.sampler);
                parameters.image = image?.base64; // NovelAI / NAIFU accepts bare base64 encoded image
                if (config.type === 'naifu')
                    return parameters;
                return { model, input: prompt, parameters: (0, koishi_1.omit)(parameters, ['prompt']) };
            }
            return {
                sampler_index: config_1.sampler.sd[options.sampler],
                init_images: image && [image.dataUrl],
                ...(0, utils_1.project)(parameters, {
                    prompt: 'prompt',
                    batch_size: 'n_samples',
                    seed: 'seed',
                    negative_prompt: 'uc',
                    cfg_scale: 'scale',
                    steps: 'steps',
                    width: 'width',
                    height: 'height',
                    denoising_strength: 'strength',
                }),
            };
        };
        const iterate = async () => {
            const request = () => ctx.http.axios((0, koishi_1.trimSlash)(config.endpoint) + path, {
                method: 'POST',
                timeout: config.requestTimeout,
                headers: {
                    ...config.headers,
                    authorization: 'Bearer ' + token,
                },
                data: getPayload(),
            }).then((res) => {
                if (config.type === 'sd-webui') {
                    return (0, utils_1.stripDataPrefix)(res.data.images[0]);
                }
                // event: newImage
                // id: 1
                // data:
                return res.data?.slice(27);
            });
            let base64, count = 0;
            while (true) {
                try {
                    base64 = await request();
                    break;
                }
                catch (err) {
                    if (koishi_1.Quester.isAxiosError(err)) {
                        if (err.code && err.code !== 'ETIMEDOUT' && ++count < config.maxRetryCount) {
                            continue;
                        }
                    }
                    return await session.send(handleError(session, err));
                }
            }
            if (!base64.trim())
                return await session.send(session.text('.empty-response'));
            function getContent() {
                if (config.output === 'minimal')
                    return koishi_1.segment.image('base64://' + base64);
                const attrs = {
                    userId: session.userId,
                    nickname: session.author?.nickname || session.username,
                };
                const result = (0, koishi_1.segment)('figure');
                const lines = [`seed = ${parameters.seed}`];
                if (config.output === 'verbose') {
                    if (!thirdParty()) {
                        lines.push(`model = ${model}`);
                    }
                    lines.push(`sampler = ${options.sampler}`, `steps = ${parameters.steps}`, `scale = ${parameters.scale}`);
                    if (parameters.image) {
                        lines.push(`strength = ${parameters.strength}`, `noise = ${parameters.noise}`);
                    }
                }
                result.children.push((0, koishi_1.segment)('message', attrs, lines.join('\n')));
                result.children.push((0, koishi_1.segment)('message', attrs, `prompt = ${prompt}`));
                if (config.output === 'verbose') {
                    result.children.push((0, koishi_1.segment)('message', attrs, `undesired = ${uc}`));
                }
                result.children.push((0, koishi_1.segment)('message', attrs, koishi_1.segment.image('base64://' + base64)));
                return result;
            }
            const messageIds = await session.send(getContent());
            if (messageIds.length && config.recallTimeout) {
                ctx.setTimeout(() => {
                    for (const id of messageIds) {
                        session.bot.deleteMessage(session.channelId, id);
                    }
                }, config.recallTimeout);
            }
        };
        while (iterations.length) {
            try {
                await iterate();
                cleanUp(iterations.pop());
                parameters.seed++;
            }
            catch (err) {
                iterations.forEach(cleanUp);
                throw err;
            }
        }
    });
    ctx.accept(['model', 'orient', 'sampler'], (config) => {
        cmd._options.model.fallback = config.model;
        cmd._options.sampler.fallback = config.sampler;
        cmd._options.sampler.type = Object.keys(config.type === 'sd-webui' ? config_1.sampler.sd : config_1.sampler.nai);
    }, { immediate: true });
}
exports.apply = apply;
